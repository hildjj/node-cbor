/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/.pnpm/css-loader@5.1.0_webpack@5.24.2/node_modules/css-loader/dist/cjs.js!./src/style.css":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/css-loader@5.1.0_webpack@5.24.2/node_modules/css-loader/dist/cjs.js!./src/style.css ***!
  \****************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_pnpm_css_loader_5_1_0_webpack_5_24_2_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/.pnpm/css-loader@5.1.0_webpack@5.24.2/node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/.pnpm/css-loader@5.1.0_webpack@5.24.2/node_modules/css-loader/dist/runtime/api.js\");\n/* harmony import */ var _node_modules_pnpm_css_loader_5_1_0_webpack_5_24_2_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_css_loader_5_1_0_webpack_5_24_2_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _node_modules_pnpm_css_loader_5_1_0_webpack_5_24_2_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(function(i){return i[1]});\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"body {\\n  font-family: Arial, Helvetica, sans-serif;\\n  background-color:cornsilk;\\n}\\n\\n.container {\\n  display: flex;\\n  flex-flow: row wrap;\\n  align-items: flex-start;\\n}\\n\\n.cmd {\\n  margin: 0 10px 5px 10px;\\n}\\n\\n#to {\\n  float: right;\\n}\\n\\nh3 {\\n  margin: 0 10px 5px 10px;\\n}\\n\\ntextarea {\\n  margin: 0 10px 0 10px;\\n}\\n\\n.power {\\n  margin: 10px;\\n}\\n\", \"\"]);\n// Exports\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);\n\n\n//# sourceURL=webpack://webpack-demo/./src/style.css?./node_modules/.pnpm/css-loader@5.1.0_webpack@5.24.2/node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/.pnpm/css-loader@5.1.0_webpack@5.24.2/node_modules/css-loader/dist/runtime/api.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/.pnpm/css-loader@5.1.0_webpack@5.24.2/node_modules/css-loader/dist/runtime/api.js ***!
  \********************************************************************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (cssWithMappingToString) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join(\"\");\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery, dedupe) {\n    if (typeof modules === \"string\") {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, \"\"]];\n    }\n\n    var alreadyImportedModules = {};\n\n    if (dedupe) {\n      for (var i = 0; i < this.length; i++) {\n        // eslint-disable-next-line prefer-destructuring\n        var id = this[i][0];\n\n        if (id != null) {\n          alreadyImportedModules[id] = true;\n        }\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = [].concat(modules[_i]);\n\n      if (dedupe && alreadyImportedModules[item[0]]) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n\n      if (mediaQuery) {\n        if (!item[2]) {\n          item[2] = mediaQuery;\n        } else {\n          item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n        }\n      }\n\n      list.push(item);\n    }\n  };\n\n  return list;\n};\n\n//# sourceURL=webpack://webpack-demo/./node_modules/.pnpm/css-loader@5.1.0_webpack@5.24.2/node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _node_modules_pnpm_style_loader_2_0_0_webpack_5_24_2_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.2/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.2/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\");\n/* harmony import */ var _node_modules_pnpm_style_loader_2_0_0_webpack_5_24_2_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_pnpm_style_loader_2_0_0_webpack_5_24_2_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _node_modules_pnpm_css_loader_5_1_0_webpack_5_24_2_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !!../node_modules/.pnpm/css-loader@5.1.0_webpack@5.24.2/node_modules/css-loader/dist/cjs.js!./style.css */ \"./node_modules/.pnpm/css-loader@5.1.0_webpack@5.24.2/node_modules/css-loader/dist/cjs.js!./src/style.css\");\n\n            \n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = _node_modules_pnpm_style_loader_2_0_0_webpack_5_24_2_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_pnpm_css_loader_5_1_0_webpack_5_24_2_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_1__.default, options);\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_pnpm_css_loader_5_1_0_webpack_5_24_2_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_1__.default.locals || {});\n\n//# sourceURL=webpack://webpack-demo/./src/style.css?");

/***/ }),

/***/ "./node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.2/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!*********************************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.2/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \*********************************************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nvar stylesInDom = [];\n\nfunction getIndexByIdentifier(identifier) {\n  var result = -1;\n\n  for (var i = 0; i < stylesInDom.length; i++) {\n    if (stylesInDom[i].identifier === identifier) {\n      result = i;\n      break;\n    }\n  }\n\n  return result;\n}\n\nfunction modulesToDom(list, options) {\n  var idCountMap = {};\n  var identifiers = [];\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var count = idCountMap[id] || 0;\n    var identifier = \"\".concat(id, \" \").concat(count);\n    idCountMap[id] = count + 1;\n    var index = getIndexByIdentifier(identifier);\n    var obj = {\n      css: item[1],\n      media: item[2],\n      sourceMap: item[3]\n    };\n\n    if (index !== -1) {\n      stylesInDom[index].references++;\n      stylesInDom[index].updater(obj);\n    } else {\n      stylesInDom.push({\n        identifier: identifier,\n        updater: addStyle(obj, options),\n        references: 1\n      });\n    }\n\n    identifiers.push(identifier);\n  }\n\n  return identifiers;\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n  var attributes = options.attributes || {};\n\n  if (typeof attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : 0;\n\n    if (nonce) {\n      attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(attributes).forEach(function (key) {\n    style.setAttribute(key, attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.media ? \"@media \".concat(obj.media, \" {\").concat(obj.css, \"}\") : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  } else {\n    style.removeAttribute('media');\n  }\n\n  if (sourceMap && typeof btoa !== 'undefined') {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  list = list || [];\n  var lastIdentifiers = modulesToDom(list, options);\n  return function update(newList) {\n    newList = newList || [];\n\n    if (Object.prototype.toString.call(newList) !== '[object Array]') {\n      return;\n    }\n\n    for (var i = 0; i < lastIdentifiers.length; i++) {\n      var identifier = lastIdentifiers[i];\n      var index = getIndexByIdentifier(identifier);\n      stylesInDom[index].references--;\n    }\n\n    var newLastIdentifiers = modulesToDom(newList, options);\n\n    for (var _i = 0; _i < lastIdentifiers.length; _i++) {\n      var _identifier = lastIdentifiers[_i];\n\n      var _index = getIndexByIdentifier(_identifier);\n\n      if (stylesInDom[_index].references === 0) {\n        stylesInDom[_index].updater();\n\n        stylesInDom.splice(_index, 1);\n      }\n    }\n\n    lastIdentifiers = newLastIdentifiers;\n  };\n};\n\n//# sourceURL=webpack://webpack-demo/./node_modules/.pnpm/style-loader@2.0.0_webpack@5.24.2/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n\n\n//# sourceURL=webpack://webpack-demo/./node_modules/base64-js/index.js?");

/***/ }),

/***/ "./node_modules/bignumber.js/bignumber.js":
/*!************************************************!*\
  !*** ./node_modules/bignumber.js/bignumber.js ***!
  \************************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;;(function (globalObject) {\r\n  'use strict';\r\n\r\n/*\r\n *      bignumber.js v9.0.1\r\n *      A JavaScript library for arbitrary-precision arithmetic.\r\n *      https://github.com/MikeMcl/bignumber.js\r\n *      Copyright (c) 2020 Michael Mclaughlin <M8ch88l@gmail.com>\r\n *      MIT Licensed.\r\n *\r\n *      BigNumber.prototype methods     |  BigNumber methods\r\n *                                      |\r\n *      absoluteValue            abs    |  clone\r\n *      comparedTo                      |  config               set\r\n *      decimalPlaces            dp     |      DECIMAL_PLACES\r\n *      dividedBy                div    |      ROUNDING_MODE\r\n *      dividedToIntegerBy       idiv   |      EXPONENTIAL_AT\r\n *      exponentiatedBy          pow    |      RANGE\r\n *      integerValue                    |      CRYPTO\r\n *      isEqualTo                eq     |      MODULO_MODE\r\n *      isFinite                        |      POW_PRECISION\r\n *      isGreaterThan            gt     |      FORMAT\r\n *      isGreaterThanOrEqualTo   gte    |      ALPHABET\r\n *      isInteger                       |  isBigNumber\r\n *      isLessThan               lt     |  maximum              max\r\n *      isLessThanOrEqualTo      lte    |  minimum              min\r\n *      isNaN                           |  random\r\n *      isNegative                      |  sum\r\n *      isPositive                      |\r\n *      isZero                          |\r\n *      minus                           |\r\n *      modulo                   mod    |\r\n *      multipliedBy             times  |\r\n *      negated                         |\r\n *      plus                            |\r\n *      precision                sd     |\r\n *      shiftedBy                       |\r\n *      squareRoot               sqrt   |\r\n *      toExponential                   |\r\n *      toFixed                         |\r\n *      toFormat                        |\r\n *      toFraction                      |\r\n *      toJSON                          |\r\n *      toNumber                        |\r\n *      toPrecision                     |\r\n *      toString                        |\r\n *      valueOf                         |\r\n *\r\n */\r\n\r\n\r\n  var BigNumber,\r\n    isNumeric = /^-?(?:\\d+(?:\\.\\d*)?|\\.\\d+)(?:e[+-]?\\d+)?$/i,\r\n    mathceil = Math.ceil,\r\n    mathfloor = Math.floor,\r\n\r\n    bignumberError = '[BigNumber Error] ',\r\n    tooManyDigits = bignumberError + 'Number primitive has more than 15 significant digits: ',\r\n\r\n    BASE = 1e14,\r\n    LOG_BASE = 14,\r\n    MAX_SAFE_INTEGER = 0x1fffffffffffff,         // 2^53 - 1\r\n    // MAX_INT32 = 0x7fffffff,                   // 2^31 - 1\r\n    POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13],\r\n    SQRT_BASE = 1e7,\r\n\r\n    // EDITABLE\r\n    // The limit on the value of DECIMAL_PLACES, TO_EXP_NEG, TO_EXP_POS, MIN_EXP, MAX_EXP, and\r\n    // the arguments to toExponential, toFixed, toFormat, and toPrecision.\r\n    MAX = 1E9;                                   // 0 to MAX_INT32\r\n\r\n\r\n  /*\r\n   * Create and return a BigNumber constructor.\r\n   */\r\n  function clone(configObject) {\r\n    var div, convertBase, parseNumeric,\r\n      P = BigNumber.prototype = { constructor: BigNumber, toString: null, valueOf: null },\r\n      ONE = new BigNumber(1),\r\n\r\n\r\n      //----------------------------- EDITABLE CONFIG DEFAULTS -------------------------------\r\n\r\n\r\n      // The default values below must be integers within the inclusive ranges stated.\r\n      // The values can also be changed at run-time using BigNumber.set.\r\n\r\n      // The maximum number of decimal places for operations involving division.\r\n      DECIMAL_PLACES = 20,                     // 0 to MAX\r\n\r\n      // The rounding mode used when rounding to the above decimal places, and when using\r\n      // toExponential, toFixed, toFormat and toPrecision, and round (default value).\r\n      // UP         0 Away from zero.\r\n      // DOWN       1 Towards zero.\r\n      // CEIL       2 Towards +Infinity.\r\n      // FLOOR      3 Towards -Infinity.\r\n      // HALF_UP    4 Towards nearest neighbour. If equidistant, up.\r\n      // HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\r\n      // HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\r\n      // HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\r\n      // HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\r\n      ROUNDING_MODE = 4,                       // 0 to 8\r\n\r\n      // EXPONENTIAL_AT : [TO_EXP_NEG , TO_EXP_POS]\r\n\r\n      // The exponent value at and beneath which toString returns exponential notation.\r\n      // Number type: -7\r\n      TO_EXP_NEG = -7,                         // 0 to -MAX\r\n\r\n      // The exponent value at and above which toString returns exponential notation.\r\n      // Number type: 21\r\n      TO_EXP_POS = 21,                         // 0 to MAX\r\n\r\n      // RANGE : [MIN_EXP, MAX_EXP]\r\n\r\n      // The minimum exponent value, beneath which underflow to zero occurs.\r\n      // Number type: -324  (5e-324)\r\n      MIN_EXP = -1e7,                          // -1 to -MAX\r\n\r\n      // The maximum exponent value, above which overflow to Infinity occurs.\r\n      // Number type:  308  (1.7976931348623157e+308)\r\n      // For MAX_EXP > 1e7, e.g. new BigNumber('1e100000000').plus(1) may be slow.\r\n      MAX_EXP = 1e7,                           // 1 to MAX\r\n\r\n      // Whether to use cryptographically-secure random number generation, if available.\r\n      CRYPTO = false,                          // true or false\r\n\r\n      // The modulo mode used when calculating the modulus: a mod n.\r\n      // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\r\n      // The remainder (r) is calculated as: r = a - n * q.\r\n      //\r\n      // UP        0 The remainder is positive if the dividend is negative, else is negative.\r\n      // DOWN      1 The remainder has the same sign as the dividend.\r\n      //             This modulo mode is commonly known as 'truncated division' and is\r\n      //             equivalent to (a % n) in JavaScript.\r\n      // FLOOR     3 The remainder has the same sign as the divisor (Python %).\r\n      // HALF_EVEN 6 This modulo mode implements the IEEE 754 remainder function.\r\n      // EUCLID    9 Euclidian division. q = sign(n) * floor(a / abs(n)).\r\n      //             The remainder is always positive.\r\n      //\r\n      // The truncated division, floored division, Euclidian division and IEEE 754 remainder\r\n      // modes are commonly used for the modulus operation.\r\n      // Although the other rounding modes can also be used, they may not give useful results.\r\n      MODULO_MODE = 1,                         // 0 to 9\r\n\r\n      // The maximum number of significant digits of the result of the exponentiatedBy operation.\r\n      // If POW_PRECISION is 0, there will be unlimited significant digits.\r\n      POW_PRECISION = 0,                    // 0 to MAX\r\n\r\n      // The format specification used by the BigNumber.prototype.toFormat method.\r\n      FORMAT = {\r\n        prefix: '',\r\n        groupSize: 3,\r\n        secondaryGroupSize: 0,\r\n        groupSeparator: ',',\r\n        decimalSeparator: '.',\r\n        fractionGroupSize: 0,\r\n        fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n        suffix: ''\r\n      },\r\n\r\n      // The alphabet used for base conversion. It must be at least 2 characters long, with no '+',\r\n      // '-', '.', whitespace, or repeated character.\r\n      // '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_'\r\n      ALPHABET = '0123456789abcdefghijklmnopqrstuvwxyz';\r\n\r\n\r\n    //------------------------------------------------------------------------------------------\r\n\r\n\r\n    // CONSTRUCTOR\r\n\r\n\r\n    /*\r\n     * The BigNumber constructor and exported function.\r\n     * Create and return a new instance of a BigNumber object.\r\n     *\r\n     * v {number|string|BigNumber} A numeric value.\r\n     * [b] {number} The base of v. Integer, 2 to ALPHABET.length inclusive.\r\n     */\r\n    function BigNumber(v, b) {\r\n      var alphabet, c, caseChanged, e, i, isNum, len, str,\r\n        x = this;\r\n\r\n      // Enable constructor call without `new`.\r\n      if (!(x instanceof BigNumber)) return new BigNumber(v, b);\r\n\r\n      if (b == null) {\r\n\r\n        if (v && v._isBigNumber === true) {\r\n          x.s = v.s;\r\n\r\n          if (!v.c || v.e > MAX_EXP) {\r\n            x.c = x.e = null;\r\n          } else if (v.e < MIN_EXP) {\r\n            x.c = [x.e = 0];\r\n          } else {\r\n            x.e = v.e;\r\n            x.c = v.c.slice();\r\n          }\r\n\r\n          return;\r\n        }\r\n\r\n        if ((isNum = typeof v == 'number') && v * 0 == 0) {\r\n\r\n          // Use `1 / n` to handle minus zero also.\r\n          x.s = 1 / v < 0 ? (v = -v, -1) : 1;\r\n\r\n          // Fast path for integers, where n < 2147483648 (2**31).\r\n          if (v === ~~v) {\r\n            for (e = 0, i = v; i >= 10; i /= 10, e++);\r\n\r\n            if (e > MAX_EXP) {\r\n              x.c = x.e = null;\r\n            } else {\r\n              x.e = e;\r\n              x.c = [v];\r\n            }\r\n\r\n            return;\r\n          }\r\n\r\n          str = String(v);\r\n        } else {\r\n\r\n          if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);\r\n\r\n          x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n\r\n        // Exponential form?\r\n        if ((i = str.search(/e/i)) > 0) {\r\n\r\n          // Determine exponent.\r\n          if (e < 0) e = i;\r\n          e += +str.slice(i + 1);\r\n          str = str.substring(0, i);\r\n        } else if (e < 0) {\r\n\r\n          // Integer.\r\n          e = str.length;\r\n        }\r\n\r\n      } else {\r\n\r\n        // '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n        intCheck(b, 2, ALPHABET.length, 'Base');\r\n\r\n        // Allow exponential notation to be used with base 10 argument, while\r\n        // also rounding to DECIMAL_PLACES as with other bases.\r\n        if (b == 10) {\r\n          x = new BigNumber(v);\r\n          return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);\r\n        }\r\n\r\n        str = String(v);\r\n\r\n        if (isNum = typeof v == 'number') {\r\n\r\n          // Avoid potential interpretation of Infinity and NaN as base 44+ values.\r\n          if (v * 0 != 0) return parseNumeric(x, str, isNum, b);\r\n\r\n          x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;\r\n\r\n          // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n          if (BigNumber.DEBUG && str.replace(/^0\\.0*|\\./, '').length > 15) {\r\n            throw Error\r\n             (tooManyDigits + v);\r\n          }\r\n        } else {\r\n          x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;\r\n        }\r\n\r\n        alphabet = ALPHABET.slice(0, b);\r\n        e = i = 0;\r\n\r\n        // Check that str is a valid base b number.\r\n        // Don't use RegExp, so alphabet can contain special characters.\r\n        for (len = str.length; i < len; i++) {\r\n          if (alphabet.indexOf(c = str.charAt(i)) < 0) {\r\n            if (c == '.') {\r\n\r\n              // If '.' is not the first character and it has not be found before.\r\n              if (i > e) {\r\n                e = len;\r\n                continue;\r\n              }\r\n            } else if (!caseChanged) {\r\n\r\n              // Allow e.g. hexadecimal 'FF' as well as 'ff'.\r\n              if (str == str.toUpperCase() && (str = str.toLowerCase()) ||\r\n                  str == str.toLowerCase() && (str = str.toUpperCase())) {\r\n                caseChanged = true;\r\n                i = -1;\r\n                e = 0;\r\n                continue;\r\n              }\r\n            }\r\n\r\n            return parseNumeric(x, String(v), isNum, b);\r\n          }\r\n        }\r\n\r\n        // Prevent later check for length on converted number.\r\n        isNum = false;\r\n        str = convertBase(str, b, 10, x.s);\r\n\r\n        // Decimal point?\r\n        if ((e = str.indexOf('.')) > -1) str = str.replace('.', '');\r\n        else e = str.length;\r\n      }\r\n\r\n      // Determine leading zeros.\r\n      for (i = 0; str.charCodeAt(i) === 48; i++);\r\n\r\n      // Determine trailing zeros.\r\n      for (len = str.length; str.charCodeAt(--len) === 48;);\r\n\r\n      if (str = str.slice(i, ++len)) {\r\n        len -= i;\r\n\r\n        // '[BigNumber Error] Number primitive has more than 15 significant digits: {n}'\r\n        if (isNum && BigNumber.DEBUG &&\r\n          len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {\r\n            throw Error\r\n             (tooManyDigits + (x.s * v));\r\n        }\r\n\r\n         // Overflow?\r\n        if ((e = e - i - 1) > MAX_EXP) {\r\n\r\n          // Infinity.\r\n          x.c = x.e = null;\r\n\r\n        // Underflow?\r\n        } else if (e < MIN_EXP) {\r\n\r\n          // Zero.\r\n          x.c = [x.e = 0];\r\n        } else {\r\n          x.e = e;\r\n          x.c = [];\r\n\r\n          // Transform base\r\n\r\n          // e is the base 10 exponent.\r\n          // i is where to slice str to get the first element of the coefficient array.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (e < 0) i += LOG_BASE;  // i < 1\r\n\r\n          if (i < len) {\r\n            if (i) x.c.push(+str.slice(0, i));\r\n\r\n            for (len -= LOG_BASE; i < len;) {\r\n              x.c.push(+str.slice(i, i += LOG_BASE));\r\n            }\r\n\r\n            i = LOG_BASE - (str = str.slice(i)).length;\r\n          } else {\r\n            i -= len;\r\n          }\r\n\r\n          for (; i--; str += '0');\r\n          x.c.push(+str);\r\n        }\r\n      } else {\r\n\r\n        // Zero.\r\n        x.c = [x.e = 0];\r\n      }\r\n    }\r\n\r\n\r\n    // CONSTRUCTOR PROPERTIES\r\n\r\n\r\n    BigNumber.clone = clone;\r\n\r\n    BigNumber.ROUND_UP = 0;\r\n    BigNumber.ROUND_DOWN = 1;\r\n    BigNumber.ROUND_CEIL = 2;\r\n    BigNumber.ROUND_FLOOR = 3;\r\n    BigNumber.ROUND_HALF_UP = 4;\r\n    BigNumber.ROUND_HALF_DOWN = 5;\r\n    BigNumber.ROUND_HALF_EVEN = 6;\r\n    BigNumber.ROUND_HALF_CEIL = 7;\r\n    BigNumber.ROUND_HALF_FLOOR = 8;\r\n    BigNumber.EUCLID = 9;\r\n\r\n\r\n    /*\r\n     * Configure infrequently-changing library-wide settings.\r\n     *\r\n     * Accept an object with the following optional properties (if the value of a property is\r\n     * a number, it must be an integer within the inclusive range stated):\r\n     *\r\n     *   DECIMAL_PLACES   {number}           0 to MAX\r\n     *   ROUNDING_MODE    {number}           0 to 8\r\n     *   EXPONENTIAL_AT   {number|number[]}  -MAX to MAX  or  [-MAX to 0, 0 to MAX]\r\n     *   RANGE            {number|number[]}  -MAX to MAX (not zero)  or  [-MAX to -1, 1 to MAX]\r\n     *   CRYPTO           {boolean}          true or false\r\n     *   MODULO_MODE      {number}           0 to 9\r\n     *   POW_PRECISION       {number}           0 to MAX\r\n     *   ALPHABET         {string}           A string of two or more unique characters which does\r\n     *                                       not contain '.'.\r\n     *   FORMAT           {object}           An object with some of the following properties:\r\n     *     prefix                 {string}\r\n     *     groupSize              {number}\r\n     *     secondaryGroupSize     {number}\r\n     *     groupSeparator         {string}\r\n     *     decimalSeparator       {string}\r\n     *     fractionGroupSize      {number}\r\n     *     fractionGroupSeparator {string}\r\n     *     suffix                 {string}\r\n     *\r\n     * (The values assigned to the above FORMAT object properties are not checked for validity.)\r\n     *\r\n     * E.g.\r\n     * BigNumber.config({ DECIMAL_PLACES : 20, ROUNDING_MODE : 4 })\r\n     *\r\n     * Ignore properties/parameters set to null or undefined, except for ALPHABET.\r\n     *\r\n     * Return an object with the properties current values.\r\n     */\r\n    BigNumber.config = BigNumber.set = function (obj) {\r\n      var p, v;\r\n\r\n      if (obj != null) {\r\n\r\n        if (typeof obj == 'object') {\r\n\r\n          // DECIMAL_PLACES {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] DECIMAL_PLACES {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'DECIMAL_PLACES')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            DECIMAL_PLACES = v;\r\n          }\r\n\r\n          // ROUNDING_MODE {number} Integer, 0 to 8 inclusive.\r\n          // '[BigNumber Error] ROUNDING_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'ROUNDING_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 8, p);\r\n            ROUNDING_MODE = v;\r\n          }\r\n\r\n          // EXPONENTIAL_AT {number|number[]}\r\n          // Integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to 0 inclusive, 0 to MAX inclusive].\r\n          // '[BigNumber Error] EXPONENTIAL_AT {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'EXPONENTIAL_AT')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, 0, p);\r\n              intCheck(v[1], 0, MAX, p);\r\n              TO_EXP_NEG = v[0];\r\n              TO_EXP_POS = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);\r\n            }\r\n          }\r\n\r\n          // RANGE {number|number[]} Non-zero integer, -MAX to MAX inclusive or\r\n          // [integer -MAX to -1 inclusive, integer 1 to MAX inclusive].\r\n          // '[BigNumber Error] RANGE {not a primitive number|not an integer|out of range|cannot be zero}: {v}'\r\n          if (obj.hasOwnProperty(p = 'RANGE')) {\r\n            v = obj[p];\r\n            if (v && v.pop) {\r\n              intCheck(v[0], -MAX, -1, p);\r\n              intCheck(v[1], 1, MAX, p);\r\n              MIN_EXP = v[0];\r\n              MAX_EXP = v[1];\r\n            } else {\r\n              intCheck(v, -MAX, MAX, p);\r\n              if (v) {\r\n                MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);\r\n              } else {\r\n                throw Error\r\n                 (bignumberError + p + ' cannot be zero: ' + v);\r\n              }\r\n            }\r\n          }\r\n\r\n          // CRYPTO {boolean} true or false.\r\n          // '[BigNumber Error] CRYPTO not true or false: {v}'\r\n          // '[BigNumber Error] crypto unavailable'\r\n          if (obj.hasOwnProperty(p = 'CRYPTO')) {\r\n            v = obj[p];\r\n            if (v === !!v) {\r\n              if (v) {\r\n                if (typeof crypto != 'undefined' && crypto &&\r\n                 (crypto.getRandomValues || crypto.randomBytes)) {\r\n                  CRYPTO = v;\r\n                } else {\r\n                  CRYPTO = !v;\r\n                  throw Error\r\n                   (bignumberError + 'crypto unavailable');\r\n                }\r\n              } else {\r\n                CRYPTO = v;\r\n              }\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' not true or false: ' + v);\r\n            }\r\n          }\r\n\r\n          // MODULO_MODE {number} Integer, 0 to 9 inclusive.\r\n          // '[BigNumber Error] MODULO_MODE {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'MODULO_MODE')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, 9, p);\r\n            MODULO_MODE = v;\r\n          }\r\n\r\n          // POW_PRECISION {number} Integer, 0 to MAX inclusive.\r\n          // '[BigNumber Error] POW_PRECISION {not a primitive number|not an integer|out of range}: {v}'\r\n          if (obj.hasOwnProperty(p = 'POW_PRECISION')) {\r\n            v = obj[p];\r\n            intCheck(v, 0, MAX, p);\r\n            POW_PRECISION = v;\r\n          }\r\n\r\n          // FORMAT {object}\r\n          // '[BigNumber Error] FORMAT not an object: {v}'\r\n          if (obj.hasOwnProperty(p = 'FORMAT')) {\r\n            v = obj[p];\r\n            if (typeof v == 'object') FORMAT = v;\r\n            else throw Error\r\n             (bignumberError + p + ' not an object: ' + v);\r\n          }\r\n\r\n          // ALPHABET {string}\r\n          // '[BigNumber Error] ALPHABET invalid: {v}'\r\n          if (obj.hasOwnProperty(p = 'ALPHABET')) {\r\n            v = obj[p];\r\n\r\n            // Disallow if less than two characters,\r\n            // or if it contains '+', '-', '.', whitespace, or a repeated character.\r\n            if (typeof v == 'string' && !/^.?$|[+\\-.\\s]|(.).*\\1/.test(v)) {\r\n              ALPHABET = v;\r\n            } else {\r\n              throw Error\r\n               (bignumberError + p + ' invalid: ' + v);\r\n            }\r\n          }\r\n\r\n        } else {\r\n\r\n          // '[BigNumber Error] Object expected: {v}'\r\n          throw Error\r\n           (bignumberError + 'Object expected: ' + obj);\r\n        }\r\n      }\r\n\r\n      return {\r\n        DECIMAL_PLACES: DECIMAL_PLACES,\r\n        ROUNDING_MODE: ROUNDING_MODE,\r\n        EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],\r\n        RANGE: [MIN_EXP, MAX_EXP],\r\n        CRYPTO: CRYPTO,\r\n        MODULO_MODE: MODULO_MODE,\r\n        POW_PRECISION: POW_PRECISION,\r\n        FORMAT: FORMAT,\r\n        ALPHABET: ALPHABET\r\n      };\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if v is a BigNumber instance, otherwise return false.\r\n     *\r\n     * If BigNumber.DEBUG is true, throw if a BigNumber instance is not well-formed.\r\n     *\r\n     * v {any}\r\n     *\r\n     * '[BigNumber Error] Invalid BigNumber: {v}'\r\n     */\r\n    BigNumber.isBigNumber = function (v) {\r\n      if (!v || v._isBigNumber !== true) return false;\r\n      if (!BigNumber.DEBUG) return true;\r\n\r\n      var i, n,\r\n        c = v.c,\r\n        e = v.e,\r\n        s = v.s;\r\n\r\n      out: if ({}.toString.call(c) == '[object Array]') {\r\n\r\n        if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {\r\n\r\n          // If the first element is zero, the BigNumber value must be zero.\r\n          if (c[0] === 0) {\r\n            if (e === 0 && c.length === 1) return true;\r\n            break out;\r\n          }\r\n\r\n          // Calculate number of digits that c[0] should have, based on the exponent.\r\n          i = (e + 1) % LOG_BASE;\r\n          if (i < 1) i += LOG_BASE;\r\n\r\n          // Calculate number of digits of c[0].\r\n          //if (Math.ceil(Math.log(c[0] + 1) / Math.LN10) == i) {\r\n          if (String(c[0]).length == i) {\r\n\r\n            for (i = 0; i < c.length; i++) {\r\n              n = c[i];\r\n              if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;\r\n            }\r\n\r\n            // Last element cannot be zero, unless it is the only element.\r\n            if (n !== 0) return true;\r\n          }\r\n        }\r\n\r\n      // Infinity/NaN\r\n      } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {\r\n        return true;\r\n      }\r\n\r\n      throw Error\r\n        (bignumberError + 'Invalid BigNumber: ' + v);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the maximum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.maximum = BigNumber.max = function () {\r\n      return maxOrMin(arguments, P.lt);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the minimum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.minimum = BigNumber.min = function () {\r\n      return maxOrMin(arguments, P.gt);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber with a random value equal to or greater than 0 and less than 1,\r\n     * and with dp, or DECIMAL_PLACES if dp is omitted, decimal places (or less if trailing\r\n     * zeros are produced).\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp}'\r\n     * '[BigNumber Error] crypto unavailable'\r\n     */\r\n    BigNumber.random = (function () {\r\n      var pow2_53 = 0x20000000000000;\r\n\r\n      // Return a 53 bit integer n, where 0 <= n < 9007199254740992.\r\n      // Check if Math.random() produces more than 32 bits of randomness.\r\n      // If it does, assume at least 53 bits are produced, otherwise assume at least 30 bits.\r\n      // 0x40000000 is 2^30, 0x800000 is 2^23, 0x1fffff is 2^21 - 1.\r\n      var random53bitInt = (Math.random() * pow2_53) & 0x1fffff\r\n       ? function () { return mathfloor(Math.random() * pow2_53); }\r\n       : function () { return ((Math.random() * 0x40000000 | 0) * 0x800000) +\r\n         (Math.random() * 0x800000 | 0); };\r\n\r\n      return function (dp) {\r\n        var a, b, e, k, v,\r\n          i = 0,\r\n          c = [],\r\n          rand = new BigNumber(ONE);\r\n\r\n        if (dp == null) dp = DECIMAL_PLACES;\r\n        else intCheck(dp, 0, MAX);\r\n\r\n        k = mathceil(dp / LOG_BASE);\r\n\r\n        if (CRYPTO) {\r\n\r\n          // Browsers supporting crypto.getRandomValues.\r\n          if (crypto.getRandomValues) {\r\n\r\n            a = crypto.getRandomValues(new Uint32Array(k *= 2));\r\n\r\n            for (; i < k;) {\r\n\r\n              // 53 bits:\r\n              // ((Math.pow(2, 32) - 1) * Math.pow(2, 21)).toString(2)\r\n              // 11111 11111111 11111111 11111111 11100000 00000000 00000000\r\n              // ((Math.pow(2, 32) - 1) >>> 11).toString(2)\r\n              //                                     11111 11111111 11111111\r\n              // 0x20000 is 2^21.\r\n              v = a[i] * 0x20000 + (a[i + 1] >>> 11);\r\n\r\n              // Rejection sampling:\r\n              // 0 <= v < 9007199254740992\r\n              // Probability that v >= 9e15, is\r\n              // 7199254740992 / 9007199254740992 ~= 0.0008, i.e. 1 in 1251\r\n              if (v >= 9e15) {\r\n                b = crypto.getRandomValues(new Uint32Array(2));\r\n                a[i] = b[0];\r\n                a[i + 1] = b[1];\r\n              } else {\r\n\r\n                // 0 <= v <= 8999999999999999\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 2;\r\n              }\r\n            }\r\n            i = k / 2;\r\n\r\n          // Node.js supporting crypto.randomBytes.\r\n          } else if (crypto.randomBytes) {\r\n\r\n            // buffer\r\n            a = crypto.randomBytes(k *= 7);\r\n\r\n            for (; i < k;) {\r\n\r\n              // 0x1000000000000 is 2^48, 0x10000000000 is 2^40\r\n              // 0x100000000 is 2^32, 0x1000000 is 2^24\r\n              // 11111 11111111 11111111 11111111 11111111 11111111 11111111\r\n              // 0 <= v < 9007199254740992\r\n              v = ((a[i] & 31) * 0x1000000000000) + (a[i + 1] * 0x10000000000) +\r\n                 (a[i + 2] * 0x100000000) + (a[i + 3] * 0x1000000) +\r\n                 (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];\r\n\r\n              if (v >= 9e15) {\r\n                crypto.randomBytes(7).copy(a, i);\r\n              } else {\r\n\r\n                // 0 <= (v % 1e14) <= 99999999999999\r\n                c.push(v % 1e14);\r\n                i += 7;\r\n              }\r\n            }\r\n            i = k / 7;\r\n          } else {\r\n            CRYPTO = false;\r\n            throw Error\r\n             (bignumberError + 'crypto unavailable');\r\n          }\r\n        }\r\n\r\n        // Use Math.random.\r\n        if (!CRYPTO) {\r\n\r\n          for (; i < k;) {\r\n            v = random53bitInt();\r\n            if (v < 9e15) c[i++] = v % 1e14;\r\n          }\r\n        }\r\n\r\n        k = c[--i];\r\n        dp %= LOG_BASE;\r\n\r\n        // Convert trailing digits to zeros according to dp.\r\n        if (k && dp) {\r\n          v = POWS_TEN[LOG_BASE - dp];\r\n          c[i] = mathfloor(k / v) * v;\r\n        }\r\n\r\n        // Remove trailing elements which are zero.\r\n        for (; c[i] === 0; c.pop(), i--);\r\n\r\n        // Zero?\r\n        if (i < 0) {\r\n          c = [e = 0];\r\n        } else {\r\n\r\n          // Remove leading elements which are zero and adjust exponent accordingly.\r\n          for (e = -1 ; c[0] === 0; c.splice(0, 1), e -= LOG_BASE);\r\n\r\n          // Count the digits of the first element of c to determine leading zeros, and...\r\n          for (i = 1, v = c[0]; v >= 10; v /= 10, i++);\r\n\r\n          // adjust the exponent accordingly.\r\n          if (i < LOG_BASE) e -= LOG_BASE - i;\r\n        }\r\n\r\n        rand.e = e;\r\n        rand.c = c;\r\n        return rand;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the sum of the arguments.\r\n     *\r\n     * arguments {number|string|BigNumber}\r\n     */\r\n    BigNumber.sum = function () {\r\n      var i = 1,\r\n        args = arguments,\r\n        sum = new BigNumber(args[0]);\r\n      for (; i < args.length;) sum = sum.plus(args[i++]);\r\n      return sum;\r\n    };\r\n\r\n\r\n    // PRIVATE FUNCTIONS\r\n\r\n\r\n    // Called by BigNumber and BigNumber.prototype.toString.\r\n    convertBase = (function () {\r\n      var decimal = '0123456789';\r\n\r\n      /*\r\n       * Convert string of baseIn to an array of numbers of baseOut.\r\n       * Eg. toBaseOut('255', 10, 16) returns [15, 15].\r\n       * Eg. toBaseOut('ff', 16, 10) returns [2, 5, 5].\r\n       */\r\n      function toBaseOut(str, baseIn, baseOut, alphabet) {\r\n        var j,\r\n          arr = [0],\r\n          arrL,\r\n          i = 0,\r\n          len = str.length;\r\n\r\n        for (; i < len;) {\r\n          for (arrL = arr.length; arrL--; arr[arrL] *= baseIn);\r\n\r\n          arr[0] += alphabet.indexOf(str.charAt(i++));\r\n\r\n          for (j = 0; j < arr.length; j++) {\r\n\r\n            if (arr[j] > baseOut - 1) {\r\n              if (arr[j + 1] == null) arr[j + 1] = 0;\r\n              arr[j + 1] += arr[j] / baseOut | 0;\r\n              arr[j] %= baseOut;\r\n            }\r\n          }\r\n        }\r\n\r\n        return arr.reverse();\r\n      }\r\n\r\n      // Convert a numeric string of baseIn to a numeric string of baseOut.\r\n      // If the caller is toString, we are converting from base 10 to baseOut.\r\n      // If the caller is BigNumber, we are converting from baseIn to base 10.\r\n      return function (str, baseIn, baseOut, sign, callerIsToString) {\r\n        var alphabet, d, e, k, r, x, xc, y,\r\n          i = str.indexOf('.'),\r\n          dp = DECIMAL_PLACES,\r\n          rm = ROUNDING_MODE;\r\n\r\n        // Non-integer.\r\n        if (i >= 0) {\r\n          k = POW_PRECISION;\r\n\r\n          // Unlimited precision.\r\n          POW_PRECISION = 0;\r\n          str = str.replace('.', '');\r\n          y = new BigNumber(baseIn);\r\n          x = y.pow(str.length - i);\r\n          POW_PRECISION = k;\r\n\r\n          // Convert str as if an integer, then restore the fraction part by dividing the\r\n          // result by its base raised to a power.\r\n\r\n          y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, '0'),\r\n           10, baseOut, decimal);\r\n          y.e = y.c.length;\r\n        }\r\n\r\n        // Convert the number as integer.\r\n\r\n        xc = toBaseOut(str, baseIn, baseOut, callerIsToString\r\n         ? (alphabet = ALPHABET, decimal)\r\n         : (alphabet = decimal, ALPHABET));\r\n\r\n        // xc now represents str as an integer and converted to baseOut. e is the exponent.\r\n        e = k = xc.length;\r\n\r\n        // Remove trailing zeros.\r\n        for (; xc[--k] == 0; xc.pop());\r\n\r\n        // Zero?\r\n        if (!xc[0]) return alphabet.charAt(0);\r\n\r\n        // Does str represent an integer? If so, no need for the division.\r\n        if (i < 0) {\r\n          --e;\r\n        } else {\r\n          x.c = xc;\r\n          x.e = e;\r\n\r\n          // The sign is needed for correct rounding.\r\n          x.s = sign;\r\n          x = div(x, y, dp, rm, baseOut);\r\n          xc = x.c;\r\n          r = x.r;\r\n          e = x.e;\r\n        }\r\n\r\n        // xc now represents str converted to baseOut.\r\n\r\n        // THe index of the rounding digit.\r\n        d = e + dp + 1;\r\n\r\n        // The rounding digit: the digit to the right of the digit that may be rounded up.\r\n        i = xc[d];\r\n\r\n        // Look at the rounding digits and mode to determine whether to round up.\r\n\r\n        k = baseOut / 2;\r\n        r = r || d < 0 || xc[d + 1] != null;\r\n\r\n        r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n              : i > k || i == k &&(rm == 4 || r || rm == 6 && xc[d - 1] & 1 ||\r\n               rm == (x.s < 0 ? 8 : 7));\r\n\r\n        // If the index of the rounding digit is not greater than zero, or xc represents\r\n        // zero, then the result of the base conversion is zero or, if rounding up, a value\r\n        // such as 0.00001.\r\n        if (d < 1 || !xc[0]) {\r\n\r\n          // 1^-dp or 0\r\n          str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);\r\n        } else {\r\n\r\n          // Truncate xc to the required number of decimal places.\r\n          xc.length = d;\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            // Rounding up may mean the previous digit has to be rounded up and so on.\r\n            for (--baseOut; ++xc[--d] > baseOut;) {\r\n              xc[d] = 0;\r\n\r\n              if (!d) {\r\n                ++e;\r\n                xc = [1].concat(xc);\r\n              }\r\n            }\r\n          }\r\n\r\n          // Determine trailing zeros.\r\n          for (k = xc.length; !xc[--k];);\r\n\r\n          // E.g. [4, 11, 15] becomes 4bf.\r\n          for (i = 0, str = ''; i <= k; str += alphabet.charAt(xc[i++]));\r\n\r\n          // Add leading zeros, decimal point and trailing zeros as required.\r\n          str = toFixedPoint(str, e, alphabet.charAt(0));\r\n        }\r\n\r\n        // The caller will add the sign.\r\n        return str;\r\n      };\r\n    })();\r\n\r\n\r\n    // Perform division in the specified base. Called by div and convertBase.\r\n    div = (function () {\r\n\r\n      // Assume non-zero x and k.\r\n      function multiply(x, k, base) {\r\n        var m, temp, xlo, xhi,\r\n          carry = 0,\r\n          i = x.length,\r\n          klo = k % SQRT_BASE,\r\n          khi = k / SQRT_BASE | 0;\r\n\r\n        for (x = x.slice(); i--;) {\r\n          xlo = x[i] % SQRT_BASE;\r\n          xhi = x[i] / SQRT_BASE | 0;\r\n          m = khi * xlo + xhi * klo;\r\n          temp = klo * xlo + ((m % SQRT_BASE) * SQRT_BASE) + carry;\r\n          carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;\r\n          x[i] = temp % base;\r\n        }\r\n\r\n        if (carry) x = [carry].concat(x);\r\n\r\n        return x;\r\n      }\r\n\r\n      function compare(a, b, aL, bL) {\r\n        var i, cmp;\r\n\r\n        if (aL != bL) {\r\n          cmp = aL > bL ? 1 : -1;\r\n        } else {\r\n\r\n          for (i = cmp = 0; i < aL; i++) {\r\n\r\n            if (a[i] != b[i]) {\r\n              cmp = a[i] > b[i] ? 1 : -1;\r\n              break;\r\n            }\r\n          }\r\n        }\r\n\r\n        return cmp;\r\n      }\r\n\r\n      function subtract(a, b, aL, base) {\r\n        var i = 0;\r\n\r\n        // Subtract b from a.\r\n        for (; aL--;) {\r\n          a[aL] -= i;\r\n          i = a[aL] < b[aL] ? 1 : 0;\r\n          a[aL] = i * base + a[aL] - b[aL];\r\n        }\r\n\r\n        // Remove leading zeros.\r\n        for (; !a[0] && a.length > 1; a.splice(0, 1));\r\n      }\r\n\r\n      // x: dividend, y: divisor.\r\n      return function (x, y, dp, rm, base) {\r\n        var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0,\r\n          yL, yz,\r\n          s = x.s == y.s ? 1 : -1,\r\n          xc = x.c,\r\n          yc = y.c;\r\n\r\n        // Either NaN, Infinity or 0?\r\n        if (!xc || !xc[0] || !yc || !yc[0]) {\r\n\r\n          return new BigNumber(\r\n\r\n           // Return NaN if either NaN, or both Infinity or 0.\r\n           !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN :\r\n\r\n            // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.\r\n            xc && xc[0] == 0 || !yc ? s * 0 : s / 0\r\n         );\r\n        }\r\n\r\n        q = new BigNumber(s);\r\n        qc = q.c = [];\r\n        e = x.e - y.e;\r\n        s = dp + e + 1;\r\n\r\n        if (!base) {\r\n          base = BASE;\r\n          e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);\r\n          s = s / LOG_BASE | 0;\r\n        }\r\n\r\n        // Result exponent may be one less then the current value of e.\r\n        // The coefficients of the BigNumbers from convertBase may have trailing zeros.\r\n        for (i = 0; yc[i] == (xc[i] || 0); i++);\r\n\r\n        if (yc[i] > (xc[i] || 0)) e--;\r\n\r\n        if (s < 0) {\r\n          qc.push(1);\r\n          more = true;\r\n        } else {\r\n          xL = xc.length;\r\n          yL = yc.length;\r\n          i = 0;\r\n          s += 2;\r\n\r\n          // Normalise xc and yc so highest order digit of yc is >= base / 2.\r\n\r\n          n = mathfloor(base / (yc[0] + 1));\r\n\r\n          // Not necessary, but to handle odd bases where yc[0] == (base / 2) - 1.\r\n          // if (n > 1 || n++ == 1 && yc[0] < base / 2) {\r\n          if (n > 1) {\r\n            yc = multiply(yc, n, base);\r\n            xc = multiply(xc, n, base);\r\n            yL = yc.length;\r\n            xL = xc.length;\r\n          }\r\n\r\n          xi = yL;\r\n          rem = xc.slice(0, yL);\r\n          remL = rem.length;\r\n\r\n          // Add zeros to make remainder as long as divisor.\r\n          for (; remL < yL; rem[remL++] = 0);\r\n          yz = yc.slice();\r\n          yz = [0].concat(yz);\r\n          yc0 = yc[0];\r\n          if (yc[1] >= base / 2) yc0++;\r\n          // Not necessary, but to prevent trial digit n > base, when using base 3.\r\n          // else if (base == 3 && yc0 == 1) yc0 = 1 + 1e-15;\r\n\r\n          do {\r\n            n = 0;\r\n\r\n            // Compare divisor and remainder.\r\n            cmp = compare(yc, rem, yL, remL);\r\n\r\n            // If divisor < remainder.\r\n            if (cmp < 0) {\r\n\r\n              // Calculate trial digit, n.\r\n\r\n              rem0 = rem[0];\r\n              if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\r\n\r\n              // n is how many times the divisor goes into the current remainder.\r\n              n = mathfloor(rem0 / yc0);\r\n\r\n              //  Algorithm:\r\n              //  product = divisor multiplied by trial digit (n).\r\n              //  Compare product and remainder.\r\n              //  If product is greater than remainder:\r\n              //    Subtract divisor from product, decrement trial digit.\r\n              //  Subtract product from remainder.\r\n              //  If product was less than remainder at the last compare:\r\n              //    Compare new remainder and divisor.\r\n              //    If remainder is greater than divisor:\r\n              //      Subtract divisor from remainder, increment trial digit.\r\n\r\n              if (n > 1) {\r\n\r\n                // n may be > base only when base is 3.\r\n                if (n >= base) n = base - 1;\r\n\r\n                // product = divisor * trial digit.\r\n                prod = multiply(yc, n, base);\r\n                prodL = prod.length;\r\n                remL = rem.length;\r\n\r\n                // Compare product and remainder.\r\n                // If product > remainder then trial digit n too high.\r\n                // n is 1 too high about 5% of the time, and is not known to have\r\n                // ever been more than 1 too high.\r\n                while (compare(prod, rem, prodL, remL) == 1) {\r\n                  n--;\r\n\r\n                  // Subtract divisor from product.\r\n                  subtract(prod, yL < prodL ? yz : yc, prodL, base);\r\n                  prodL = prod.length;\r\n                  cmp = 1;\r\n                }\r\n              } else {\r\n\r\n                // n is 0 or 1, cmp is -1.\r\n                // If n is 0, there is no need to compare yc and rem again below,\r\n                // so change cmp to 1 to avoid it.\r\n                // If n is 1, leave cmp as -1, so yc and rem are compared again.\r\n                if (n == 0) {\r\n\r\n                  // divisor < remainder, so n must be at least 1.\r\n                  cmp = n = 1;\r\n                }\r\n\r\n                // product = divisor\r\n                prod = yc.slice();\r\n                prodL = prod.length;\r\n              }\r\n\r\n              if (prodL < remL) prod = [0].concat(prod);\r\n\r\n              // Subtract product from remainder.\r\n              subtract(rem, prod, remL, base);\r\n              remL = rem.length;\r\n\r\n               // If product was < remainder.\r\n              if (cmp == -1) {\r\n\r\n                // Compare divisor and new remainder.\r\n                // If divisor < new remainder, subtract divisor from remainder.\r\n                // Trial digit n too low.\r\n                // n is 1 too low about 5% of the time, and very rarely 2 too low.\r\n                while (compare(yc, rem, yL, remL) < 1) {\r\n                  n++;\r\n\r\n                  // Subtract divisor from remainder.\r\n                  subtract(rem, yL < remL ? yz : yc, remL, base);\r\n                  remL = rem.length;\r\n                }\r\n              }\r\n            } else if (cmp === 0) {\r\n              n++;\r\n              rem = [0];\r\n            } // else cmp === 1 and n will be 0\r\n\r\n            // Add the next digit, n, to the result array.\r\n            qc[i++] = n;\r\n\r\n            // Update the remainder.\r\n            if (rem[0]) {\r\n              rem[remL++] = xc[xi] || 0;\r\n            } else {\r\n              rem = [xc[xi]];\r\n              remL = 1;\r\n            }\r\n          } while ((xi++ < xL || rem[0] != null) && s--);\r\n\r\n          more = rem[0] != null;\r\n\r\n          // Leading zero?\r\n          if (!qc[0]) qc.splice(0, 1);\r\n        }\r\n\r\n        if (base == BASE) {\r\n\r\n          // To calculate q.e, first get the number of digits of qc[0].\r\n          for (i = 1, s = qc[0]; s >= 10; s /= 10, i++);\r\n\r\n          round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);\r\n\r\n        // Caller is convertBase.\r\n        } else {\r\n          q.e = e;\r\n          q.r = +more;\r\n        }\r\n\r\n        return q;\r\n      };\r\n    })();\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of BigNumber n in fixed-point or exponential\r\n     * notation rounded to the specified decimal places or significant digits.\r\n     *\r\n     * n: a BigNumber.\r\n     * i: the index of the last digit required (i.e. the digit that may be rounded up).\r\n     * rm: the rounding mode.\r\n     * id: 1 (toExponential) or 2 (toPrecision).\r\n     */\r\n    function format(n, i, rm, id) {\r\n      var c0, e, ne, len, str;\r\n\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n\r\n      if (!n.c) return n.toString();\r\n\r\n      c0 = n.c[0];\r\n      ne = n.e;\r\n\r\n      if (i == null) {\r\n        str = coeffToString(n.c);\r\n        str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS)\r\n         ? toExponential(str, ne)\r\n         : toFixedPoint(str, ne, '0');\r\n      } else {\r\n        n = round(new BigNumber(n), i, rm);\r\n\r\n        // n.e may have changed if the value was rounded up.\r\n        e = n.e;\r\n\r\n        str = coeffToString(n.c);\r\n        len = str.length;\r\n\r\n        // toPrecision returns exponential notation if the number of significant digits\r\n        // specified is less than the number of digits necessary to represent the integer\r\n        // part of the value in fixed-point notation.\r\n\r\n        // Exponential notation.\r\n        if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {\r\n\r\n          // Append zeros?\r\n          for (; len < i; str += '0', len++);\r\n          str = toExponential(str, e);\r\n\r\n        // Fixed-point notation.\r\n        } else {\r\n          i -= ne;\r\n          str = toFixedPoint(str, e, '0');\r\n\r\n          // Append zeros?\r\n          if (e + 1 > len) {\r\n            if (--i > 0) for (str += '.'; i--; str += '0');\r\n          } else {\r\n            i += e - len;\r\n            if (i > 0) {\r\n              if (e + 1 == len) str += '.';\r\n              for (; i--; str += '0');\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return n.s < 0 && c0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // Handle BigNumber.max and BigNumber.min.\r\n    function maxOrMin(args, method) {\r\n      var n,\r\n        i = 1,\r\n        m = new BigNumber(args[0]);\r\n\r\n      for (; i < args.length; i++) {\r\n        n = new BigNumber(args[i]);\r\n\r\n        // If any number is NaN, return NaN.\r\n        if (!n.s) {\r\n          m = n;\r\n          break;\r\n        } else if (method.call(m, n)) {\r\n          m = n;\r\n        }\r\n      }\r\n\r\n      return m;\r\n    }\r\n\r\n\r\n    /*\r\n     * Strip trailing zeros, calculate base 10 exponent and check against MIN_EXP and MAX_EXP.\r\n     * Called by minus, plus and times.\r\n     */\r\n    function normalise(n, c, e) {\r\n      var i = 1,\r\n        j = c.length;\r\n\r\n       // Remove trailing zeros.\r\n      for (; !c[--j]; c.pop());\r\n\r\n      // Calculate the base 10 exponent. First get the number of digits of c[0].\r\n      for (j = c[0]; j >= 10; j /= 10, i++);\r\n\r\n      // Overflow?\r\n      if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {\r\n\r\n        // Infinity.\r\n        n.c = n.e = null;\r\n\r\n      // Underflow?\r\n      } else if (e < MIN_EXP) {\r\n\r\n        // Zero.\r\n        n.c = [n.e = 0];\r\n      } else {\r\n        n.e = e;\r\n        n.c = c;\r\n      }\r\n\r\n      return n;\r\n    }\r\n\r\n\r\n    // Handle values that fail the validity test in BigNumber.\r\n    parseNumeric = (function () {\r\n      var basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i,\r\n        dotAfter = /^([^.]+)\\.$/,\r\n        dotBefore = /^\\.([^.]+)$/,\r\n        isInfinityOrNaN = /^-?(Infinity|NaN)$/,\r\n        whitespaceOrPlus = /^\\s*\\+(?=[\\w.])|^\\s+|\\s+$/g;\r\n\r\n      return function (x, str, isNum, b) {\r\n        var base,\r\n          s = isNum ? str : str.replace(whitespaceOrPlus, '');\r\n\r\n        // No exception on Infinity or NaN.\r\n        if (isInfinityOrNaN.test(s)) {\r\n          x.s = isNaN(s) ? null : s < 0 ? -1 : 1;\r\n        } else {\r\n          if (!isNum) {\r\n\r\n            // basePrefix = /^(-?)0([xbo])(?=\\w[\\w.]*$)/i\r\n            s = s.replace(basePrefix, function (m, p1, p2) {\r\n              base = (p2 = p2.toLowerCase()) == 'x' ? 16 : p2 == 'b' ? 2 : 8;\r\n              return !b || b == base ? p1 : m;\r\n            });\r\n\r\n            if (b) {\r\n              base = b;\r\n\r\n              // E.g. '1.' to '1', '.1' to '0.1'\r\n              s = s.replace(dotAfter, '$1').replace(dotBefore, '0.$1');\r\n            }\r\n\r\n            if (str != s) return new BigNumber(s, base);\r\n          }\r\n\r\n          // '[BigNumber Error] Not a number: {n}'\r\n          // '[BigNumber Error] Not a base {b} number: {n}'\r\n          if (BigNumber.DEBUG) {\r\n            throw Error\r\n              (bignumberError + 'Not a' + (b ? ' base ' + b : '') + ' number: ' + str);\r\n          }\r\n\r\n          // NaN\r\n          x.s = null;\r\n        }\r\n\r\n        x.c = x.e = null;\r\n      }\r\n    })();\r\n\r\n\r\n    /*\r\n     * Round x to sd significant digits using rounding mode rm. Check for over/under-flow.\r\n     * If r is truthy, it is known that there are more digits after the rounding digit.\r\n     */\r\n    function round(x, sd, rm, r) {\r\n      var d, i, j, k, n, ni, rd,\r\n        xc = x.c,\r\n        pows10 = POWS_TEN;\r\n\r\n      // if x is not Infinity or NaN...\r\n      if (xc) {\r\n\r\n        // rd is the rounding digit, i.e. the digit after the digit that may be rounded up.\r\n        // n is a base 1e14 number, the value of the element of array x.c containing rd.\r\n        // ni is the index of n within x.c.\r\n        // d is the number of digits of n.\r\n        // i is the index of rd within n including leading zeros.\r\n        // j is the actual index of rd within n (if < 0, rd is a leading zero).\r\n        out: {\r\n\r\n          // Get the number of digits of the first element of xc.\r\n          for (d = 1, k = xc[0]; k >= 10; k /= 10, d++);\r\n          i = sd - d;\r\n\r\n          // If the rounding digit is in the first element of xc...\r\n          if (i < 0) {\r\n            i += LOG_BASE;\r\n            j = sd;\r\n            n = xc[ni = 0];\r\n\r\n            // Get the rounding digit at index j of n.\r\n            rd = n / pows10[d - j - 1] % 10 | 0;\r\n          } else {\r\n            ni = mathceil((i + 1) / LOG_BASE);\r\n\r\n            if (ni >= xc.length) {\r\n\r\n              if (r) {\r\n\r\n                // Needed by sqrt.\r\n                for (; xc.length <= ni; xc.push(0));\r\n                n = rd = 0;\r\n                d = 1;\r\n                i %= LOG_BASE;\r\n                j = i - LOG_BASE + 1;\r\n              } else {\r\n                break out;\r\n              }\r\n            } else {\r\n              n = k = xc[ni];\r\n\r\n              // Get the number of digits of n.\r\n              for (d = 1; k >= 10; k /= 10, d++);\r\n\r\n              // Get the index of rd within n.\r\n              i %= LOG_BASE;\r\n\r\n              // Get the index of rd within n, adjusted for leading zeros.\r\n              // The number of leading zeros of n is given by LOG_BASE - d.\r\n              j = i - LOG_BASE + d;\r\n\r\n              // Get the rounding digit at index j of n.\r\n              rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;\r\n            }\r\n          }\r\n\r\n          r = r || sd < 0 ||\r\n\r\n          // Are there any non-zero digits after the rounding digit?\r\n          // The expression  n % pows10[d - j - 1]  returns all digits of n to the right\r\n          // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.\r\n           xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);\r\n\r\n          r = rm < 4\r\n           ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2))\r\n           : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 &&\r\n\r\n            // Check whether the digit to the left of the rounding digit is odd.\r\n            ((i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10) & 1 ||\r\n             rm == (x.s < 0 ? 8 : 7));\r\n\r\n          if (sd < 1 || !xc[0]) {\r\n            xc.length = 0;\r\n\r\n            if (r) {\r\n\r\n              // Convert sd to decimal places.\r\n              sd -= x.e + 1;\r\n\r\n              // 1, 0.1, 0.01, 0.001, 0.0001 etc.\r\n              xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];\r\n              x.e = -sd || 0;\r\n            } else {\r\n\r\n              // Zero.\r\n              xc[0] = x.e = 0;\r\n            }\r\n\r\n            return x;\r\n          }\r\n\r\n          // Remove excess digits.\r\n          if (i == 0) {\r\n            xc.length = ni;\r\n            k = 1;\r\n            ni--;\r\n          } else {\r\n            xc.length = ni + 1;\r\n            k = pows10[LOG_BASE - i];\r\n\r\n            // E.g. 56700 becomes 56000 if 7 is the rounding digit.\r\n            // j > 0 means i > number of leading zeros of n.\r\n            xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;\r\n          }\r\n\r\n          // Round up?\r\n          if (r) {\r\n\r\n            for (; ;) {\r\n\r\n              // If the digit to be rounded up is in the first element of xc...\r\n              if (ni == 0) {\r\n\r\n                // i will be the length of xc[0] before k is added.\r\n                for (i = 1, j = xc[0]; j >= 10; j /= 10, i++);\r\n                j = xc[0] += k;\r\n                for (k = 1; j >= 10; j /= 10, k++);\r\n\r\n                // if i != k the length has increased.\r\n                if (i != k) {\r\n                  x.e++;\r\n                  if (xc[0] == BASE) xc[0] = 1;\r\n                }\r\n\r\n                break;\r\n              } else {\r\n                xc[ni] += k;\r\n                if (xc[ni] != BASE) break;\r\n                xc[ni--] = 0;\r\n                k = 1;\r\n              }\r\n            }\r\n          }\r\n\r\n          // Remove trailing zeros.\r\n          for (i = xc.length; xc[--i] === 0; xc.pop());\r\n        }\r\n\r\n        // Overflow? Infinity.\r\n        if (x.e > MAX_EXP) {\r\n          x.c = x.e = null;\r\n\r\n        // Underflow? Zero.\r\n        } else if (x.e < MIN_EXP) {\r\n          x.c = [x.e = 0];\r\n        }\r\n      }\r\n\r\n      return x;\r\n    }\r\n\r\n\r\n    function valueOf(n) {\r\n      var str,\r\n        e = n.e;\r\n\r\n      if (e === null) return n.toString();\r\n\r\n      str = coeffToString(n.c);\r\n\r\n      str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n        ? toExponential(str, e)\r\n        : toFixedPoint(str, e, '0');\r\n\r\n      return n.s < 0 ? '-' + str : str;\r\n    }\r\n\r\n\r\n    // PROTOTYPE/INSTANCE METHODS\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the absolute value of this BigNumber.\r\n     */\r\n    P.absoluteValue = P.abs = function () {\r\n      var x = new BigNumber(this);\r\n      if (x.s < 0) x.s = 1;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return\r\n     *   1 if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     *   -1 if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     *   0 if they have the same value,\r\n     *   or null if the value of either is NaN.\r\n     */\r\n    P.comparedTo = function (y, b) {\r\n      return compare(this, new BigNumber(y, b));\r\n    };\r\n\r\n\r\n    /*\r\n     * If dp is undefined or null or true or false, return the number of decimal places of the\r\n     * value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n     *\r\n     * Otherwise, if dp is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of dp decimal places using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [dp] {number} Decimal places: integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.decimalPlaces = P.dp = function (dp, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), dp + x.e + 1, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;\r\n\r\n      // Subtract the number of trailing zeros of the last number.\r\n      if (v = c[v]) for (; v % 10 == 0; v /= 10, n--);\r\n      if (n < 0) n = 0;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n / 0 = I\r\n     *  n / N = N\r\n     *  n / I = 0\r\n     *  0 / n = 0\r\n     *  0 / 0 = N\r\n     *  0 / N = N\r\n     *  0 / I = 0\r\n     *  N / n = N\r\n     *  N / 0 = N\r\n     *  N / N = N\r\n     *  N / I = N\r\n     *  I / n = I\r\n     *  I / 0 = I\r\n     *  I / N = N\r\n     *  I / I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber divided by the value of\r\n     * BigNumber(y, b), rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.dividedBy = P.div = function (y, b) {\r\n      return div(this, new BigNumber(y, b), DECIMAL_PLACES, ROUNDING_MODE);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the integer part of dividing the value of this\r\n     * BigNumber by the value of BigNumber(y, b).\r\n     */\r\n    P.dividedToIntegerBy = P.idiv = function (y, b) {\r\n      return div(this, new BigNumber(y, b), 0, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a BigNumber whose value is the value of this BigNumber exponentiated by n.\r\n     *\r\n     * If m is present, return the result modulo m.\r\n     * If n is negative round according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     * If POW_PRECISION is non-zero and m is not present, round to POW_PRECISION using ROUNDING_MODE.\r\n     *\r\n     * The modular power operation works efficiently when x, n, and m are integers, otherwise it\r\n     * is equivalent to calculating x.exponentiatedBy(n).modulo(m) with a POW_PRECISION of 0.\r\n     *\r\n     * n {number|string|BigNumber} The exponent. An integer.\r\n     * [m] {number|string|BigNumber} The modulus.\r\n     *\r\n     * '[BigNumber Error] Exponent not an integer: {n}'\r\n     */\r\n    P.exponentiatedBy = P.pow = function (n, m) {\r\n      var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y,\r\n        x = this;\r\n\r\n      n = new BigNumber(n);\r\n\r\n      // Allow NaN and Infinity, but not other non-integers.\r\n      if (n.c && !n.isInteger()) {\r\n        throw Error\r\n          (bignumberError + 'Exponent not an integer: ' + valueOf(n));\r\n      }\r\n\r\n      if (m != null) m = new BigNumber(m);\r\n\r\n      // Exponent of MAX_SAFE_INTEGER is 15.\r\n      nIsBig = n.e > 14;\r\n\r\n      // If x is NaN, Infinity, 0 or 1, or n is Infinity, NaN or 0.\r\n      if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {\r\n\r\n        // The sign of the result of pow when x is negative depends on the evenness of n.\r\n        // If +n overflows to Infinity, the evenness of n would be not be known.\r\n        y = new BigNumber(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));\r\n        return m ? y.mod(m) : y;\r\n      }\r\n\r\n      nIsNeg = n.s < 0;\r\n\r\n      if (m) {\r\n\r\n        // x % m returns NaN if abs(m) is zero, or m is NaN.\r\n        if (m.c ? !m.c[0] : !m.s) return new BigNumber(NaN);\r\n\r\n        isModExp = !nIsNeg && x.isInteger() && m.isInteger();\r\n\r\n        if (isModExp) x = x.mod(m);\r\n\r\n      // Overflow to Infinity: >=2**1e10 or >=1.0000024**1e15.\r\n      // Underflow to 0: <=0.79**1e10 or <=0.9999975**1e15.\r\n      } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0\r\n        // [1, 240000000]\r\n        ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7\r\n        // [80000000000000]  [99999750000000]\r\n        : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {\r\n\r\n        // If x is negative and n is odd, k = -0, else k = 0.\r\n        k = x.s < 0 && isOdd(n) ? -0 : 0;\r\n\r\n        // If x >= 1, k = Infinity.\r\n        if (x.e > -1) k = 1 / k;\r\n\r\n        // If n is negative return 0, else return Infinity.\r\n        return new BigNumber(nIsNeg ? 1 / k : k);\r\n\r\n      } else if (POW_PRECISION) {\r\n\r\n        // Truncating each coefficient array to a length of k after each multiplication\r\n        // equates to truncating significant digits to POW_PRECISION + [28, 41],\r\n        // i.e. there will be a minimum of 28 guard digits retained.\r\n        k = mathceil(POW_PRECISION / LOG_BASE + 2);\r\n      }\r\n\r\n      if (nIsBig) {\r\n        half = new BigNumber(0.5);\r\n        if (nIsNeg) n.s = 1;\r\n        nIsOdd = isOdd(n);\r\n      } else {\r\n        i = Math.abs(+valueOf(n));\r\n        nIsOdd = i % 2;\r\n      }\r\n\r\n      y = new BigNumber(ONE);\r\n\r\n      // Performs 54 loop iterations for n of 9007199254740991.\r\n      for (; ;) {\r\n\r\n        if (nIsOdd) {\r\n          y = y.times(x);\r\n          if (!y.c) break;\r\n\r\n          if (k) {\r\n            if (y.c.length > k) y.c.length = k;\r\n          } else if (isModExp) {\r\n            y = y.mod(m);    //y = y.minus(div(y, m, 0, MODULO_MODE).times(m));\r\n          }\r\n        }\r\n\r\n        if (i) {\r\n          i = mathfloor(i / 2);\r\n          if (i === 0) break;\r\n          nIsOdd = i % 2;\r\n        } else {\r\n          n = n.times(half);\r\n          round(n, n.e + 1, 1);\r\n\r\n          if (n.e > 14) {\r\n            nIsOdd = isOdd(n);\r\n          } else {\r\n            i = +valueOf(n);\r\n            if (i === 0) break;\r\n            nIsOdd = i % 2;\r\n          }\r\n        }\r\n\r\n        x = x.times(x);\r\n\r\n        if (k) {\r\n          if (x.c && x.c.length > k) x.c.length = k;\r\n        } else if (isModExp) {\r\n          x = x.mod(m);    //x = x.minus(div(x, m, 0, MODULO_MODE).times(m));\r\n        }\r\n      }\r\n\r\n      if (isModExp) return y;\r\n      if (nIsNeg) y = ONE.div(y);\r\n\r\n      return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber rounded to an integer\r\n     * using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {rm}'\r\n     */\r\n    P.integerValue = function (rm) {\r\n      var n = new BigNumber(this);\r\n      if (rm == null) rm = ROUNDING_MODE;\r\n      else intCheck(rm, 0, 8);\r\n      return round(n, n.e + 1, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is equal to the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isEqualTo = P.eq = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is a finite number, otherwise return false.\r\n     */\r\n    P.isFinite = function () {\r\n      return !!this.c;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isGreaterThan = P.gt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is greater than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isGreaterThanOrEqualTo = P.gte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === 1 || b === 0;\r\n\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is an integer, otherwise return false.\r\n     */\r\n    P.isInteger = function () {\r\n      return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than the value of BigNumber(y, b),\r\n     * otherwise return false.\r\n     */\r\n    P.isLessThan = P.lt = function (y, b) {\r\n      return compare(this, new BigNumber(y, b)) < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is less than or equal to the value of\r\n     * BigNumber(y, b), otherwise return false.\r\n     */\r\n    P.isLessThanOrEqualTo = P.lte = function (y, b) {\r\n      return (b = compare(this, new BigNumber(y, b))) === -1 || b === 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is NaN, otherwise return false.\r\n     */\r\n    P.isNaN = function () {\r\n      return !this.s;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is negative, otherwise return false.\r\n     */\r\n    P.isNegative = function () {\r\n      return this.s < 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is positive, otherwise return false.\r\n     */\r\n    P.isPositive = function () {\r\n      return this.s > 0;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return true if the value of this BigNumber is 0 or -0, otherwise return false.\r\n     */\r\n    P.isZero = function () {\r\n      return !!this.c && this.c[0] == 0;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n - 0 = n\r\n     *  n - N = N\r\n     *  n - I = -I\r\n     *  0 - n = -n\r\n     *  0 - 0 = 0\r\n     *  0 - N = N\r\n     *  0 - I = -I\r\n     *  N - n = N\r\n     *  N - 0 = N\r\n     *  N - N = N\r\n     *  N - I = N\r\n     *  I - n = I\r\n     *  I - 0 = I\r\n     *  I - N = N\r\n     *  I - I = N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber minus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.minus = function (y, b) {\r\n      var i, j, t, xLTy,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n      if (a != b) {\r\n        y.s = -b;\r\n        return x.plus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Either Infinity?\r\n        if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber(yc ? x : NaN);\r\n\r\n        // Either zero?\r\n        if (!xc[0] || !yc[0]) {\r\n\r\n          // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n          return yc[0] ? (y.s = -b, y) : new BigNumber(xc[0] ? x :\r\n\r\n           // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity\r\n           ROUNDING_MODE == 3 ? -0 : 0);\r\n        }\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Determine which is the bigger number.\r\n      if (a = xe - ye) {\r\n\r\n        if (xLTy = a < 0) {\r\n          a = -a;\r\n          t = xc;\r\n        } else {\r\n          ye = xe;\r\n          t = yc;\r\n        }\r\n\r\n        t.reverse();\r\n\r\n        // Prepend zeros to equalise exponents.\r\n        for (b = a; b--; t.push(0));\r\n        t.reverse();\r\n      } else {\r\n\r\n        // Exponents equal. Check digit by digit.\r\n        j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;\r\n\r\n        for (a = b = 0; b < j; b++) {\r\n\r\n          if (xc[b] != yc[b]) {\r\n            xLTy = xc[b] < yc[b];\r\n            break;\r\n          }\r\n        }\r\n      }\r\n\r\n      // x < y? Point xc to the array of the bigger number.\r\n      if (xLTy) t = xc, xc = yc, yc = t, y.s = -y.s;\r\n\r\n      b = (j = yc.length) - (i = xc.length);\r\n\r\n      // Append zeros to xc if shorter.\r\n      // No need to add zeros to yc if shorter as subtract only needs to start at yc.length.\r\n      if (b > 0) for (; b--; xc[i++] = 0);\r\n      b = BASE - 1;\r\n\r\n      // Subtract yc from xc.\r\n      for (; j > a;) {\r\n\r\n        if (xc[--j] < yc[j]) {\r\n          for (i = j; i && !xc[--i]; xc[i] = b);\r\n          --xc[i];\r\n          xc[j] += BASE;\r\n        }\r\n\r\n        xc[j] -= yc[j];\r\n      }\r\n\r\n      // Remove leading zeros and adjust exponent accordingly.\r\n      for (; xc[0] == 0; xc.splice(0, 1), --ye);\r\n\r\n      // Zero?\r\n      if (!xc[0]) {\r\n\r\n        // Following IEEE 754 (2008) 6.3,\r\n        // n - n = +0  but  n - n = -0  when rounding towards -Infinity.\r\n        y.s = ROUNDING_MODE == 3 ? -1 : 1;\r\n        y.c = [y.e = 0];\r\n        return y;\r\n      }\r\n\r\n      // No need to check for Infinity as +x - +y != Infinity && -x - -y != Infinity\r\n      // for finite x and y.\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     *   n % 0 =  N\r\n     *   n % N =  N\r\n     *   n % I =  n\r\n     *   0 % n =  0\r\n     *  -0 % n = -0\r\n     *   0 % 0 =  N\r\n     *   0 % N =  N\r\n     *   0 % I =  0\r\n     *   N % n =  N\r\n     *   N % 0 =  N\r\n     *   N % N =  N\r\n     *   N % I =  N\r\n     *   I % n =  N\r\n     *   I % 0 =  N\r\n     *   I % N =  N\r\n     *   I % I =  N\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber modulo the value of\r\n     * BigNumber(y, b). The result depends on the value of MODULO_MODE.\r\n     */\r\n    P.modulo = P.mod = function (y, b) {\r\n      var q, s,\r\n        x = this;\r\n\r\n      y = new BigNumber(y, b);\r\n\r\n      // Return NaN if x is Infinity or NaN, or y is NaN or zero.\r\n      if (!x.c || !y.s || y.c && !y.c[0]) {\r\n        return new BigNumber(NaN);\r\n\r\n      // Return x if y is Infinity or x is zero.\r\n      } else if (!y.c || x.c && !x.c[0]) {\r\n        return new BigNumber(x);\r\n      }\r\n\r\n      if (MODULO_MODE == 9) {\r\n\r\n        // Euclidian division: q = sign(y) * floor(x / abs(y))\r\n        // r = x - qy    where  0 <= r < abs(y)\r\n        s = y.s;\r\n        y.s = 1;\r\n        q = div(x, y, 0, 3);\r\n        y.s = s;\r\n        q.s *= s;\r\n      } else {\r\n        q = div(x, y, 0, MODULO_MODE);\r\n      }\r\n\r\n      y = x.minus(q.times(y));\r\n\r\n      // To match JavaScript %, ensure sign of zero is sign of dividend.\r\n      if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;\r\n\r\n      return y;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n * 0 = 0\r\n     *  n * N = N\r\n     *  n * I = I\r\n     *  0 * n = 0\r\n     *  0 * 0 = 0\r\n     *  0 * N = N\r\n     *  0 * I = N\r\n     *  N * n = N\r\n     *  N * 0 = N\r\n     *  N * N = N\r\n     *  N * I = N\r\n     *  I * n = I\r\n     *  I * 0 = N\r\n     *  I * N = N\r\n     *  I * I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber multiplied by the value\r\n     * of BigNumber(y, b).\r\n     */\r\n    P.multipliedBy = P.times = function (y, b) {\r\n      var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc,\r\n        base, sqrtBase,\r\n        x = this,\r\n        xc = x.c,\r\n        yc = (y = new BigNumber(y, b)).c;\r\n\r\n      // Either NaN, Infinity or 0?\r\n      if (!xc || !yc || !xc[0] || !yc[0]) {\r\n\r\n        // Return NaN if either is NaN, or one is 0 and the other is Infinity.\r\n        if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {\r\n          y.c = y.e = y.s = null;\r\n        } else {\r\n          y.s *= x.s;\r\n\r\n          // Return Infinity if either is Infinity.\r\n          if (!xc || !yc) {\r\n            y.c = y.e = null;\r\n\r\n          // Return 0 if either is 0.\r\n          } else {\r\n            y.c = [0];\r\n            y.e = 0;\r\n          }\r\n        }\r\n\r\n        return y;\r\n      }\r\n\r\n      e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);\r\n      y.s *= x.s;\r\n      xcL = xc.length;\r\n      ycL = yc.length;\r\n\r\n      // Ensure xc points to longer array and xcL to its length.\r\n      if (xcL < ycL) zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;\r\n\r\n      // Initialise the result array with zeros.\r\n      for (i = xcL + ycL, zc = []; i--; zc.push(0));\r\n\r\n      base = BASE;\r\n      sqrtBase = SQRT_BASE;\r\n\r\n      for (i = ycL; --i >= 0;) {\r\n        c = 0;\r\n        ylo = yc[i] % sqrtBase;\r\n        yhi = yc[i] / sqrtBase | 0;\r\n\r\n        for (k = xcL, j = i + k; j > i;) {\r\n          xlo = xc[--k] % sqrtBase;\r\n          xhi = xc[k] / sqrtBase | 0;\r\n          m = yhi * xlo + xhi * ylo;\r\n          xlo = ylo * xlo + ((m % sqrtBase) * sqrtBase) + zc[j] + c;\r\n          c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;\r\n          zc[j--] = xlo % base;\r\n        }\r\n\r\n        zc[j] = c;\r\n      }\r\n\r\n      if (c) {\r\n        ++e;\r\n      } else {\r\n        zc.splice(0, 1);\r\n      }\r\n\r\n      return normalise(y, zc, e);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber negated,\r\n     * i.e. multiplied by -1.\r\n     */\r\n    P.negated = function () {\r\n      var x = new BigNumber(this);\r\n      x.s = -x.s || null;\r\n      return x;\r\n    };\r\n\r\n\r\n    /*\r\n     *  n + 0 = n\r\n     *  n + N = N\r\n     *  n + I = I\r\n     *  0 + n = n\r\n     *  0 + 0 = 0\r\n     *  0 + N = N\r\n     *  0 + I = I\r\n     *  N + n = N\r\n     *  N + 0 = N\r\n     *  N + N = N\r\n     *  N + I = N\r\n     *  I + n = I\r\n     *  I + 0 = I\r\n     *  I + N = N\r\n     *  I + I = I\r\n     *\r\n     * Return a new BigNumber whose value is the value of this BigNumber plus the value of\r\n     * BigNumber(y, b).\r\n     */\r\n    P.plus = function (y, b) {\r\n      var t,\r\n        x = this,\r\n        a = x.s;\r\n\r\n      y = new BigNumber(y, b);\r\n      b = y.s;\r\n\r\n      // Either NaN?\r\n      if (!a || !b) return new BigNumber(NaN);\r\n\r\n      // Signs differ?\r\n       if (a != b) {\r\n        y.s = -b;\r\n        return x.minus(y);\r\n      }\r\n\r\n      var xe = x.e / LOG_BASE,\r\n        ye = y.e / LOG_BASE,\r\n        xc = x.c,\r\n        yc = y.c;\r\n\r\n      if (!xe || !ye) {\r\n\r\n        // Return Infinity if either Infinity.\r\n        if (!xc || !yc) return new BigNumber(a / 0);\r\n\r\n        // Either zero?\r\n        // Return y if y is non-zero, x if x is non-zero, or zero if both are zero.\r\n        if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber(xc[0] ? x : a * 0);\r\n      }\r\n\r\n      xe = bitFloor(xe);\r\n      ye = bitFloor(ye);\r\n      xc = xc.slice();\r\n\r\n      // Prepend zeros to equalise exponents. Faster to use reverse then do unshifts.\r\n      if (a = xe - ye) {\r\n        if (a > 0) {\r\n          ye = xe;\r\n          t = yc;\r\n        } else {\r\n          a = -a;\r\n          t = xc;\r\n        }\r\n\r\n        t.reverse();\r\n        for (; a--; t.push(0));\r\n        t.reverse();\r\n      }\r\n\r\n      a = xc.length;\r\n      b = yc.length;\r\n\r\n      // Point xc to the longer array, and b to the shorter length.\r\n      if (a - b < 0) t = yc, yc = xc, xc = t, b = a;\r\n\r\n      // Only start adding at yc.length - 1 as the further digits of xc can be ignored.\r\n      for (a = 0; b;) {\r\n        a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;\r\n        xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;\r\n      }\r\n\r\n      if (a) {\r\n        xc = [a].concat(xc);\r\n        ++ye;\r\n      }\r\n\r\n      // No need to check for zero, as +x + +y != 0 && -x + -y != 0\r\n      // ye = MAX_EXP + 1 possible\r\n      return normalise(y, xc, ye);\r\n    };\r\n\r\n\r\n    /*\r\n     * If sd is undefined or null or true or false, return the number of significant digits of\r\n     * the value of this BigNumber, or null if the value of this BigNumber is Infinity or NaN.\r\n     * If sd is true include integer-part trailing zeros in the count.\r\n     *\r\n     * Otherwise, if sd is a number, return a new BigNumber whose value is the value of this\r\n     * BigNumber rounded to a maximum of sd significant digits using rounding mode rm, or\r\n     * ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * sd {number|boolean} number: significant digits: integer, 1 to MAX inclusive.\r\n     *                     boolean: whether to count integer-part trailing zeros: true or false.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.precision = P.sd = function (sd, rm) {\r\n      var c, n, v,\r\n        x = this;\r\n\r\n      if (sd != null && sd !== !!sd) {\r\n        intCheck(sd, 1, MAX);\r\n        if (rm == null) rm = ROUNDING_MODE;\r\n        else intCheck(rm, 0, 8);\r\n\r\n        return round(new BigNumber(x), sd, rm);\r\n      }\r\n\r\n      if (!(c = x.c)) return null;\r\n      v = c.length - 1;\r\n      n = v * LOG_BASE + 1;\r\n\r\n      if (v = c[v]) {\r\n\r\n        // Subtract the number of trailing zeros of the last element.\r\n        for (; v % 10 == 0; v /= 10, n--);\r\n\r\n        // Add the number of digits of the first element.\r\n        for (v = c[0]; v >= 10; v /= 10, n++);\r\n      }\r\n\r\n      if (sd && x.e + 1 > n) n = x.e + 1;\r\n\r\n      return n;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a new BigNumber whose value is the value of this BigNumber shifted by k places\r\n     * (powers of 10). Shift to the right if n > 0, and to the left if n < 0.\r\n     *\r\n     * k {number} Integer, -MAX_SAFE_INTEGER to MAX_SAFE_INTEGER inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {k}'\r\n     */\r\n    P.shiftedBy = function (k) {\r\n      intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);\r\n      return this.times('1e' + k);\r\n    };\r\n\r\n\r\n    /*\r\n     *  sqrt(-n) =  N\r\n     *  sqrt(N) =  N\r\n     *  sqrt(-I) =  N\r\n     *  sqrt(I) =  I\r\n     *  sqrt(0) =  0\r\n     *  sqrt(-0) = -0\r\n     *\r\n     * Return a new BigNumber whose value is the square root of the value of this BigNumber,\r\n     * rounded according to DECIMAL_PLACES and ROUNDING_MODE.\r\n     */\r\n    P.squareRoot = P.sqrt = function () {\r\n      var m, n, r, rep, t,\r\n        x = this,\r\n        c = x.c,\r\n        s = x.s,\r\n        e = x.e,\r\n        dp = DECIMAL_PLACES + 4,\r\n        half = new BigNumber('0.5');\r\n\r\n      // Negative/NaN/Infinity/zero?\r\n      if (s !== 1 || !c || !c[0]) {\r\n        return new BigNumber(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);\r\n      }\r\n\r\n      // Initial estimate.\r\n      s = Math.sqrt(+valueOf(x));\r\n\r\n      // Math.sqrt underflow/overflow?\r\n      // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\r\n      if (s == 0 || s == 1 / 0) {\r\n        n = coeffToString(c);\r\n        if ((n.length + e) % 2 == 0) n += '0';\r\n        s = Math.sqrt(+n);\r\n        e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);\r\n\r\n        if (s == 1 / 0) {\r\n          n = '5e' + e;\r\n        } else {\r\n          n = s.toExponential();\r\n          n = n.slice(0, n.indexOf('e') + 1) + e;\r\n        }\r\n\r\n        r = new BigNumber(n);\r\n      } else {\r\n        r = new BigNumber(s + '');\r\n      }\r\n\r\n      // Check for zero.\r\n      // r could be zero if MIN_EXP is changed after the this value was created.\r\n      // This would cause a division by zero (x/t) and hence Infinity below, which would cause\r\n      // coeffToString to throw.\r\n      if (r.c[0]) {\r\n        e = r.e;\r\n        s = e + dp;\r\n        if (s < 3) s = 0;\r\n\r\n        // Newton-Raphson iteration.\r\n        for (; ;) {\r\n          t = r;\r\n          r = half.times(t.plus(div(x, t, dp, 1)));\r\n\r\n          if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {\r\n\r\n            // The exponent of r may here be one less than the final result exponent,\r\n            // e.g 0.0009999 (e-4) --> 0.001 (e-3), so adjust s so the rounding digits\r\n            // are indexed correctly.\r\n            if (r.e < e) --s;\r\n            n = n.slice(s - 3, s + 1);\r\n\r\n            // The 4th rounding digit may be in error by -1 so if the 4 rounding digits\r\n            // are 9999 or 4999 (i.e. approaching a rounding boundary) continue the\r\n            // iteration.\r\n            if (n == '9999' || !rep && n == '4999') {\r\n\r\n              // On the first iteration only, check to see if rounding up gives the\r\n              // exact result as the nines may infinitely repeat.\r\n              if (!rep) {\r\n                round(t, t.e + DECIMAL_PLACES + 2, 0);\r\n\r\n                if (t.times(t).eq(x)) {\r\n                  r = t;\r\n                  break;\r\n                }\r\n              }\r\n\r\n              dp += 4;\r\n              s += 4;\r\n              rep = 1;\r\n            } else {\r\n\r\n              // If rounding digits are null, 0{0,4} or 50{0,3}, check for exact\r\n              // result. If not, then there are further digits and m will be truthy.\r\n              if (!+n || !+n.slice(1) && n.charAt(0) == '5') {\r\n\r\n                // Truncate to the first rounding digit.\r\n                round(r, r.e + DECIMAL_PLACES + 2, 1);\r\n                m = !r.times(r).eq(x);\r\n              }\r\n\r\n              break;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n      return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in exponential notation and\r\n     * rounded using ROUNDING_MODE to dp fixed decimal places.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toExponential = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp++;\r\n      }\r\n      return format(this, dp, rm, 1);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounding\r\n     * to dp fixed decimal places using rounding mode rm, or ROUNDING_MODE if rm is omitted.\r\n     *\r\n     * Note: as with JavaScript's number type, (-0).toFixed(0) is '0',\r\n     * but e.g. (-0.00001).toFixed(0) is '-0'.\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     */\r\n    P.toFixed = function (dp, rm) {\r\n      if (dp != null) {\r\n        intCheck(dp, 0, MAX);\r\n        dp = dp + this.e + 1;\r\n      }\r\n      return format(this, dp, rm);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in fixed-point notation rounded\r\n     * using rm or ROUNDING_MODE to dp decimal places, and formatted according to the properties\r\n     * of the format or FORMAT object (see BigNumber.set).\r\n     *\r\n     * The formatting object may contain some or all of the properties shown below.\r\n     *\r\n     * FORMAT = {\r\n     *   prefix: '',\r\n     *   groupSize: 3,\r\n     *   secondaryGroupSize: 0,\r\n     *   groupSeparator: ',',\r\n     *   decimalSeparator: '.',\r\n     *   fractionGroupSize: 0,\r\n     *   fractionGroupSeparator: '\\xA0',      // non-breaking space\r\n     *   suffix: ''\r\n     * };\r\n     *\r\n     * [dp] {number} Decimal places. Integer, 0 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     * [format] {object} Formatting options. See FORMAT pbject above.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {dp|rm}'\r\n     * '[BigNumber Error] Argument not an object: {format}'\r\n     */\r\n    P.toFormat = function (dp, rm, format) {\r\n      var str,\r\n        x = this;\r\n\r\n      if (format == null) {\r\n        if (dp != null && rm && typeof rm == 'object') {\r\n          format = rm;\r\n          rm = null;\r\n        } else if (dp && typeof dp == 'object') {\r\n          format = dp;\r\n          dp = rm = null;\r\n        } else {\r\n          format = FORMAT;\r\n        }\r\n      } else if (typeof format != 'object') {\r\n        throw Error\r\n          (bignumberError + 'Argument not an object: ' + format);\r\n      }\r\n\r\n      str = x.toFixed(dp, rm);\r\n\r\n      if (x.c) {\r\n        var i,\r\n          arr = str.split('.'),\r\n          g1 = +format.groupSize,\r\n          g2 = +format.secondaryGroupSize,\r\n          groupSeparator = format.groupSeparator || '',\r\n          intPart = arr[0],\r\n          fractionPart = arr[1],\r\n          isNeg = x.s < 0,\r\n          intDigits = isNeg ? intPart.slice(1) : intPart,\r\n          len = intDigits.length;\r\n\r\n        if (g2) i = g1, g1 = g2, g2 = i, len -= i;\r\n\r\n        if (g1 > 0 && len > 0) {\r\n          i = len % g1 || g1;\r\n          intPart = intDigits.substr(0, i);\r\n          for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);\r\n          if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);\r\n          if (isNeg) intPart = '-' + intPart;\r\n        }\r\n\r\n        str = fractionPart\r\n         ? intPart + (format.decimalSeparator || '') + ((g2 = +format.fractionGroupSize)\r\n          ? fractionPart.replace(new RegExp('\\\\d{' + g2 + '}\\\\B', 'g'),\r\n           '$&' + (format.fractionGroupSeparator || ''))\r\n          : fractionPart)\r\n         : intPart;\r\n      }\r\n\r\n      return (format.prefix || '') + str + (format.suffix || '');\r\n    };\r\n\r\n\r\n    /*\r\n     * Return an array of two BigNumbers representing the value of this BigNumber as a simple\r\n     * fraction with an integer numerator and an integer denominator.\r\n     * The denominator will be a positive non-zero value less than or equal to the specified\r\n     * maximum denominator. If a maximum denominator is not specified, the denominator will be\r\n     * the lowest value necessary to represent the number exactly.\r\n     *\r\n     * [md] {number|string|BigNumber} Integer >= 1, or Infinity. The maximum denominator.\r\n     *\r\n     * '[BigNumber Error] Argument {not an integer|out of range} : {md}'\r\n     */\r\n    P.toFraction = function (md) {\r\n      var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s,\r\n        x = this,\r\n        xc = x.c;\r\n\r\n      if (md != null) {\r\n        n = new BigNumber(md);\r\n\r\n        // Throw if md is less than one or is not an integer, unless it is Infinity.\r\n        if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {\r\n          throw Error\r\n            (bignumberError + 'Argument ' +\r\n              (n.isInteger() ? 'out of range: ' : 'not an integer: ') + valueOf(n));\r\n        }\r\n      }\r\n\r\n      if (!xc) return new BigNumber(x);\r\n\r\n      d = new BigNumber(ONE);\r\n      n1 = d0 = new BigNumber(ONE);\r\n      d1 = n0 = new BigNumber(ONE);\r\n      s = coeffToString(xc);\r\n\r\n      // Determine initial denominator.\r\n      // d is a power of 10 and the minimum max denominator that specifies the value exactly.\r\n      e = d.e = s.length - x.e - 1;\r\n      d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];\r\n      md = !md || n.comparedTo(d) > 0 ? (e > 0 ? d : n1) : n;\r\n\r\n      exp = MAX_EXP;\r\n      MAX_EXP = 1 / 0;\r\n      n = new BigNumber(s);\r\n\r\n      // n0 = d1 = 0\r\n      n0.c[0] = 0;\r\n\r\n      for (; ;)  {\r\n        q = div(n, d, 0, 1);\r\n        d2 = d0.plus(q.times(d1));\r\n        if (d2.comparedTo(md) == 1) break;\r\n        d0 = d1;\r\n        d1 = d2;\r\n        n1 = n0.plus(q.times(d2 = n1));\r\n        n0 = d2;\r\n        d = n.minus(q.times(d2 = d));\r\n        n = d2;\r\n      }\r\n\r\n      d2 = div(md.minus(d0), d1, 0, 1);\r\n      n0 = n0.plus(d2.times(n1));\r\n      d0 = d0.plus(d2.times(d1));\r\n      n0.s = n1.s = x.s;\r\n      e = e * 2;\r\n\r\n      // Determine which fraction is closer to x, n0/d0 or n1/d1\r\n      r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(\r\n          div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];\r\n\r\n      MAX_EXP = exp;\r\n\r\n      return r;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return the value of this BigNumber converted to a number primitive.\r\n     */\r\n    P.toNumber = function () {\r\n      return +valueOf(this);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber rounded to sd significant digits\r\n     * using rounding mode rm or ROUNDING_MODE. If sd is less than the number of digits\r\n     * necessary to represent the integer part of the value in fixed-point notation, then use\r\n     * exponential notation.\r\n     *\r\n     * [sd] {number} Significant digits. Integer, 1 to MAX inclusive.\r\n     * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n     *\r\n     * '[BigNumber Error] Argument {not a primitive number|not an integer|out of range}: {sd|rm}'\r\n     */\r\n    P.toPrecision = function (sd, rm) {\r\n      if (sd != null) intCheck(sd, 1, MAX);\r\n      return format(this, sd, rm, 2);\r\n    };\r\n\r\n\r\n    /*\r\n     * Return a string representing the value of this BigNumber in base b, or base 10 if b is\r\n     * omitted. If a base is specified, including base 10, round according to DECIMAL_PLACES and\r\n     * ROUNDING_MODE. If a base is not specified, and this BigNumber has a positive exponent\r\n     * that is equal to or greater than TO_EXP_POS, or a negative exponent equal to or less than\r\n     * TO_EXP_NEG, return exponential notation.\r\n     *\r\n     * [b] {number} Integer, 2 to ALPHABET.length inclusive.\r\n     *\r\n     * '[BigNumber Error] Base {not a primitive number|not an integer|out of range}: {b}'\r\n     */\r\n    P.toString = function (b) {\r\n      var str,\r\n        n = this,\r\n        s = n.s,\r\n        e = n.e;\r\n\r\n      // Infinity or NaN?\r\n      if (e === null) {\r\n        if (s) {\r\n          str = 'Infinity';\r\n          if (s < 0) str = '-' + str;\r\n        } else {\r\n          str = 'NaN';\r\n        }\r\n      } else {\r\n        if (b == null) {\r\n          str = e <= TO_EXP_NEG || e >= TO_EXP_POS\r\n           ? toExponential(coeffToString(n.c), e)\r\n           : toFixedPoint(coeffToString(n.c), e, '0');\r\n        } else if (b === 10) {\r\n          n = round(new BigNumber(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);\r\n          str = toFixedPoint(coeffToString(n.c), n.e, '0');\r\n        } else {\r\n          intCheck(b, 2, ALPHABET.length, 'Base');\r\n          str = convertBase(toFixedPoint(coeffToString(n.c), e, '0'), 10, b, s, true);\r\n        }\r\n\r\n        if (s < 0 && n.c[0]) str = '-' + str;\r\n      }\r\n\r\n      return str;\r\n    };\r\n\r\n\r\n    /*\r\n     * Return as toString, but do not accept a base argument, and include the minus sign for\r\n     * negative zero.\r\n     */\r\n    P.valueOf = P.toJSON = function () {\r\n      return valueOf(this);\r\n    };\r\n\r\n\r\n    P._isBigNumber = true;\r\n\r\n    if (configObject != null) BigNumber.set(configObject);\r\n\r\n    return BigNumber;\r\n  }\r\n\r\n\r\n  // PRIVATE HELPER FUNCTIONS\r\n\r\n  // These functions don't need access to variables,\r\n  // e.g. DECIMAL_PLACES, in the scope of the `clone` function above.\r\n\r\n\r\n  function bitFloor(n) {\r\n    var i = n | 0;\r\n    return n > 0 || n === i ? i : i - 1;\r\n  }\r\n\r\n\r\n  // Return a coefficient array as a string of base 10 digits.\r\n  function coeffToString(a) {\r\n    var s, z,\r\n      i = 1,\r\n      j = a.length,\r\n      r = a[0] + '';\r\n\r\n    for (; i < j;) {\r\n      s = a[i++] + '';\r\n      z = LOG_BASE - s.length;\r\n      for (; z--; s = '0' + s);\r\n      r += s;\r\n    }\r\n\r\n    // Determine trailing zeros.\r\n    for (j = r.length; r.charCodeAt(--j) === 48;);\r\n\r\n    return r.slice(0, j + 1 || 1);\r\n  }\r\n\r\n\r\n  // Compare the value of BigNumbers x and y.\r\n  function compare(x, y) {\r\n    var a, b,\r\n      xc = x.c,\r\n      yc = y.c,\r\n      i = x.s,\r\n      j = y.s,\r\n      k = x.e,\r\n      l = y.e;\r\n\r\n    // Either NaN?\r\n    if (!i || !j) return null;\r\n\r\n    a = xc && !xc[0];\r\n    b = yc && !yc[0];\r\n\r\n    // Either zero?\r\n    if (a || b) return a ? b ? 0 : -j : i;\r\n\r\n    // Signs differ?\r\n    if (i != j) return i;\r\n\r\n    a = i < 0;\r\n    b = k == l;\r\n\r\n    // Either Infinity?\r\n    if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;\r\n\r\n    // Compare exponents.\r\n    if (!b) return k > l ^ a ? 1 : -1;\r\n\r\n    j = (k = xc.length) < (l = yc.length) ? k : l;\r\n\r\n    // Compare digit by digit.\r\n    for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;\r\n\r\n    // Compare lengths.\r\n    return k == l ? 0 : k > l ^ a ? 1 : -1;\r\n  }\r\n\r\n\r\n  /*\r\n   * Check that n is a primitive number, an integer, and in range, otherwise throw.\r\n   */\r\n  function intCheck(n, min, max, name) {\r\n    if (n < min || n > max || n !== mathfloor(n)) {\r\n      throw Error\r\n       (bignumberError + (name || 'Argument') + (typeof n == 'number'\r\n         ? n < min || n > max ? ' out of range: ' : ' not an integer: '\r\n         : ' not a primitive number: ') + String(n));\r\n    }\r\n  }\r\n\r\n\r\n  // Assumes finite n.\r\n  function isOdd(n) {\r\n    var k = n.c.length - 1;\r\n    return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;\r\n  }\r\n\r\n\r\n  function toExponential(str, e) {\r\n    return (str.length > 1 ? str.charAt(0) + '.' + str.slice(1) : str) +\r\n     (e < 0 ? 'e' : 'e+') + e;\r\n  }\r\n\r\n\r\n  function toFixedPoint(str, e, z) {\r\n    var len, zs;\r\n\r\n    // Negative exponent?\r\n    if (e < 0) {\r\n\r\n      // Prepend zeros.\r\n      for (zs = z + '.'; ++e; zs += z);\r\n      str = zs + str;\r\n\r\n    // Positive exponent\r\n    } else {\r\n      len = str.length;\r\n\r\n      // Append zeros.\r\n      if (++e > len) {\r\n        for (zs = z, e -= len; --e; zs += z);\r\n        str += zs;\r\n      } else if (e < len) {\r\n        str = str.slice(0, e) + '.' + str.slice(e);\r\n      }\r\n    }\r\n\r\n    return str;\r\n  }\r\n\r\n\r\n  // EXPORT\r\n\r\n\r\n  BigNumber = clone();\r\n  BigNumber['default'] = BigNumber.BigNumber = BigNumber;\r\n\r\n  // AMD.\r\n  if (true) {\r\n    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () { return BigNumber; }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\r\n  // Node.js and other environments that support module.exports.\r\n  } else {}\r\n})(this);\r\n\n\n//# sourceURL=webpack://webpack-demo/./node_modules/bignumber.js/bignumber.js?");

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n\n\nconst base64 = __webpack_require__(/*! base64-js */ \"./node_modules/base64-js/index.js\")\nconst ieee754 = __webpack_require__(/*! ieee754 */ \"./node_modules/ieee754/index.js\")\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n\n\n//# sourceURL=webpack://webpack-demo/./node_modules/buffer/index.js?");

/***/ }),

/***/ "./node_modules/cbor-web/dist/cbor.js":
/*!********************************************!*\
  !*** ./node_modules/cbor-web/dist/cbor.js ***!
  \********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("/*! For license information please see cbor.js.LICENSE.txt */\n!function(t,e){ true?module.exports=e(function(){try{return __webpack_require__(/*! bignumber.js */ \"./node_modules/bignumber.js/bignumber.js\")}catch(t){}}(),__webpack_require__(/*! util */ \"util\")):0}(this,(function(t,e){return(()=>{var r={742:(t,e)=>{\"use strict\";e.byteLength=function(t){var e=u(t),r=e[0],n=e[1];return 3*(r+n)/4-n},e.toByteArray=function(t){var e,r,o=u(t),s=o[0],a=o[1],l=new i(function(t,e,r){return 3*(e+r)/4-r}(0,s,a)),c=0,f=a>0?s-4:s;for(r=0;r<f;r+=4)e=n[t.charCodeAt(r)]<<18|n[t.charCodeAt(r+1)]<<12|n[t.charCodeAt(r+2)]<<6|n[t.charCodeAt(r+3)],l[c++]=e>>16&255,l[c++]=e>>8&255,l[c++]=255&e;return 2===a&&(e=n[t.charCodeAt(r)]<<2|n[t.charCodeAt(r+1)]>>4,l[c++]=255&e),1===a&&(e=n[t.charCodeAt(r)]<<10|n[t.charCodeAt(r+1)]<<4|n[t.charCodeAt(r+2)]>>2,l[c++]=e>>8&255,l[c++]=255&e),l},e.fromByteArray=function(t){for(var e,n=t.length,i=n%3,o=[],s=16383,a=0,u=n-i;a<u;a+=s)o.push(l(t,a,a+s>u?u:a+s));return 1===i?(e=t[n-1],o.push(r[e>>2]+r[e<<4&63]+\"==\")):2===i&&(e=(t[n-2]<<8)+t[n-1],o.push(r[e>>10]+r[e>>4&63]+r[e<<2&63]+\"=\")),o.join(\"\")};for(var r=[],n=[],i=\"undefined\"!=typeof Uint8Array?Uint8Array:Array,o=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",s=0,a=o.length;s<a;++s)r[s]=o[s],n[o.charCodeAt(s)]=s;function u(t){var e=t.length;if(e%4>0)throw new Error(\"Invalid string. Length must be a multiple of 4\");var r=t.indexOf(\"=\");return-1===r&&(r=e),[r,r===e?0:4-r%4]}function l(t,e,n){for(var i,o,s=[],a=e;a<n;a+=3)i=(t[a]<<16&16711680)+(t[a+1]<<8&65280)+(255&t[a+2]),s.push(r[(o=i)>>18&63]+r[o>>12&63]+r[o>>6&63]+r[63&o]);return s.join(\"\")}n[\"-\".charCodeAt(0)]=62,n[\"_\".charCodeAt(0)]=63},764:(t,e,r)=>{\"use strict\";const n=r(742),i=r(645),o=\"function\"==typeof Symbol&&\"function\"==typeof Symbol.for?Symbol.for(\"nodejs.util.inspect.custom\"):null;e.Buffer=u,e.SlowBuffer=function(t){return+t!=t&&(t=0),u.alloc(+t)},e.INSPECT_MAX_BYTES=50;const s=2147483647;function a(t){if(t>s)throw new RangeError('The value \"'+t+'\" is invalid for option \"size\"');const e=new Uint8Array(t);return Object.setPrototypeOf(e,u.prototype),e}function u(t,e,r){if(\"number\"==typeof t){if(\"string\"==typeof e)throw new TypeError('The \"string\" argument must be of type string. Received type number');return f(t)}return l(t,e,r)}function l(t,e,r){if(\"string\"==typeof t)return function(t,e){if(\"string\"==typeof e&&\"\"!==e||(e=\"utf8\"),!u.isEncoding(e))throw new TypeError(\"Unknown encoding: \"+e);const r=0|y(t,e);let n=a(r);const i=n.write(t,e);return i!==r&&(n=n.slice(0,i)),n}(t,e);if(ArrayBuffer.isView(t))return function(t){if(K(t,Uint8Array)){const e=new Uint8Array(t);return p(e.buffer,e.byteOffset,e.byteLength)}return h(t)}(t);if(null==t)throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \"+typeof t);if(K(t,ArrayBuffer)||t&&K(t.buffer,ArrayBuffer))return p(t,e,r);if(\"undefined\"!=typeof SharedArrayBuffer&&(K(t,SharedArrayBuffer)||t&&K(t.buffer,SharedArrayBuffer)))return p(t,e,r);if(\"number\"==typeof t)throw new TypeError('The \"value\" argument must not be of type number. Received type number');const n=t.valueOf&&t.valueOf();if(null!=n&&n!==t)return u.from(n,e,r);const i=function(t){if(u.isBuffer(t)){const e=0|d(t.length),r=a(e);return 0===r.length||t.copy(r,0,0,e),r}return void 0!==t.length?\"number\"!=typeof t.length||X(t.length)?a(0):h(t):\"Buffer\"===t.type&&Array.isArray(t.data)?h(t.data):void 0}(t);if(i)return i;if(\"undefined\"!=typeof Symbol&&null!=Symbol.toPrimitive&&\"function\"==typeof t[Symbol.toPrimitive])return u.from(t[Symbol.toPrimitive](\"string\"),e,r);throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \"+typeof t)}function c(t){if(\"number\"!=typeof t)throw new TypeError('\"size\" argument must be of type number');if(t<0)throw new RangeError('The value \"'+t+'\" is invalid for option \"size\"')}function f(t){return c(t),a(t<0?0:0|d(t))}function h(t){const e=t.length<0?0:0|d(t.length),r=a(e);for(let n=0;n<e;n+=1)r[n]=255&t[n];return r}function p(t,e,r){if(e<0||t.byteLength<e)throw new RangeError('\"offset\" is outside of buffer bounds');if(t.byteLength<e+(r||0))throw new RangeError('\"length\" is outside of buffer bounds');let n;return n=void 0===e&&void 0===r?new Uint8Array(t):void 0===r?new Uint8Array(t,e):new Uint8Array(t,e,r),Object.setPrototypeOf(n,u.prototype),n}function d(t){if(t>=s)throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\"+s.toString(16)+\" bytes\");return 0|t}function y(t,e){if(u.isBuffer(t))return t.length;if(ArrayBuffer.isView(t)||K(t,ArrayBuffer))return t.byteLength;if(\"string\"!=typeof t)throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type '+typeof t);const r=t.length,n=arguments.length>2&&!0===arguments[2];if(!n&&0===r)return 0;let i=!1;for(;;)switch(e){case\"ascii\":case\"latin1\":case\"binary\":return r;case\"utf8\":case\"utf-8\":return Y(t).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return 2*r;case\"hex\":return r>>>1;case\"base64\":return q(t).length;default:if(i)return n?-1:Y(t).length;e=(\"\"+e).toLowerCase(),i=!0}}function g(t,e,r){let n=!1;if((void 0===e||e<0)&&(e=0),e>this.length)return\"\";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return\"\";if((r>>>=0)<=(e>>>=0))return\"\";for(t||(t=\"utf8\");;)switch(t){case\"hex\":return R(this,e,r);case\"utf8\":case\"utf-8\":return I(this,e,r);case\"ascii\":return x(this,e,r);case\"latin1\":case\"binary\":return O(this,e,r);case\"base64\":return T(this,e,r);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return N(this,e,r);default:if(n)throw new TypeError(\"Unknown encoding: \"+t);t=(t+\"\").toLowerCase(),n=!0}}function b(t,e,r){const n=t[e];t[e]=t[r],t[r]=n}function m(t,e,r,n,i){if(0===t.length)return-1;if(\"string\"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),X(r=+r)&&(r=i?0:t.length-1),r<0&&(r=t.length+r),r>=t.length){if(i)return-1;r=t.length-1}else if(r<0){if(!i)return-1;r=0}if(\"string\"==typeof e&&(e=u.from(e,n)),u.isBuffer(e))return 0===e.length?-1:w(t,e,r,n,i);if(\"number\"==typeof e)return e&=255,\"function\"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(t,e,r):Uint8Array.prototype.lastIndexOf.call(t,e,r):w(t,[e],r,n,i);throw new TypeError(\"val must be string, number or Buffer\")}function w(t,e,r,n,i){let o,s=1,a=t.length,u=e.length;if(void 0!==n&&(\"ucs2\"===(n=String(n).toLowerCase())||\"ucs-2\"===n||\"utf16le\"===n||\"utf-16le\"===n)){if(t.length<2||e.length<2)return-1;s=2,a/=2,u/=2,r/=2}function l(t,e){return 1===s?t[e]:t.readUInt16BE(e*s)}if(i){let n=-1;for(o=r;o<a;o++)if(l(t,o)===l(e,-1===n?0:o-n)){if(-1===n&&(n=o),o-n+1===u)return n*s}else-1!==n&&(o-=o-n),n=-1}else for(r+u>a&&(r=a-u),o=r;o>=0;o--){let r=!0;for(let n=0;n<u;n++)if(l(t,o+n)!==l(e,n)){r=!1;break}if(r)return o}return-1}function _(t,e,r,n){r=Number(r)||0;const i=t.length-r;n?(n=Number(n))>i&&(n=i):n=i;const o=e.length;let s;for(n>o/2&&(n=o/2),s=0;s<n;++s){const n=parseInt(e.substr(2*s,2),16);if(X(n))return s;t[r+s]=n}return s}function E(t,e,r,n){return V(Y(e,t.length-r),t,r,n)}function v(t,e,r,n){return V(function(t){const e=[];for(let r=0;r<t.length;++r)e.push(255&t.charCodeAt(r));return e}(e),t,r,n)}function S(t,e,r,n){return V(q(e),t,r,n)}function A(t,e,r,n){return V(function(t,e){let r,n,i;const o=[];for(let s=0;s<t.length&&!((e-=2)<0);++s)r=t.charCodeAt(s),n=r>>8,i=r%256,o.push(i),o.push(n);return o}(e,t.length-r),t,r,n)}function T(t,e,r){return 0===e&&r===t.length?n.fromByteArray(t):n.fromByteArray(t.slice(e,r))}function I(t,e,r){r=Math.min(t.length,r);const n=[];let i=e;for(;i<r;){const e=t[i];let o=null,s=e>239?4:e>223?3:e>191?2:1;if(i+s<=r){let r,n,a,u;switch(s){case 1:e<128&&(o=e);break;case 2:r=t[i+1],128==(192&r)&&(u=(31&e)<<6|63&r,u>127&&(o=u));break;case 3:r=t[i+1],n=t[i+2],128==(192&r)&&128==(192&n)&&(u=(15&e)<<12|(63&r)<<6|63&n,u>2047&&(u<55296||u>57343)&&(o=u));break;case 4:r=t[i+1],n=t[i+2],a=t[i+3],128==(192&r)&&128==(192&n)&&128==(192&a)&&(u=(15&e)<<18|(63&r)<<12|(63&n)<<6|63&a,u>65535&&u<1114112&&(o=u))}}null===o?(o=65533,s=1):o>65535&&(o-=65536,n.push(o>>>10&1023|55296),o=56320|1023&o),n.push(o),i+=s}return function(t){const e=t.length;if(e<=B)return String.fromCharCode.apply(String,t);let r=\"\",n=0;for(;n<e;)r+=String.fromCharCode.apply(String,t.slice(n,n+=B));return r}(n)}e.kMaxLength=s,u.TYPED_ARRAY_SUPPORT=function(){try{const t=new Uint8Array(1),e={foo:function(){return 42}};return Object.setPrototypeOf(e,Uint8Array.prototype),Object.setPrototypeOf(t,e),42===t.foo()}catch(t){return!1}}(),u.TYPED_ARRAY_SUPPORT||\"undefined\"==typeof console||\"function\"!=typeof console.error||console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\"),Object.defineProperty(u.prototype,\"parent\",{enumerable:!0,get:function(){if(u.isBuffer(this))return this.buffer}}),Object.defineProperty(u.prototype,\"offset\",{enumerable:!0,get:function(){if(u.isBuffer(this))return this.byteOffset}}),u.poolSize=8192,u.from=function(t,e,r){return l(t,e,r)},Object.setPrototypeOf(u.prototype,Uint8Array.prototype),Object.setPrototypeOf(u,Uint8Array),u.alloc=function(t,e,r){return function(t,e,r){return c(t),t<=0?a(t):void 0!==e?\"string\"==typeof r?a(t).fill(e,r):a(t).fill(e):a(t)}(t,e,r)},u.allocUnsafe=function(t){return f(t)},u.allocUnsafeSlow=function(t){return f(t)},u.isBuffer=function(t){return null!=t&&!0===t._isBuffer&&t!==u.prototype},u.compare=function(t,e){if(K(t,Uint8Array)&&(t=u.from(t,t.offset,t.byteLength)),K(e,Uint8Array)&&(e=u.from(e,e.offset,e.byteLength)),!u.isBuffer(t)||!u.isBuffer(e))throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');if(t===e)return 0;let r=t.length,n=e.length;for(let i=0,o=Math.min(r,n);i<o;++i)if(t[i]!==e[i]){r=t[i],n=e[i];break}return r<n?-1:n<r?1:0},u.isEncoding=function(t){switch(String(t).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return!0;default:return!1}},u.concat=function(t,e){if(!Array.isArray(t))throw new TypeError('\"list\" argument must be an Array of Buffers');if(0===t.length)return u.alloc(0);let r;if(void 0===e)for(e=0,r=0;r<t.length;++r)e+=t[r].length;const n=u.allocUnsafe(e);let i=0;for(r=0;r<t.length;++r){let e=t[r];if(K(e,Uint8Array))i+e.length>n.length?(u.isBuffer(e)||(e=u.from(e)),e.copy(n,i)):Uint8Array.prototype.set.call(n,e,i);else{if(!u.isBuffer(e))throw new TypeError('\"list\" argument must be an Array of Buffers');e.copy(n,i)}i+=e.length}return n},u.byteLength=y,u.prototype._isBuffer=!0,u.prototype.swap16=function(){const t=this.length;if(t%2!=0)throw new RangeError(\"Buffer size must be a multiple of 16-bits\");for(let e=0;e<t;e+=2)b(this,e,e+1);return this},u.prototype.swap32=function(){const t=this.length;if(t%4!=0)throw new RangeError(\"Buffer size must be a multiple of 32-bits\");for(let e=0;e<t;e+=4)b(this,e,e+3),b(this,e+1,e+2);return this},u.prototype.swap64=function(){const t=this.length;if(t%8!=0)throw new RangeError(\"Buffer size must be a multiple of 64-bits\");for(let e=0;e<t;e+=8)b(this,e,e+7),b(this,e+1,e+6),b(this,e+2,e+5),b(this,e+3,e+4);return this},u.prototype.toString=function(){const t=this.length;return 0===t?\"\":0===arguments.length?I(this,0,t):g.apply(this,arguments)},u.prototype.toLocaleString=u.prototype.toString,u.prototype.equals=function(t){if(!u.isBuffer(t))throw new TypeError(\"Argument must be a Buffer\");return this===t||0===u.compare(this,t)},u.prototype.inspect=function(){let t=\"\";const r=e.INSPECT_MAX_BYTES;return t=this.toString(\"hex\",0,r).replace(/(.{2})/g,\"$1 \").trim(),this.length>r&&(t+=\" ... \"),\"<Buffer \"+t+\">\"},o&&(u.prototype[o]=u.prototype.inspect),u.prototype.compare=function(t,e,r,n,i){if(K(t,Uint8Array)&&(t=u.from(t,t.offset,t.byteLength)),!u.isBuffer(t))throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type '+typeof t);if(void 0===e&&(e=0),void 0===r&&(r=t?t.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),e<0||r>t.length||n<0||i>this.length)throw new RangeError(\"out of range index\");if(n>=i&&e>=r)return 0;if(n>=i)return-1;if(e>=r)return 1;if(this===t)return 0;let o=(i>>>=0)-(n>>>=0),s=(r>>>=0)-(e>>>=0);const a=Math.min(o,s),l=this.slice(n,i),c=t.slice(e,r);for(let t=0;t<a;++t)if(l[t]!==c[t]){o=l[t],s=c[t];break}return o<s?-1:s<o?1:0},u.prototype.includes=function(t,e,r){return-1!==this.indexOf(t,e,r)},u.prototype.indexOf=function(t,e,r){return m(this,t,e,r,!0)},u.prototype.lastIndexOf=function(t,e,r){return m(this,t,e,r,!1)},u.prototype.write=function(t,e,r,n){if(void 0===e)n=\"utf8\",r=this.length,e=0;else if(void 0===r&&\"string\"==typeof e)n=e,r=this.length,e=0;else{if(!isFinite(e))throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");e>>>=0,isFinite(r)?(r>>>=0,void 0===n&&(n=\"utf8\")):(n=r,r=void 0)}const i=this.length-e;if((void 0===r||r>i)&&(r=i),t.length>0&&(r<0||e<0)||e>this.length)throw new RangeError(\"Attempt to write outside buffer bounds\");n||(n=\"utf8\");let o=!1;for(;;)switch(n){case\"hex\":return _(this,t,e,r);case\"utf8\":case\"utf-8\":return E(this,t,e,r);case\"ascii\":case\"latin1\":case\"binary\":return v(this,t,e,r);case\"base64\":return S(this,t,e,r);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return A(this,t,e,r);default:if(o)throw new TypeError(\"Unknown encoding: \"+n);n=(\"\"+n).toLowerCase(),o=!0}},u.prototype.toJSON=function(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};const B=4096;function x(t,e,r){let n=\"\";r=Math.min(t.length,r);for(let i=e;i<r;++i)n+=String.fromCharCode(127&t[i]);return n}function O(t,e,r){let n=\"\";r=Math.min(t.length,r);for(let i=e;i<r;++i)n+=String.fromCharCode(t[i]);return n}function R(t,e,r){const n=t.length;(!e||e<0)&&(e=0),(!r||r<0||r>n)&&(r=n);let i=\"\";for(let n=e;n<r;++n)i+=J[t[n]];return i}function N(t,e,r){const n=t.slice(e,r);let i=\"\";for(let t=0;t<n.length-1;t+=2)i+=String.fromCharCode(n[t]+256*n[t+1]);return i}function L(t,e,r){if(t%1!=0||t<0)throw new RangeError(\"offset is not uint\");if(t+e>r)throw new RangeError(\"Trying to access beyond buffer length\")}function P(t,e,r,n,i,o){if(!u.isBuffer(t))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(e>i||e<o)throw new RangeError('\"value\" argument is out of bounds');if(r+n>t.length)throw new RangeError(\"Index out of range\")}function M(t,e,r,n,i){G(e,n,i,t,r,7);let o=Number(e&BigInt(4294967295));t[r++]=o,o>>=8,t[r++]=o,o>>=8,t[r++]=o,o>>=8,t[r++]=o;let s=Number(e>>BigInt(32)&BigInt(4294967295));return t[r++]=s,s>>=8,t[r++]=s,s>>=8,t[r++]=s,s>>=8,t[r++]=s,r}function U(t,e,r,n,i){G(e,n,i,t,r,7);let o=Number(e&BigInt(4294967295));t[r+7]=o,o>>=8,t[r+6]=o,o>>=8,t[r+5]=o,o>>=8,t[r+4]=o;let s=Number(e>>BigInt(32)&BigInt(4294967295));return t[r+3]=s,s>>=8,t[r+2]=s,s>>=8,t[r+1]=s,s>>=8,t[r]=s,r+8}function j(t,e,r,n,i,o){if(r+n>t.length)throw new RangeError(\"Index out of range\");if(r<0)throw new RangeError(\"Index out of range\")}function k(t,e,r,n,o){return e=+e,r>>>=0,o||j(t,0,r,4),i.write(t,e,r,n,23,4),r+4}function $(t,e,r,n,o){return e=+e,r>>>=0,o||j(t,0,r,8),i.write(t,e,r,n,52,8),r+8}u.prototype.slice=function(t,e){const r=this.length;(t=~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),(e=void 0===e?r:~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),e<t&&(e=t);const n=this.subarray(t,e);return Object.setPrototypeOf(n,u.prototype),n},u.prototype.readUintLE=u.prototype.readUIntLE=function(t,e,r){t>>>=0,e>>>=0,r||L(t,e,this.length);let n=this[t],i=1,o=0;for(;++o<e&&(i*=256);)n+=this[t+o]*i;return n},u.prototype.readUintBE=u.prototype.readUIntBE=function(t,e,r){t>>>=0,e>>>=0,r||L(t,e,this.length);let n=this[t+--e],i=1;for(;e>0&&(i*=256);)n+=this[t+--e]*i;return n},u.prototype.readUint8=u.prototype.readUInt8=function(t,e){return t>>>=0,e||L(t,1,this.length),this[t]},u.prototype.readUint16LE=u.prototype.readUInt16LE=function(t,e){return t>>>=0,e||L(t,2,this.length),this[t]|this[t+1]<<8},u.prototype.readUint16BE=u.prototype.readUInt16BE=function(t,e){return t>>>=0,e||L(t,2,this.length),this[t]<<8|this[t+1]},u.prototype.readUint32LE=u.prototype.readUInt32LE=function(t,e){return t>>>=0,e||L(t,4,this.length),(this[t]|this[t+1]<<8|this[t+2]<<16)+16777216*this[t+3]},u.prototype.readUint32BE=u.prototype.readUInt32BE=function(t,e){return t>>>=0,e||L(t,4,this.length),16777216*this[t]+(this[t+1]<<16|this[t+2]<<8|this[t+3])},u.prototype.readBigUInt64LE=Z((function(t){W(t>>>=0,\"offset\");const e=this[t],r=this[t+7];void 0!==e&&void 0!==r||z(t,this.length-8);const n=e+256*this[++t]+65536*this[++t]+this[++t]*2**24,i=this[++t]+256*this[++t]+65536*this[++t]+r*2**24;return BigInt(n)+(BigInt(i)<<BigInt(32))})),u.prototype.readBigUInt64BE=Z((function(t){W(t>>>=0,\"offset\");const e=this[t],r=this[t+7];void 0!==e&&void 0!==r||z(t,this.length-8);const n=e*2**24+65536*this[++t]+256*this[++t]+this[++t],i=this[++t]*2**24+65536*this[++t]+256*this[++t]+r;return(BigInt(n)<<BigInt(32))+BigInt(i)})),u.prototype.readIntLE=function(t,e,r){t>>>=0,e>>>=0,r||L(t,e,this.length);let n=this[t],i=1,o=0;for(;++o<e&&(i*=256);)n+=this[t+o]*i;return i*=128,n>=i&&(n-=Math.pow(2,8*e)),n},u.prototype.readIntBE=function(t,e,r){t>>>=0,e>>>=0,r||L(t,e,this.length);let n=e,i=1,o=this[t+--n];for(;n>0&&(i*=256);)o+=this[t+--n]*i;return i*=128,o>=i&&(o-=Math.pow(2,8*e)),o},u.prototype.readInt8=function(t,e){return t>>>=0,e||L(t,1,this.length),128&this[t]?-1*(255-this[t]+1):this[t]},u.prototype.readInt16LE=function(t,e){t>>>=0,e||L(t,2,this.length);const r=this[t]|this[t+1]<<8;return 32768&r?4294901760|r:r},u.prototype.readInt16BE=function(t,e){t>>>=0,e||L(t,2,this.length);const r=this[t+1]|this[t]<<8;return 32768&r?4294901760|r:r},u.prototype.readInt32LE=function(t,e){return t>>>=0,e||L(t,4,this.length),this[t]|this[t+1]<<8|this[t+2]<<16|this[t+3]<<24},u.prototype.readInt32BE=function(t,e){return t>>>=0,e||L(t,4,this.length),this[t]<<24|this[t+1]<<16|this[t+2]<<8|this[t+3]},u.prototype.readBigInt64LE=Z((function(t){W(t>>>=0,\"offset\");const e=this[t],r=this[t+7];void 0!==e&&void 0!==r||z(t,this.length-8);const n=this[t+4]+256*this[t+5]+65536*this[t+6]+(r<<24);return(BigInt(n)<<BigInt(32))+BigInt(e+256*this[++t]+65536*this[++t]+this[++t]*2**24)})),u.prototype.readBigInt64BE=Z((function(t){W(t>>>=0,\"offset\");const e=this[t],r=this[t+7];void 0!==e&&void 0!==r||z(t,this.length-8);const n=(e<<24)+65536*this[++t]+256*this[++t]+this[++t];return(BigInt(n)<<BigInt(32))+BigInt(this[++t]*2**24+65536*this[++t]+256*this[++t]+r)})),u.prototype.readFloatLE=function(t,e){return t>>>=0,e||L(t,4,this.length),i.read(this,t,!0,23,4)},u.prototype.readFloatBE=function(t,e){return t>>>=0,e||L(t,4,this.length),i.read(this,t,!1,23,4)},u.prototype.readDoubleLE=function(t,e){return t>>>=0,e||L(t,8,this.length),i.read(this,t,!0,52,8)},u.prototype.readDoubleBE=function(t,e){return t>>>=0,e||L(t,8,this.length),i.read(this,t,!1,52,8)},u.prototype.writeUintLE=u.prototype.writeUIntLE=function(t,e,r,n){t=+t,e>>>=0,r>>>=0,n||P(this,t,e,r,Math.pow(2,8*r)-1,0);let i=1,o=0;for(this[e]=255&t;++o<r&&(i*=256);)this[e+o]=t/i&255;return e+r},u.prototype.writeUintBE=u.prototype.writeUIntBE=function(t,e,r,n){t=+t,e>>>=0,r>>>=0,n||P(this,t,e,r,Math.pow(2,8*r)-1,0);let i=r-1,o=1;for(this[e+i]=255&t;--i>=0&&(o*=256);)this[e+i]=t/o&255;return e+r},u.prototype.writeUint8=u.prototype.writeUInt8=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,1,255,0),this[e]=255&t,e+1},u.prototype.writeUint16LE=u.prototype.writeUInt16LE=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,2,65535,0),this[e]=255&t,this[e+1]=t>>>8,e+2},u.prototype.writeUint16BE=u.prototype.writeUInt16BE=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,2,65535,0),this[e]=t>>>8,this[e+1]=255&t,e+2},u.prototype.writeUint32LE=u.prototype.writeUInt32LE=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,4,4294967295,0),this[e+3]=t>>>24,this[e+2]=t>>>16,this[e+1]=t>>>8,this[e]=255&t,e+4},u.prototype.writeUint32BE=u.prototype.writeUInt32BE=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,4,4294967295,0),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t,e+4},u.prototype.writeBigUInt64LE=Z((function(t,e=0){return M(this,t,e,BigInt(0),BigInt(\"0xffffffffffffffff\"))})),u.prototype.writeBigUInt64BE=Z((function(t,e=0){return U(this,t,e,BigInt(0),BigInt(\"0xffffffffffffffff\"))})),u.prototype.writeIntLE=function(t,e,r,n){if(t=+t,e>>>=0,!n){const n=Math.pow(2,8*r-1);P(this,t,e,r,n-1,-n)}let i=0,o=1,s=0;for(this[e]=255&t;++i<r&&(o*=256);)t<0&&0===s&&0!==this[e+i-1]&&(s=1),this[e+i]=(t/o>>0)-s&255;return e+r},u.prototype.writeIntBE=function(t,e,r,n){if(t=+t,e>>>=0,!n){const n=Math.pow(2,8*r-1);P(this,t,e,r,n-1,-n)}let i=r-1,o=1,s=0;for(this[e+i]=255&t;--i>=0&&(o*=256);)t<0&&0===s&&0!==this[e+i+1]&&(s=1),this[e+i]=(t/o>>0)-s&255;return e+r},u.prototype.writeInt8=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,1,127,-128),t<0&&(t=255+t+1),this[e]=255&t,e+1},u.prototype.writeInt16LE=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,2,32767,-32768),this[e]=255&t,this[e+1]=t>>>8,e+2},u.prototype.writeInt16BE=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,2,32767,-32768),this[e]=t>>>8,this[e+1]=255&t,e+2},u.prototype.writeInt32LE=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,4,2147483647,-2147483648),this[e]=255&t,this[e+1]=t>>>8,this[e+2]=t>>>16,this[e+3]=t>>>24,e+4},u.prototype.writeInt32BE=function(t,e,r){return t=+t,e>>>=0,r||P(this,t,e,4,2147483647,-2147483648),t<0&&(t=4294967295+t+1),this[e]=t>>>24,this[e+1]=t>>>16,this[e+2]=t>>>8,this[e+3]=255&t,e+4},u.prototype.writeBigInt64LE=Z((function(t,e=0){return M(this,t,e,-BigInt(\"0x8000000000000000\"),BigInt(\"0x7fffffffffffffff\"))})),u.prototype.writeBigInt64BE=Z((function(t,e=0){return U(this,t,e,-BigInt(\"0x8000000000000000\"),BigInt(\"0x7fffffffffffffff\"))})),u.prototype.writeFloatLE=function(t,e,r){return k(this,t,e,!0,r)},u.prototype.writeFloatBE=function(t,e,r){return k(this,t,e,!1,r)},u.prototype.writeDoubleLE=function(t,e,r){return $(this,t,e,!0,r)},u.prototype.writeDoubleBE=function(t,e,r){return $(this,t,e,!1,r)},u.prototype.copy=function(t,e,r,n){if(!u.isBuffer(t))throw new TypeError(\"argument should be a Buffer\");if(r||(r=0),n||0===n||(n=this.length),e>=t.length&&(e=t.length),e||(e=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===t.length||0===this.length)return 0;if(e<0)throw new RangeError(\"targetStart out of bounds\");if(r<0||r>=this.length)throw new RangeError(\"Index out of range\");if(n<0)throw new RangeError(\"sourceEnd out of bounds\");n>this.length&&(n=this.length),t.length-e<n-r&&(n=t.length-e+r);const i=n-r;return this===t&&\"function\"==typeof Uint8Array.prototype.copyWithin?this.copyWithin(e,r,n):Uint8Array.prototype.set.call(t,this.subarray(r,n),e),i},u.prototype.fill=function(t,e,r,n){if(\"string\"==typeof t){if(\"string\"==typeof e?(n=e,e=0,r=this.length):\"string\"==typeof r&&(n=r,r=this.length),void 0!==n&&\"string\"!=typeof n)throw new TypeError(\"encoding must be a string\");if(\"string\"==typeof n&&!u.isEncoding(n))throw new TypeError(\"Unknown encoding: \"+n);if(1===t.length){const e=t.charCodeAt(0);(\"utf8\"===n&&e<128||\"latin1\"===n)&&(t=e)}}else\"number\"==typeof t?t&=255:\"boolean\"==typeof t&&(t=Number(t));if(e<0||this.length<e||this.length<r)throw new RangeError(\"Out of range index\");if(r<=e)return this;let i;if(e>>>=0,r=void 0===r?this.length:r>>>0,t||(t=0),\"number\"==typeof t)for(i=e;i<r;++i)this[i]=t;else{const o=u.isBuffer(t)?t:u.from(t,n),s=o.length;if(0===s)throw new TypeError('The value \"'+t+'\" is invalid for argument \"value\"');for(i=0;i<r-e;++i)this[i+e]=o[i%s]}return this};const F={};function D(t,e,r){F[t]=class extends r{constructor(){super(),Object.defineProperty(this,\"message\",{value:e.apply(this,arguments),writable:!0,configurable:!0}),this.name=`${this.name} [${t}]`,this.stack,delete this.name}get code(){return t}set code(t){Object.defineProperty(this,\"code\",{configurable:!0,enumerable:!0,value:t,writable:!0})}toString(){return`${this.name} [${t}]: ${this.message}`}}}function C(t){let e=\"\",r=t.length;const n=\"-\"===t[0]?1:0;for(;r>=n+4;r-=3)e=`_${t.slice(r-3,r)}${e}`;return`${t.slice(0,r)}${e}`}function G(t,e,r,n,i,o){if(t>r||t<e){const n=\"bigint\"==typeof e?\"n\":\"\";let i;throw i=o>3?0===e||e===BigInt(0)?`>= 0${n} and < 2${n} ** ${8*(o+1)}${n}`:`>= -(2${n} ** ${8*(o+1)-1}${n}) and < 2 ** ${8*(o+1)-1}${n}`:`>= ${e}${n} and <= ${r}${n}`,new F.ERR_OUT_OF_RANGE(\"value\",i,t)}!function(t,e,r){W(e,\"offset\"),void 0!==t[e]&&void 0!==t[e+r]||z(e,t.length-(r+1))}(n,i,o)}function W(t,e){if(\"number\"!=typeof t)throw new F.ERR_INVALID_ARG_TYPE(e,\"number\",t)}function z(t,e,r){if(Math.floor(t)!==t)throw W(t,r),new F.ERR_OUT_OF_RANGE(r||\"offset\",\"an integer\",t);if(e<0)throw new F.ERR_BUFFER_OUT_OF_BOUNDS;throw new F.ERR_OUT_OF_RANGE(r||\"offset\",`>= ${r?1:0} and <= ${e}`,t)}D(\"ERR_BUFFER_OUT_OF_BOUNDS\",(function(t){return t?`${t} is outside of buffer bounds`:\"Attempt to access memory outside buffer bounds\"}),RangeError),D(\"ERR_INVALID_ARG_TYPE\",(function(t,e){return`The \"${t}\" argument must be of type number. Received type ${typeof e}`}),TypeError),D(\"ERR_OUT_OF_RANGE\",(function(t,e,r){let n=`The value of \"${t}\" is out of range.`,i=r;return Number.isInteger(r)&&Math.abs(r)>2**32?i=C(String(r)):\"bigint\"==typeof r&&(i=String(r),(r>BigInt(2)**BigInt(32)||r<-(BigInt(2)**BigInt(32)))&&(i=C(i)),i+=\"n\"),n+=` It must be ${e}. Received ${i}`,n}),RangeError);const H=/[^+/0-9A-Za-z-_]/g;function Y(t,e){let r;e=e||1/0;const n=t.length;let i=null;const o=[];for(let s=0;s<n;++s){if(r=t.charCodeAt(s),r>55295&&r<57344){if(!i){if(r>56319){(e-=3)>-1&&o.push(239,191,189);continue}if(s+1===n){(e-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(e-=3)>-1&&o.push(239,191,189),i=r;continue}r=65536+(i-55296<<10|r-56320)}else i&&(e-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((e-=1)<0)break;o.push(r)}else if(r<2048){if((e-=2)<0)break;o.push(r>>6|192,63&r|128)}else if(r<65536){if((e-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error(\"Invalid code point\");if((e-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return o}function q(t){return n.toByteArray(function(t){if((t=(t=t.split(\"=\")[0]).trim().replace(H,\"\")).length<2)return\"\";for(;t.length%4!=0;)t+=\"=\";return t}(t))}function V(t,e,r,n){let i;for(i=0;i<n&&!(i+r>=e.length||i>=t.length);++i)e[i+r]=t[i];return i}function K(t,e){return t instanceof e||null!=t&&null!=t.constructor&&null!=t.constructor.name&&t.constructor.name===e.name}function X(t){return t!=t}const J=function(){const t=\"0123456789abcdef\",e=new Array(256);for(let r=0;r<16;++r){const n=16*r;for(let i=0;i<16;++i)e[n+i]=t[r]+t[i]}return e}();function Z(t){return\"undefined\"==typeof BigInt?Q:t}function Q(){throw new Error(\"BigInt not supported\")}},141:(t,e,r)=>{\"use strict\";e.BigNumber=r(66).BigNumber,e.Commented=r(20),e.Diagnose=r(694),e.Decoder=r(774),e.Encoder=r(666),e.Simple=r(32),e.Tagged=r(785),e.Map=r(70),e.UI=e.Commented.comment,e.fI=e.Decoder.decodeAll,e.h8=e.Decoder.decodeFirst,e.cc=e.Decoder.decodeAllSync,e.$u=e.Decoder.decodeFirstSync,e.M=e.Diagnose.diagnose,e.cv=e.Encoder.encode,e.N2=e.Encoder.encodeCanonical,e.TG=e.Encoder.encodeOne,e.WR=e.Encoder.encodeAsync,e.Jx=e.Decoder.decodeFirstSync,e.ww={decode:e.Decoder.decodeFirstSync,encode:e.Encoder.encode,buffer:!0,name:\"cbor\"},e.vc=!0},20:(t,e,r)=>{\"use strict\";const n=r(830),i=r(873),o=r(774),s=r(202),{MT:a,NUMBYTES:u,SYMS:l}=r(66),{Buffer:c}=r(764);function f(t){return t>1?\"s\":\"\"}class h extends n.Transform{constructor(t={}){const{depth:e=1,max_depth:r=10,no_summary:n=!1,tags:i={},bigint:a,preferWeb:u,encoding:l,...c}=t;super({...c,readableObjectMode:!1,writableObjectMode:!1}),this.depth=e,this.max_depth=r,this.all=new s,i[24]||(i[24]=this._tag_24.bind(this)),this.parser=new o({tags:i,max_depth:r,bigint:a,preferWeb:u,encoding:l}),this.parser.on(\"value\",this._on_value.bind(this)),this.parser.on(\"start\",this._on_start.bind(this)),this.parser.on(\"start-string\",this._on_start_string.bind(this)),this.parser.on(\"stop\",this._on_stop.bind(this)),this.parser.on(\"more-bytes\",this._on_more.bind(this)),this.parser.on(\"error\",this._on_error.bind(this)),n||this.parser.on(\"data\",this._on_data.bind(this)),this.parser.bs.on(\"read\",this._on_read.bind(this))}_tag_24(t){const e=new h({depth:this.depth+1,no_summary:!0});e.on(\"data\",(t=>this.push(t))),e.on(\"error\",(t=>this.emit(\"error\",t))),e.end(t)}_transform(t,e,r){this.parser.write(t,e,r)}_flush(t){return this.parser._flush(t)}static comment(t,e={},r=null){if(null==t)throw new Error(\"input required\");({options:e,cb:r}=function(t,e){switch(typeof t){case\"function\":return{options:{},cb:t};case\"string\":return{options:{encoding:t},cb:e};case\"number\":return{options:{max_depth:t},cb:e};case\"object\":return{options:t||{},cb:e};default:throw new TypeError(\"Unknown option type\")}}(e,r));const n=new s,{encoding:o=\"hex\",...a}=e,u=new h(a);let l=null;return\"function\"==typeof r?(u.on(\"end\",(()=>{r(null,n.toString(\"utf8\"))})),u.on(\"error\",r)):l=new Promise(((t,e)=>{u.on(\"end\",(()=>{t(n.toString(\"utf8\"))})),u.on(\"error\",e)})),u.pipe(n),i.guessEncoding(t,o).pipe(u),l}_on_error(t){this.push(\"ERROR: \"),this.push(t.toString()),this.push(\"\\n\")}_on_read(t){this.all.write(t);const e=t.toString(\"hex\");this.push(new Array(this.depth+1).join(\"  \")),this.push(e);let r=2*(this.max_depth-this.depth)-e.length;return r<1&&(r=1),this.push(new Array(r+1).join(\" \")),this.push(\"-- \")}_on_more(t,e,r,n){let i=\"\";switch(this.depth++,t){case a.POS_INT:i=\"Positive number,\";break;case a.NEG_INT:i=\"Negative number,\";break;case a.ARRAY:i=\"Array, length\";break;case a.MAP:i=\"Map, count\";break;case a.BYTE_STRING:i=\"Bytes, length\";break;case a.UTF8_STRING:i=\"String, length\";break;case a.SIMPLE_FLOAT:i=1===e?\"Simple value,\":\"Float,\"}return this.push(i+\" next \"+e+\" byte\"+f(e)+\"\\n\")}_on_start_string(t,e,r,n){let i=\"\";switch(this.depth++,t){case a.BYTE_STRING:i=\"Bytes, length: \"+e;break;case a.UTF8_STRING:i=\"String, length: \"+e.toString()}return this.push(i+\"\\n\")}_on_start(t,e,r,n){switch(this.depth++,r){case a.ARRAY:this.push(`[${n}], `);break;case a.MAP:n%2?this.push(`{Val:${Math.floor(n/2)}}, `):this.push(`{Key:${Math.floor(n/2)}}, `)}switch(t){case a.TAG:this.push(`Tag #${e}`),24===e&&this.push(\" Encoded CBOR data item\");break;case a.ARRAY:e===l.STREAM?this.push(\"Array (streaming)\"):this.push(`Array, ${e} item${f(e)}`);break;case a.MAP:e===l.STREAM?this.push(\"Map (streaming)\"):this.push(`Map, ${e} pair${f(e)}`);break;case a.BYTE_STRING:this.push(\"Bytes (streaming)\");break;case a.UTF8_STRING:this.push(\"String (streaming)\")}return this.push(\"\\n\")}_on_stop(t){return this.depth--}_on_value(t,e,r,n){if(t!==l.BREAK)switch(e){case a.ARRAY:this.push(`[${r}], `);break;case a.MAP:r%2?this.push(`{Val:${Math.floor(r/2)}}, `):this.push(`{Key:${Math.floor(r/2)}}, `)}const o=i.cborValueToString(t,-1/0);switch(\"string\"==typeof t||c.isBuffer(t)?(t.length>0&&(this.push(o),this.push(\"\\n\")),this.depth--):(this.push(o),this.push(\"\\n\")),n){case u.ONE:case u.TWO:case u.FOUR:case u.EIGHT:this.depth--}}_on_data(){return this.push(\"0x\"),this.push(this.all.read().toString(\"hex\")),this.push(\"\\n\")}}t.exports=h},66:(t,e,r)=>{\"use strict\";let n=null;try{n=r(937).BigNumber}catch(t){}if(e.BigNumber=n,e.MT={POS_INT:0,NEG_INT:1,BYTE_STRING:2,UTF8_STRING:3,ARRAY:4,MAP:5,TAG:6,SIMPLE_FLOAT:7},e.TAG={DATE_STRING:0,DATE_EPOCH:1,POS_BIGINT:2,NEG_BIGINT:3,DECIMAL_FRAC:4,BIGFLOAT:5,BASE64URL_EXPECTED:21,BASE64_EXPECTED:22,BASE16_EXPECTED:23,CBOR:24,URI:32,BASE64URL:33,BASE64:34,REGEXP:35,MIME:36,SET:258},e.NUMBYTES={ZERO:0,ONE:24,TWO:25,FOUR:26,EIGHT:27,INDEFINITE:31},e.SIMPLE={FALSE:20,TRUE:21,NULL:22,UNDEFINED:23},e.SYMS={NULL:Symbol.for(\"github.com/hildjj/node-cbor/null\"),UNDEFINED:Symbol.for(\"github.com/hildjj/node-cbor/undef\"),PARENT:Symbol.for(\"github.com/hildjj/node-cbor/parent\"),BREAK:Symbol.for(\"github.com/hildjj/node-cbor/break\"),STREAM:Symbol.for(\"github.com/hildjj/node-cbor/stream\")},e.SHIFT32=4294967296,e.BI={MINUS_ONE:BigInt(-1),NEG_MAX:BigInt(-1)-BigInt(Number.MAX_SAFE_INTEGER),MAXINT32:BigInt(\"0xffffffff\"),MAXINT64:BigInt(\"0xffffffffffffffff\"),SHIFT32:BigInt(e.SHIFT32)},e.BigNumber){const t=new e.BigNumber(-1);e.BN={MINUS_ONE:t,NEG_MAX:t.minus(new e.BigNumber(Number.MAX_SAFE_INTEGER.toString(16),16)),TWO:new e.BigNumber(2),MAXINT:new e.BigNumber(\"0x20000000000000\"),MAXINT32:new e.BigNumber(4294967295),MAXINT64:new e.BigNumber(\"0xffffffffffffffff\"),SHIFT32:new e.BigNumber(e.SHIFT32)}}},774:(t,e,r)=>{\"use strict\";const n=r(71),i=r(785),o=r(32),s=r(873),a=r(202),u=r(66),{MT:l,NUMBYTES:c,SYMS:f,BI:h}=u,{Buffer:p}=r(764),d=Symbol(\"count\"),y=Symbol(\"major type\"),g=Symbol(\"error\"),b=Symbol(\"not found\");function m(t,e,r){const n=[];return n[d]=r,n[f.PARENT]=t,n[y]=e,n}function w(t,e){const r=new a;return r[d]=-1,r[f.PARENT]=t,r[y]=e,r}function _(t){return s.bufferToBigInt(t)}function E(t){return h.MINUS_ONE-s.bufferToBigInt(t)}class v extends Error{constructor(t,e){super(`Unexpected data: 0x${t.toString(16)}`),this.name=\"UnexpectedDataError\",this.byte=t,this.value=e}}function S(t,e){switch(typeof t){case\"function\":return{options:{},cb:t};case\"string\":return{options:{encoding:t},cb:e};case\"object\":return{options:t||{},cb:e};default:throw new TypeError(\"Unknown option type\")}}class A extends n{constructor(t={}){const{tags:e={},max_depth:r=-1,bigint:n=!0,preferWeb:i=!1,required:o=!1,encoding:s=\"hex\",extendedResults:u=!1,...l}=t;super({defaultEncoding:s,...l}),this.running=!0,this.max_depth=r,this.tags=e,this.preferWeb=i,this.extendedResults=u,this.bigint=n,this.required=o,u&&(this.bs.on(\"read\",this._onRead.bind(this)),this.valueBytes=new a),n&&(null==this.tags[2]&&(this.tags[2]=_),null==this.tags[3]&&(this.tags[3]=E))}static nullcheck(t){switch(t){case f.NULL:return null;case f.UNDEFINED:return;case b:throw new Error(\"Value not found\");default:return t}}static decodeFirstSync(t,e={}){if(null==t)throw new TypeError(\"input required\");({options:e}=S(e));const{encoding:r=\"hex\",...n}=e,i=new A(n),o=s.guessEncoding(t,r),a=i._parse();let u=a.next();for(;!u.done;){const t=o.read(u.value);if(null==t||t.length!==u.value)throw new Error(\"Insufficient data\");i.extendedResults&&i.valueBytes.write(t),u=a.next(t)}let l=null;if(i.extendedResults)l=u.value,l.unused=o.read();else if(l=A.nullcheck(u.value),o.length>0){const t=o.read(1);throw o.unshift(t),new v(t[0],l)}return l}static decodeAllSync(t,e={}){if(null==t)throw new TypeError(\"input required\");({options:e}=S(e));const{encoding:r=\"hex\",...n}=e,i=new A(n),o=s.guessEncoding(t,r),a=[];for(;o.length>0;){const t=i._parse();let e=t.next();for(;!e.done;){const r=o.read(e.value);if(null==r||r.length!==e.value)throw new Error(\"Insufficient data\");i.extendedResults&&i.valueBytes.write(r),e=t.next(r)}a.push(A.nullcheck(e.value))}return a}static decodeFirst(t,e={},r=null){if(null==t)throw new TypeError(\"input required\");({options:e,cb:r}=S(e,r));const{encoding:n=\"hex\",required:i=!1,...o}=e,a=new A(o);let u=b;const l=s.guessEncoding(t,n),c=new Promise(((t,e)=>{a.on(\"data\",(t=>{u=A.nullcheck(t),a.close()})),a.once(\"error\",(r=>a.extendedResults&&r instanceof v?(u.unused=a.bs.slice(),t(u)):(u!==b&&(r.value=u),u=g,a.close(),e(r)))),a.once(\"end\",(()=>{switch(u){case b:return i?e(new Error(\"No CBOR found\")):t(u);case g:return;default:return t(u)}}))}));return\"function\"==typeof r&&c.then((t=>r(null,t)),r),l.pipe(a),c}static decodeAll(t,e={},r=null){if(null==t)throw new TypeError(\"input required\");({options:e,cb:r}=S(e,r));const{encoding:n=\"hex\",...i}=e,o=new A(i),a=[];o.on(\"data\",(t=>a.push(A.nullcheck(t))));const u=new Promise(((t,e)=>{o.on(\"error\",e),o.on(\"end\",(()=>t(a)))}));return\"function\"==typeof r&&u.then((t=>r(void 0,t)),(t=>r(t,void 0))),s.guessEncoding(t,n).pipe(o),u}close(){this.running=!1,this.__fresh=!0}_onRead(t){this.valueBytes.write(t)}*_parse(){let t=null,e=0,r=null;for(;;){if(this.max_depth>=0&&e>this.max_depth)throw new Error(\"Maximum depth \"+this.max_depth+\" exceeded\");const[n]=yield 1;if(!this.running)throw this.bs.unshift(p.from([n])),new v(n);const g=n>>5,b=31&n,_=null!=t?t[y]:void 0,E=null!=t?t.length:void 0;switch(b){case c.ONE:this.emit(\"more-bytes\",g,1,_,E),[r]=yield 1;break;case c.TWO:case c.FOUR:case c.EIGHT:{const t=1<<b-24;this.emit(\"more-bytes\",g,t,_,E);const e=yield t;r=g===l.SIMPLE_FLOAT?e:s.parseCBORint(b,e,this.bigint);break}case 28:case 29:case 30:throw this.running=!1,new Error(\"Additional info not implemented: \"+b);case c.INDEFINITE:switch(g){case l.POS_INT:case l.NEG_INT:case l.TAG:throw new Error(`Invalid indefinite encoding for MT ${g}`)}r=-1;break;default:r=b}switch(g){case l.POS_INT:break;case l.NEG_INT:if(r===Number.MAX_SAFE_INTEGER)if(this.bigint)r=h.NEG_MAX;else{if(!u.BigNumber)throw new Error(\"No bigint and no bignumber.js\");r=u.BN.NEG_MAX}else r=u.BigNumber&&r instanceof u.BigNumber?u.BN.MINUS_ONE.minus(r):\"bigint\"==typeof r?h.MINUS_ONE-r:-1-r;break;case l.BYTE_STRING:case l.UTF8_STRING:switch(r){case 0:this.emit(\"start-string\",g,r,_,E),r=g===l.UTF8_STRING?\"\":this.preferWeb?new Uint8Array(0):p.allocUnsafe(0);break;case-1:this.emit(\"start\",g,f.STREAM,_,E),t=w(t,g),e++;continue;default:this.emit(\"start-string\",g,r,_,E),r=yield r,g===l.UTF8_STRING?r=s.utf8(r):this.preferWeb&&(r=new Uint8Array(r.buffer,r.byteOffset,r.length))}break;case l.ARRAY:case l.MAP:switch(r){case 0:r=g===l.MAP?{}:[];break;case-1:this.emit(\"start\",g,f.STREAM,_,E),t=m(t,g,-1),e++;continue;default:this.emit(\"start\",g,r,_,E),t=m(t,g,r*(g-3)),e++;continue}break;case l.TAG:this.emit(\"start\",g,r,_,E),t=m(t,g,1),t.push(r),e++;continue;case l.SIMPLE_FLOAT:if(\"number\"==typeof r){if(b===c.ONE&&r<32)throw new Error(`Invalid two-byte encoding of simple value ${r}`);const e=null!=t;r=o.decode(r,e,e&&t[d]<0)}else r=s.parseCBORfloat(r)}this.emit(\"value\",r,_,E,b);let S=!1;for(;null!=t;){switch(!1){case r!==f.BREAK:t[d]=1;break;case!Array.isArray(t):t.push(r);break;case!(t instanceof a):{const e=t[y];if(null!=e&&e!==g)throw this.running=!1,new Error(\"Invalid major type in indefinite encoding\");t.write(r)}}if(0!=--t[d]){S=!0;break}if(--e,delete t[d],Array.isArray(t))switch(t[y]){case l.ARRAY:r=t;break;case l.MAP:{let e=!0;if(t.length%2!=0)throw new Error(\"Invalid map length: \"+t.length);for(let r=0,n=t.length;r<n;r+=2)if(\"string\"!=typeof t[r]){e=!1;break}if(e){r={};for(let e=0,n=t.length;e<n;e+=2)r[t[e]]=t[e+1]}else{r=new Map;for(let e=0,n=t.length;e<n;e+=2)r.set(t[e],t[e+1])}break}case l.TAG:r=new i(t[0],t[1]).convert(this.tags)}else if(t instanceof a)switch(t[y]){case l.BYTE_STRING:r=t.slice(),this.preferWeb&&(r=new Uint8Array(r.buffer,r.byteOffset,r.length));break;case l.UTF8_STRING:r=t.toString(\"utf-8\")}this.emit(\"stop\",t[y]);const n=t;t=t[f.PARENT],delete n[f.PARENT],delete n[y]}if(!S){if(this.extendedResults){const t=this.valueBytes.slice(),e={value:A.nullcheck(r),bytes:t,length:t.length};return this.valueBytes=new a,e}return r}}}}A.NOT_FOUND=b,t.exports=A},694:(t,e,r)=>{\"use strict\";const n=r(830),i=r(774),o=r(873),s=r(202),{MT:a,SYMS:u}=r(66);class l extends n.Transform{constructor(t={}){const{separator:e=\"\\n\",stream_errors:r=!1,tags:n,max_depth:o,bigint:s,preferWeb:a,encoding:u,...l}=t;super({...l,readableObjectMode:!1,writableObjectMode:!1}),this.float_bytes=-1,this.separator=e,this.stream_errors=r,this.parser=new i({tags:n,max_depth:o,bigint:s,preferWeb:a,encoding:u}),this.parser.on(\"more-bytes\",this._on_more.bind(this)),this.parser.on(\"value\",this._on_value.bind(this)),this.parser.on(\"start\",this._on_start.bind(this)),this.parser.on(\"stop\",this._on_stop.bind(this)),this.parser.on(\"data\",this._on_data.bind(this)),this.parser.on(\"error\",this._on_error.bind(this))}_transform(t,e,r){return this.parser.write(t,e,r)}_flush(t){return this.parser._flush((e=>this.stream_errors?(e&&this._on_error(e),t()):t(e)))}static diagnose(t,e={},r=null){if(null==t)throw new Error(\"input required\");({options:e,cb:r}=function(t,e){switch(typeof t){case\"function\":return{options:{},cb:t};case\"string\":return{options:{encoding:t},cb:e};case\"object\":return{options:t||{},cb:e};default:throw new TypeError(\"Unknown option type\")}}(e,r));const{encoding:n=\"hex\",...i}=e,a=new s,u=new l(i);let c=null;return\"function\"==typeof r?(u.on(\"end\",(()=>r(null,a.toString(\"utf8\")))),u.on(\"error\",r)):c=new Promise(((t,e)=>{u.on(\"end\",(()=>t(a.toString(\"utf8\")))),u.on(\"error\",e)})),u.pipe(a),o.guessEncoding(t,n).pipe(u),c}_on_error(t){return this.stream_errors?this.push(t.toString()):this.emit(\"error\",t)}_on_more(t,e,r,n){t===a.SIMPLE_FLOAT&&(this.float_bytes={2:1,4:2,8:3}[e])}_fore(t,e){switch(t){case a.BYTE_STRING:case a.UTF8_STRING:case a.ARRAY:e>0&&this.push(\", \");break;case a.MAP:e>0&&(e%2?this.push(\": \"):this.push(\", \"))}}_on_value(t,e,r){if(t===u.BREAK)return;this._fore(e,r);const n=this.float_bytes;this.float_bytes=-1,this.push(o.cborValueToString(t,n))}_on_start(t,e,r,n){switch(this._fore(r,n),t){case a.TAG:this.push(`${e}(`);break;case a.ARRAY:this.push(\"[\");break;case a.MAP:this.push(\"{\");break;case a.BYTE_STRING:case a.UTF8_STRING:this.push(\"(\")}e===u.STREAM&&this.push(\"_ \")}_on_stop(t){switch(t){case a.TAG:this.push(\")\");break;case a.ARRAY:this.push(\"]\");break;case a.MAP:this.push(\"}\");break;case a.BYTE_STRING:case a.UTF8_STRING:this.push(\")\")}}_on_data(){this.push(this.separator)}}t.exports=l},666:(t,e,r)=>{\"use strict\";const n=r(830),i=r(202),o=r(873),s=r(66),{MT:a,NUMBYTES:u,SHIFT32:l,SIMPLE:c,SYMS:f,TAG:h,BI:p}=s,{Buffer:d}=r(764),y=a.SIMPLE_FLOAT<<5|u.TWO,g=a.SIMPLE_FLOAT<<5|u.FOUR,b=a.SIMPLE_FLOAT<<5|u.EIGHT,m=a.SIMPLE_FLOAT<<5|c.TRUE,w=a.SIMPLE_FLOAT<<5|c.FALSE,_=a.SIMPLE_FLOAT<<5|c.UNDEFINED,E=a.SIMPLE_FLOAT<<5|c.NULL,v=d.from([255]),S=d.from(\"f97e00\",\"hex\"),A=d.from(\"f9fc00\",\"hex\"),T=d.from(\"f97c00\",\"hex\"),I=d.from(\"f98000\",\"hex\");class B extends n.Transform{constructor(t={}){const{canonical:e=!1,encodeUndefined:r,disallowUndefinedKeys:n=!1,dateType:o=\"number\",collapseBigIntegers:a=!1,detectLoops:u=!1,omitUndefinedProperties:l=!1,genTypes:c=[],...f}=t;if(super({...f,readableObjectMode:!1,writableObjectMode:!0}),this.canonical=e,this.encodeUndefined=r,this.disallowUndefinedKeys=n,this.dateType=function(t){if(!t)return\"number\";switch(t.toLowerCase()){case\"number\":return\"number\";case\"float\":return\"float\";case\"int\":return\"int\";case\"string\":return\"string\"}throw new TypeError(`dateType invalid, got \"${t}\"`)}(o),this.collapseBigIntegers=!!this.canonical||a,this.detectLoops=u,\"boolean\"==typeof u)u&&(this.detectLoops=new WeakSet);else if(!(u instanceof WeakSet))throw new TypeError(\"detectLoops must be boolean or WeakSet\");if(this.omitUndefinedProperties=l,this.semanticTypes={Array:this._pushArray,Date:this._pushDate,Buffer:this._pushBuffer,[d.name]:this._pushBuffer,Map:this._pushMap,NoFilter:this._pushNoFilter,[i.name]:this._pushNoFilter,RegExp:this._pushRegexp,Set:this._pushSet,ArrayBuffer:this._pushArrayBuffer,Uint8ClampedArray:this._pushTypedArray,Uint8Array:this._pushTypedArray,Uint16Array:this._pushTypedArray,Uint32Array:this._pushTypedArray,Int8Array:this._pushTypedArray,Int16Array:this._pushTypedArray,Int32Array:this._pushTypedArray,Float32Array:this._pushTypedArray,Float64Array:this._pushTypedArray,BigUint64Array:this._pushTypedArray,BigInt64Array:this._pushTypedArray,URL:this._pushURL,Boolean:this._pushBoxed,Number:this._pushBoxed,String:this._pushBoxed},s.BigNumber&&(this.semanticTypes[s.BigNumber.name]=this._pushBigNumber),Array.isArray(c))for(let t=0,e=c.length;t<e;t+=2)this.addSemanticType(c[t],c[t+1]);else for(const[t,e]of Object.entries(c))this.addSemanticType(t,e)}_transform(t,e,r){return r(!1===this.pushAny(t)?new Error(\"Push Error\"):void 0)}_flush(t){return t()}addSemanticType(t,e){const r=\"string\"==typeof t?t:t.name,n=this.semanticTypes[r];if(e){if(\"function\"!=typeof e)throw new TypeError(\"fun must be of type function\");this.semanticTypes[r]=e}else n&&delete this.semanticTypes[r];return n}_pushUInt8(t){const e=d.allocUnsafe(1);return e.writeUInt8(t,0),this.push(e)}_pushUInt16BE(t){const e=d.allocUnsafe(2);return e.writeUInt16BE(t,0),this.push(e)}_pushUInt32BE(t){const e=d.allocUnsafe(4);return e.writeUInt32BE(t,0),this.push(e)}_pushFloatBE(t){const e=d.allocUnsafe(4);return e.writeFloatBE(t,0),this.push(e)}_pushDoubleBE(t){const e=d.allocUnsafe(8);return e.writeDoubleBE(t,0),this.push(e)}_pushNaN(){return this.push(S)}_pushInfinity(t){const e=t<0?A:T;return this.push(e)}_pushFloat(t){if(this.canonical){const e=d.allocUnsafe(2);if(o.writeHalf(e,t))return this._pushUInt8(y)&&this.push(e)}return Math.fround(t)===t?this._pushUInt8(g)&&this._pushFloatBE(t):this._pushUInt8(b)&&this._pushDoubleBE(t)}_pushInt(t,e,r){const n=e<<5;switch(!1){case!(t<24):return this._pushUInt8(n|t);case!(t<=255):return this._pushUInt8(n|u.ONE)&&this._pushUInt8(t);case!(t<=65535):return this._pushUInt8(n|u.TWO)&&this._pushUInt16BE(t);case!(t<=4294967295):return this._pushUInt8(n|u.FOUR)&&this._pushUInt32BE(t);case!(t<=Number.MAX_SAFE_INTEGER):return this._pushUInt8(n|u.EIGHT)&&this._pushUInt32BE(Math.floor(t/l))&&this._pushUInt32BE(t%l);default:return e===a.NEG_INT?this._pushFloat(r):this._pushFloat(t)}}_pushIntNum(t){return Object.is(t,-0)?this.push(I):t<0?this._pushInt(-t-1,a.NEG_INT,t):this._pushInt(t,a.POS_INT)}_pushNumber(t){switch(!1){case!isNaN(t):return this._pushNaN();case isFinite(t):return this._pushInfinity(t);case Math.round(t)!==t:return this._pushIntNum(t);default:return this._pushFloat(t)}}_pushString(t){const e=d.byteLength(t,\"utf8\");return this._pushInt(e,a.UTF8_STRING)&&this.push(t,\"utf8\")}_pushBoolean(t){return this._pushUInt8(t?m:w)}_pushUndefined(t){switch(typeof this.encodeUndefined){case\"undefined\":return this._pushUInt8(_);case\"function\":return this.pushAny(this.encodeUndefined.call(this,t));case\"object\":{const t=o.bufferishToBuffer(this.encodeUndefined);if(t)return this.push(t)}}return this.pushAny(this.encodeUndefined)}_pushNull(t){return this._pushUInt8(E)}_pushArray(t,e,r){r={indefinite:!1,...r};const n=e.length;if(r.indefinite){if(!t._pushUInt8(a.ARRAY<<5|u.INDEFINITE))return!1}else if(!t._pushInt(n,a.ARRAY))return!1;for(let r=0;r<n;r++)if(!t.pushAny(e[r]))return!1;return!(r.indefinite&&!t.push(v))}_pushTag(t){return this._pushInt(t,a.TAG)}_pushDate(t,e){switch(t.dateType){case\"string\":return t._pushTag(h.DATE_STRING)&&t._pushString(e.toISOString());case\"int\":case\"integer\":return t._pushTag(h.DATE_EPOCH)&&t._pushIntNum(Math.round(e/1e3));case\"float\":return t._pushTag(h.DATE_EPOCH)&&t._pushFloat(e/1e3);case\"number\":default:return t._pushTag(h.DATE_EPOCH)&&t.pushAny(e/1e3)}}_pushBuffer(t,e){return t._pushInt(e.length,a.BYTE_STRING)&&t.push(e)}_pushNoFilter(t,e){return t._pushBuffer(t,e.slice())}_pushRegexp(t,e){return t._pushTag(h.REGEXP)&&t.pushAny(e.source)}_pushSet(t,e){if(!t._pushTag(h.SET))return!1;if(!t._pushInt(e.size,a.ARRAY))return!1;for(const r of e)if(!t.pushAny(r))return!1;return!0}_pushURL(t,e){return t._pushTag(h.URI)&&t.pushAny(e.toString())}_pushBoxed(t,e){return t._pushAny(e.valueOf())}_pushBigint(t){let e=a.POS_INT,r=h.POS_BIGINT;if(t.isNegative()&&(t=t.negated().minus(1),e=a.NEG_INT,r=h.NEG_BIGINT),this.collapseBigIntegers&&t.lte(s.BN.MAXINT64))return t.lte(s.BN.MAXINT32)?this._pushInt(t.toNumber(),e):this._pushUInt8(e<<5|u.EIGHT)&&this._pushUInt32BE(t.dividedToIntegerBy(s.BN.SHIFT32).toNumber())&&this._pushUInt32BE(t.mod(s.BN.SHIFT32).toNumber());let n=t.toString(16);n.length%2&&(n=\"0\"+n);const i=d.from(n,\"hex\");return this._pushTag(r)&&this._pushBuffer(this,i)}_pushJSBigint(t){let e=a.POS_INT,r=h.POS_BIGINT;if(t<0&&(t=-t+p.MINUS_ONE,e=a.NEG_INT,r=h.NEG_BIGINT),this.collapseBigIntegers&&t<=p.MAXINT64)return t<=4294967295?this._pushInt(Number(t),e):this._pushUInt8(e<<5|u.EIGHT)&&this._pushUInt32BE(Number(t/p.SHIFT32))&&this._pushUInt32BE(Number(t%p.SHIFT32));let n=t.toString(16);n.length%2&&(n=\"0\"+n);const i=d.from(n,\"hex\");return this._pushTag(r)&&this._pushBuffer(this,i)}_pushBigNumber(t,e){if(e.isNaN())return t._pushNaN();if(!e.isFinite())return t._pushInfinity(e.isNegative()?-1/0:1/0);if(e.isInteger())return t._pushBigint(e);if(!t._pushTag(h.DECIMAL_FRAC)||!t._pushInt(2,a.ARRAY))return!1;const r=e.decimalPlaces(),n=e.shiftedBy(r);return!!t._pushIntNum(-r)&&(n.abs().isLessThan(s.BN.MAXINT)?t._pushIntNum(n.toNumber()):t._pushBigint(n))}_pushMap(t,e,r){r={indefinite:!1,...r};let n=[...e.entries()];if(t.omitUndefinedProperties&&(n=n.filter((([t,e])=>void 0!==e))),r.indefinite){if(!t._pushUInt8(a.MAP<<5|u.INDEFINITE))return!1}else if(!t._pushInt(n.length,a.MAP))return!1;if(t.canonical){const e=new B({genTypes:t.semanticTypes,canonical:t.canonical,detectLoops:!!t.detectLoops,dateType:t.dateType,disallowUndefinedKeys:t.disallowUndefinedKeys,collapseBigIntegers:t.collapseBigIntegers}),r=new i({highWaterMark:t.readableHighWaterMark});e.pipe(r),n.sort((([t],[n])=>{e.pushAny(t);const i=r.read();e.pushAny(n);const o=r.read();return i.compare(o)}));for(const[e,r]of n){if(t.disallowUndefinedKeys&&void 0===e)throw new Error(\"Invalid Map key: undefined\");if(!t.pushAny(e)||!t.pushAny(r))return!1}}else for(const[e,r]of n){if(t.disallowUndefinedKeys&&void 0===e)throw new Error(\"Invalid Map key: undefined\");if(!t.pushAny(e)||!t.pushAny(r))return!1}return!(r.indefinite&&!t.push(v))}_pushTypedArray(t,e){let r=64,n=e.BYTES_PER_ELEMENT;const{name:i}=e.constructor;return i.startsWith(\"Float\")?(r|=16,n/=2):i.includes(\"U\")||(r|=8),(i.includes(\"Clamped\")||1!==n&&!o.isBigEndian())&&(r|=4),r|={1:0,2:1,4:2,8:3}[n],!!t._pushTag(r)&&t._pushBuffer(t,d.from(e.buffer,e.byteOffset,e.byteLength))}_pushArrayBuffer(t,e){return t._pushBuffer(t,d.from(e))}removeLoopDetectors(){return!!this.detectLoops&&(this.detectLoops=new WeakSet,!0)}_pushObject(t,e){if(!t)return this._pushNull(t);if(!(e={indefinite:!1,skipTypes:!1,...e}).indefinite&&this.detectLoops){if(this.detectLoops.has(t))throw new Error(\"Loop detected while CBOR encoding.\\nCall removeLoopDetectors before resuming.\");this.detectLoops.add(t)}if(!e.skipTypes){const e=t.encodeCBOR;if(\"function\"==typeof e)return e.call(t,this);const r=this.semanticTypes[t.constructor.name];if(r)return r.call(t,this,t)}const r=Object.keys(t).filter((e=>{const r=typeof t[e];return\"function\"!==r&&(!this.omitUndefinedProperties||\"undefined\"!==r)})),n={};if(this.canonical&&r.sort(((t,e)=>{const r=n[t]||(n[t]=B.encode(t)),i=n[e]||(n[e]=B.encode(e));return r.compare(i)})),e.indefinite){if(!this._pushUInt8(a.MAP<<5|u.INDEFINITE))return!1}else if(!this._pushInt(r.length,a.MAP))return!1;let i=null;for(let e=0,o=r.length;e<o;e++){const o=r[e];if(this.canonical&&(i=n[o])){if(!this.push(i))return!1}else if(!this._pushString(o))return!1;if(!this.pushAny(t[o]))return!1}if(e.indefinite){if(!this.push(v))return!1}else this.detectLoops&&this.detectLoops.delete(t);return!0}pushAny(t){switch(typeof t){case\"number\":return this._pushNumber(t);case\"bigint\":return this._pushJSBigint(t);case\"string\":return this._pushString(t);case\"boolean\":return this._pushBoolean(t);case\"undefined\":return this._pushUndefined(t);case\"object\":return this._pushObject(t);case\"symbol\":switch(t){case f.NULL:return this._pushNull(null);case f.UNDEFINED:return this._pushUndefined(void 0);default:throw new Error(\"Unknown symbol: \"+t.toString())}default:throw new Error(\"Unknown type: \"+typeof t+\", \"+(t.toString?t.toString():\"\"))}}_pushAny(t){return this.pushAny(t)}_encodeAll(t){const e=new i({highWaterMark:this.readableHighWaterMark});this.pipe(e);for(const e of t)this.pushAny(e);return this.end(),e.read()}static encodeIndefinite(t,e,r={}){if(null==e){if(null==this)throw new Error(\"No object to encode\");e=this}const{chunkSize:n=4096}=r;let i=!0;const s=typeof e;let l=null;if(\"string\"===s){i=i&&t._pushUInt8(a.UTF8_STRING<<5|u.INDEFINITE);let r=0;for(;r<e.length;){const o=r+n;i=i&&t._pushString(e.slice(r,o)),r=o}i=i&&t.push(v)}else if(l=o.bufferishToBuffer(e)){i=i&&t._pushUInt8(a.BYTE_STRING<<5|u.INDEFINITE);let e=0;for(;e<l.length;){const r=e+n;i=i&&t._pushBuffer(t,l.slice(e,r)),e=r}i=i&&t.push(v)}else if(Array.isArray(e))i=i&&t._pushArray(t,e,{indefinite:!0});else if(e instanceof Map)i=i&&t._pushMap(t,e,{indefinite:!0});else{if(\"object\"!==s)throw new Error(\"Invalid indefinite encoding\");i=i&&t._pushObject(e,{indefinite:!0,skipTypes:!0})}return i}static encode(...t){return(new B)._encodeAll(t)}static encodeCanonical(...t){return new B({canonical:!0})._encodeAll(t)}static encodeOne(t,e){return new B(e)._encodeAll([t])}static encodeAsync(t,e){return new Promise(((r,n)=>{const i=[],o=new B(e);o.on(\"data\",(t=>i.push(t))),o.on(\"error\",n),o.on(\"finish\",(()=>r(d.concat(i)))),o.pushAny(t),o.end()}))}}t.exports=B},70:(t,e,r)=>{\"use strict\";const{Buffer:n}=r(764),i=r(666),o=r(774),{MT:s}=r(66);class a extends Map{constructor(t){super(t)}static _encode(t){return i.encodeCanonical(t).toString(\"base64\")}static _decode(t){return o.decodeFirstSync(t,\"base64\")}get(t){return super.get(a._encode(t))}set(t,e){return super.set(a._encode(t),e)}delete(t){return super.delete(a._encode(t))}has(t){return super.has(a._encode(t))}*keys(){for(const t of super.keys())yield a._decode(t)}*entries(){for(const t of super.entries())yield[a._decode(t[0]),t[1]]}[Symbol.iterator](){return this.entries()}forEach(t,e){if(\"function\"!=typeof t)throw new TypeError(\"Must be function\");for(const e of super.entries())t.call(this,e[1],a._decode(e[0]),this)}encodeCBOR(t){if(!t._pushInt(this.size,s.MAP))return!1;if(t.canonical){const e=Array.from(super.entries()).map((t=>[n.from(t[0],\"base64\"),t[1]]));e.sort(((t,e)=>t[0].compare(e[0])));for(const r of e)if(!t.push(r[0])||!t.pushAny(r[1]))return!1}else for(const e of super.entries())if(!t.push(n.from(e[0],\"base64\"))||!t.pushAny(e[1]))return!1;return!0}}t.exports=a},32:(t,e,r)=>{\"use strict\";const{MT:n,SIMPLE:i,SYMS:o}=r(66);class s{constructor(t){if(\"number\"!=typeof t)throw new Error(\"Invalid Simple type: \"+typeof t);if(t<0||t>255||(0|t)!==t)throw new Error(\"value must be a small positive integer: \"+t);this.value=t}toString(){return\"simple(\"+this.value+\")\"}inspect(t,e){return\"simple(\"+this.value+\")\"}encodeCBOR(t){return t._pushInt(this.value,n.SIMPLE_FLOAT)}static isSimple(t){return t instanceof s}static decode(t,e=!0,r=!1){switch(t){case i.FALSE:return!1;case i.TRUE:return!0;case i.NULL:return e?null:o.NULL;case i.UNDEFINED:if(e)return;return o.UNDEFINED;case-1:if(!e||!r)throw new Error(\"Invalid BREAK\");return o.BREAK;default:return new s(t)}}}t.exports=s},785:(t,e,r)=>{\"use strict\";const n=r(66),i=r(873);function o(t,e){if(i.isBufferish(t))t.toJSON=e;else if(Array.isArray(t))for(const r of t)o(r,e);else if(t&&\"object\"==typeof t&&(!(t instanceof u)||t.tag<21||t.tag>23))for(const r of Object.values(t))o(r,e)}const s={64:Uint8Array,65:Uint16Array,66:Uint32Array,67:BigUint64Array,68:Uint8ClampedArray,69:Uint16Array,70:Uint32Array,71:BigUint64Array,72:Int8Array,73:Int16Array,74:Int32Array,75:BigInt64Array,77:Int16Array,78:Int32Array,79:BigInt64Array,81:Float32Array,82:Float64Array,85:Float32Array,86:Float64Array},a=Symbol(\"INTERNAL_JSON\");class u{constructor(t,e,r){if(this.tag=t,this.value=e,this.err=r,\"number\"!=typeof this.tag)throw new Error(\"Invalid tag type (\"+typeof this.tag+\")\");if(this.tag<0||(0|this.tag)!==this.tag)throw new Error(\"Tag must be a positive integer: \"+this.tag)}toJSON(){if(this[a])return this[a]();const t={tag:this.tag,value:this.value};return this.err&&(t.err=this.err),t}toString(){return`${this.tag}(${JSON.stringify(this.value)})`}encodeCBOR(t){return t._pushTag(this.tag),t.pushAny(this.value)}convert(t){let e=null!=t?t[this.tag]:void 0;if(\"function\"!=typeof e&&(e=u[\"_tag_\"+this.tag],\"function\"!=typeof e)){if(e=s[this.tag],\"function\"!=typeof e)return this;e=this._toTypedArray}try{return e.call(this,this.value)}catch(t){return t&&t.message&&t.message.length>0?this.err=t.message:this.err=t,this}}_toTypedArray(t){const{tag:e}=this,r=s[e];if(!r)throw new Error(`Invalid typed array tag: ${e}`);const n=2**(((16&e)>>4)+(3&e));return!(4&e)!==i.isBigEndian()&&n>1&&function(t,e,r,n){const i=new DataView(t),[o,s]={2:[i.getUint16,i.setUint16],4:[i.getUint32,i.setUint32],8:[i.getBigUint64,i.setBigUint64]}[e],a=r+n;for(let t=r;t<a;t+=e)s.call(i,t,o.call(i,t,!0))}(t.buffer,n,t.byteOffset,t.byteLength),new r(t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength))}static _tag_0(t){return new Date(t)}static _tag_1(t){return new Date(1e3*t)}static _tag_2(t){return i.bufferToBignumber(t)}static _tag_3(t){const e=i.bufferToBignumber(t);return n.BN.MINUS_ONE.minus(e)}static _tag_4(t){if(!n.BigNumber)throw new Error(\"No bignumber.js\");return new n.BigNumber(t[1]).shiftedBy(t[0])}static _tag_5(t){if(!n.BigNumber)throw new Error(\"No bignumber.js\");return n.BN.TWO.pow(t[0]).times(t[1])}static _tag_21(t){return i.isBufferish(t)?this[a]=()=>i.base64url(t):o(t,(function(){return i.base64url(this)})),this}static _tag_22(t){return i.isBufferish(t)?this[a]=()=>i.base64(t):o(t,(function(){return i.base64(this)})),this}static _tag_23(t){return i.isBufferish(t)?this[a]=()=>t.toString(\"hex\"):o(t,(function(){return this.toString(\"hex\")})),this}static _tag_32(t){return new URL(t)}static _tag_33(t){if(!t.match(/^[a-zA-Z0-9_-]+$/))throw new Error(\"Invalid base64url characters\");const e=t.length%4;if(1===e)throw new Error(\"Invalid base64url length\");if(2===e){if(-1===\"AQgw\".indexOf(t[t.length-1]))throw new Error(\"Invalid base64 padding\")}else if(3===e&&-1===\"AEIMQUYcgkosw048\".indexOf(t[t.length-1]))throw new Error(\"Invalid base64 padding\");return this}static _tag_34(t){const e=t.match(/^[a-zA-Z0-9+/]+(={0,2})$/);if(!e)throw new Error(\"Invalid base64url characters\");if(t.length%4!=0)throw new Error(\"Invalid base64url length\");if(\"=\"===e[1]){if(-1===\"AQgw\".indexOf(t[t.length-2]))throw new Error(\"Invalid base64 padding\")}else if(\"==\"===e[1]&&-1===\"AEIMQUYcgkosw048\".indexOf(t[t.length-3]))throw new Error(\"Invalid base64 padding\");return this}static _tag_35(t){return new RegExp(t)}static _tag_258(t){return new Set(t)}}u.INTERNAL_JSON=a,t.exports=u},873:(t,e,r)=>{\"use strict\";const{Buffer:n}=r(764),i=r(202),o=r(830),s=r(960),a=r(66),{NUMBYTES:u,SHIFT32:l,BI:c,SYMS:f}=a;let h=null;try{h=r(669)}catch(t){h=r(595)}e.inspect=h.inspect;const p=new s(\"utf8\",{fatal:!0,ignoreBOM:!0});e.utf8=t=>p.decode(t),e.utf8.checksUTF8=!0,e.isBufferish=function(t){return t&&\"object\"==typeof t&&(n.isBuffer(t)||t instanceof Uint8Array||t instanceof Uint8ClampedArray||t instanceof ArrayBuffer||t instanceof DataView)},e.bufferishToBuffer=function(t){return n.isBuffer(t)?t:ArrayBuffer.isView(t)?n.from(t.buffer,t.byteOffset,t.byteLength):t instanceof ArrayBuffer?n.from(t):null},e.parseCBORint=function(t,e,r=!0){switch(t){case u.ONE:return e.readUInt8(0);case u.TWO:return e.readUInt16BE(0);case u.FOUR:return e.readUInt32BE(0);case u.EIGHT:{const t=e.readUInt32BE(0),n=e.readUInt32BE(4);if(t>2097151){if(r)return BigInt(t)*c.SHIFT32+BigInt(n);if(!a.BigNumber)throw new Error(\"No bigint and no bignumber.js\");return new a.BigNumber(t).times(l).plus(n)}return t*l+n}default:throw new Error(\"Invalid additional info for int: \"+t)}},e.writeHalf=function(t,e){const r=n.allocUnsafe(4);r.writeFloatBE(e,0);const i=r.readUInt32BE(0);if(0!=(8191&i))return!1;let o=i>>16&32768;const s=i>>23&255,a=8388607&i;if(s>=113&&s<=142)o+=(s-112<<10)+(a>>13);else{if(!(s>=103&&s<113))return!1;if(a&(1<<126-s)-1)return!1;o+=a+8388608>>126-s}return t.writeUInt16BE(o),!0},e.parseHalf=function(t){const e=128&t[0]?-1:1,r=(124&t[0])>>2,n=(3&t[0])<<8|t[1];return r?31===r?e*(n?NaN:Infinity):e*Math.pow(2,r-25)*(1024+n):5.960464477539063e-8*e*n},e.parseCBORfloat=function(t){switch(t.length){case 2:return e.parseHalf(t);case 4:return t.readFloatBE(0);case 8:return t.readDoubleBE(0);default:throw new Error(\"Invalid float size: \"+t.length)}},e.hex=function(t){return n.from(t.replace(/^0x/,\"\"),\"hex\")},e.bin=function(t){let e=0,r=(t=t.replace(/\\s/g,\"\")).length%8||8;const i=[];for(;r<=t.length;)i.push(parseInt(t.slice(e,r),2)),e=r,r+=8;return n.from(i)},e.arrayEqual=function(t,e){return null==t&&null==e||null!=t&&null!=e&&t.length===e.length&&t.every(((t,r)=>t===e[r]))},e.bufferToBignumber=function(t){if(!a.BigNumber)throw new Error(\"No bigint and no bignumber.js\");return new a.BigNumber(t.toString(\"hex\"),16)},e.bufferToBigInt=function(t){return BigInt(\"0x\"+t.toString(\"hex\"))},e.cborValueToString=function(t,r=-1){switch(typeof t){case\"symbol\":{switch(t){case f.NULL:return\"null\";case f.UNDEFINED:return\"undefined\";case f.BREAK:return\"BREAK\"}if(t.description)return t.description;const e=t.toString().match(/^Symbol\\((.*)\\)/);return e&&e[1]?e[1]:\"Symbol\"}case\"string\":return JSON.stringify(t);case\"bigint\":return t.toString();case\"number\":return r>0?h.inspect(t)+\"_\"+r:h.inspect(t)}const n=e.bufferishToBuffer(t);if(n){const t=n.toString(\"hex\");return r===-1/0?t:`h'${t}'`}return a.BigNumber&&a.BigNumber.isBigNumber(t)?t.toString():t&&\"function\"==typeof t.inspect?t.inspect():h.inspect(t)},e.guessEncoding=function(t,r){if(\"string\"==typeof t)return new i(t,null!=r?r:\"hex\");const n=e.bufferishToBuffer(t);if(n)return new i(n);if((s=t)instanceof o.Readable||[\"read\",\"on\",\"pipe\"].every((t=>\"function\"==typeof s[t])))return t;var s;throw new Error(\"Unknown input type\")};const d={\"=\":\"\",\"+\":\"-\",\"/\":\"_\"};e.base64url=function(t){return e.bufferishToBuffer(t).toString(\"base64\").replace(/[=+/]/g,(t=>d[t]))},e.base64=function(t){return e.bufferishToBuffer(t).toString(\"base64\")},e.isBigEndian=function(){const t=new Uint8Array(4);return!((new Uint32Array(t.buffer)[0]=1)&t[0])}},960:(t,e,r)=>{\"use strict\";let n=null;if(\"function\"==typeof TextDecoder)n=TextDecoder;else if(\"undefined\"!=typeof window)n=window.TextDecoder;else if(\"undefined\"!=typeof self)n=self.TextDecoder;else try{const t=r(669);\"function\"!=typeof n&&(n=t.TextDecoder)}catch(t){}if(\"function\"!=typeof n){class t{constructor(t,e){this.utfLabel=t,this.options=e}decode(t){const e=t.toString(this.utfLabel);if(this.options.fatal)for(const t of e)if(65533===t.codePointAt(0)){const t=new TypeError(\"[ERR_ENCODING_INVALID_ENCODED_DATA]: The encoded data was not valid for encoding \"+this.utfLabel);throw t.code=\"ERR_ENCODING_INVALID_ENCODED_DATA\",t.errno=12,t}return e}}n=t}t.exports=n},202:(t,e,r)=>{\"use strict\";const n=r(830),{Buffer:i}=r(764),o=r(960);let s=null,a=Symbol.for(\"nodejs.util.inspect.custom\");try{s=r(669),a=s.inspect.custom}catch(t){}const u=new o(\"utf8\",{fatal:!0,ignoreBOM:!0});class l extends n.Transform{constructor(t,e,r){null==r&&(r={});let n=null,o=null;switch(typeof t){case\"object\":i.isBuffer(t)?(n=t,null!=e&&\"object\"==typeof e&&(r=e)):r=t;break;case\"string\":n=t,null!=e&&\"object\"==typeof e?r=e:o=e}null==r&&(r={}),null==n&&(n=r.input),null==o&&(o=r.inputEncoding),delete r.input,delete r.inputEncoding;const s=null==r.watchPipe||r.watchPipe;delete r.watchPipe;const a=!!r.readError;delete r.readError,super(r),this.readError=a,s&&this.on(\"pipe\",(t=>{const e=t._readableState.objectMode;if(this.length>0&&e!==this._readableState.objectMode)throw new Error(\"Do not switch objectMode in the middle of the stream\");this._readableState.objectMode=e,this._writableState.objectMode=e})),null!=n&&this.end(n,o)}static isNoFilter(t){return t instanceof this}static compare(t,e){if(!(t instanceof this))throw new TypeError(\"Arguments must be NoFilters\");return t===e?0:t.compare(e)}static concat(t,e){if(!Array.isArray(t))throw new TypeError(\"list argument must be an Array of NoFilters\");if(0===t.length||0===e)return i.alloc(0);null==e&&(e=t.reduce(((t,e)=>{if(!(e instanceof l))throw new TypeError(\"list argument must be an Array of NoFilters\");return t+e.length}),0));let r=!0,n=!0;const o=t.map((t=>{if(!(t instanceof l))throw new TypeError(\"list argument must be an Array of NoFilters\");const e=t.slice();return i.isBuffer(e)?n=!1:r=!1,e}));if(r)return i.concat(o,e);if(n)return[].concat(...o).slice(0,e);throw new Error(\"Concatenating mixed object and byte streams not supported\")}_transform(t,e,r){this._readableState.objectMode||i.isBuffer(t)||(t=i.from(t,e)),this.push(t),r()}_bufArray(){let t=this._readableState.buffer;if(!Array.isArray(t)){let e=t.head;for(t=[];null!=e;)t.push(e.data),e=e.next}return t}read(t){const e=super.read(t);if(null!=e){if(this.emit(\"read\",e),this.readError&&e.length<t)throw new Error(`Read ${e.length}, wanted ${t}`)}else if(this.readError)throw new Error(`No data available, wanted ${t}`);return e}promise(t){let e=!1;return new Promise(((r,n)=>{this.on(\"finish\",(()=>{const n=this.read();null==t||e||(e=!0,t(null,n)),r(n)})),this.on(\"error\",(r=>{null==t||e||(e=!0,t(r)),n(r)}))}))}compare(t){if(!(t instanceof l))throw new TypeError(\"Arguments must be NoFilters\");if(this===t)return 0;const e=this.slice(),r=t.slice();if(i.isBuffer(e)&&i.isBuffer(r))return e.compare(r);throw new Error(\"Cannot compare streams in object mode\")}equals(t){return 0===this.compare(t)}slice(t,e){if(this._readableState.objectMode)return this._bufArray().slice(t,e);const r=this._bufArray();switch(r.length){case 0:return i.alloc(0);case 1:return r[0].slice(t,e);default:return i.concat(r).slice(t,e)}}get(t){return this.slice()[t]}toJSON(){const t=this.slice();return i.isBuffer(t)?t.toJSON():t}toString(t,e,r){const n=this.slice(e,r);return i.isBuffer(n)?t&&\"utf8\"!==t?n.toString(t,e,r):u.decode(n):JSON.stringify(n)}inspect(t,e){return this[a](t,e)}[a](t,e){const r=this._bufArray().map((t=>i.isBuffer(t)?(null!=e?e.stylize:void 0)?e.stylize(t.toString(\"hex\"),\"string\"):t.toString(\"hex\"):s?s.inspect(t,e):t.toString())).join(\", \");return`${this.constructor.name} [${r}]`}get length(){return this._readableState.length}writeBigInt(t){let e=t.toString(16);if(t<0){const r=BigInt(Math.floor(e.length/2));e=(t=(BigInt(1)<<r*BigInt(8))+t).toString(16)}return e.length%2&&(e=\"0\"+e),this.push(i.from(e,\"hex\"))}readUBigInt(t){const e=this.read(t);return i.isBuffer(e)?BigInt(\"0x\"+e.toString(\"hex\")):null}readBigInt(t){const e=this.read(t);if(!i.isBuffer(e))return null;let r=BigInt(\"0x\"+e.toString(\"hex\"));return 128&e[0]&&(r-=BigInt(1)<<BigInt(e.length)*BigInt(8)),r}}function c(t,e){return function(r){const n=this.read(e);return i.isBuffer(n)?n[t].call(n,0,!0):null}}function f(t,e){return function(r){const n=i.alloc(e);return n[t].call(n,r,0,!0),this.push(n)}}Object.assign(l.prototype,{writeUInt8:f(\"writeUInt8\",1),writeUInt16LE:f(\"writeUInt16LE\",2),writeUInt16BE:f(\"writeUInt16BE\",2),writeUInt32LE:f(\"writeUInt32LE\",4),writeUInt32BE:f(\"writeUInt32BE\",4),writeInt8:f(\"writeInt8\",1),writeInt16LE:f(\"writeInt16LE\",2),writeInt16BE:f(\"writeInt16BE\",2),writeInt32LE:f(\"writeInt32LE\",4),writeInt32BE:f(\"writeInt32BE\",4),writeFloatLE:f(\"writeFloatLE\",4),writeFloatBE:f(\"writeFloatBE\",4),writeDoubleLE:f(\"writeDoubleLE\",8),writeDoubleBE:f(\"writeDoubleBE\",8),readUInt8:c(\"readUInt8\",1),readUInt16LE:c(\"readUInt16LE\",2),readUInt16BE:c(\"readUInt16BE\",2),readUInt32LE:c(\"readUInt32LE\",4),readUInt32BE:c(\"readUInt32BE\",4),readInt8:c(\"readInt8\",1),readInt16LE:c(\"readInt16LE\",2),readInt16BE:c(\"readInt16BE\",2),readInt32LE:c(\"readInt32LE\",4),readInt32BE:c(\"readInt32BE\",4),readFloatLE:c(\"readFloatLE\",4),readFloatBE:c(\"readFloatBE\",4),readDoubleLE:c(\"readDoubleLE\",8),readDoubleBE:c(\"readDoubleBE\",8)}),t.exports=l},71:(t,e,r)=>{\"use strict\";const n=r(830),i=r(202),o=n.Transform;t.exports=class extends o{constructor(t){super(t),this._writableState.objectMode=!1,this._readableState.objectMode=!0,this.bs=new i,this.__restart()}_transform(t,e,r){for(this.bs.write(t);this.bs.length>=this.__needed;){let t=null;const e=null===this.__needed?void 0:this.bs.read(this.__needed);try{t=this.__parser.next(e)}catch(t){return r(t)}this.__needed&&(this.__fresh=!1),t.done?(this.push(t.value),this.__restart()):this.__needed=t.value||1/0}return r()}*_parse(){throw new Error(\"Must be implemented in subclass\")}__restart(){this.__needed=null,this.__parser=this._parse(),this.__fresh=!0}_flush(t){t(this.__fresh?null:new Error(\"unexpected end of input\"))}}},187:t=>{\"use strict\";var e,r=\"object\"==typeof Reflect?Reflect:null,n=r&&\"function\"==typeof r.apply?r.apply:function(t,e,r){return Function.prototype.apply.call(t,e,r)};e=r&&\"function\"==typeof r.ownKeys?r.ownKeys:Object.getOwnPropertySymbols?function(t){return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t))}:function(t){return Object.getOwnPropertyNames(t)};var i=Number.isNaN||function(t){return t!=t};function o(){o.init.call(this)}t.exports=o,t.exports.once=function(t,e){return new Promise((function(r,n){function i(){void 0!==o&&t.removeListener(\"error\",o),r([].slice.call(arguments))}var o;\"error\"!==e&&(o=function(r){t.removeListener(e,i),n(r)},t.once(\"error\",o)),t.once(e,i)}))},o.EventEmitter=o,o.prototype._events=void 0,o.prototype._eventsCount=0,o.prototype._maxListeners=void 0;var s=10;function a(t){if(\"function\"!=typeof t)throw new TypeError('The \"listener\" argument must be of type Function. Received type '+typeof t)}function u(t){return void 0===t._maxListeners?o.defaultMaxListeners:t._maxListeners}function l(t,e,r,n){var i,o,s,l;if(a(r),void 0===(o=t._events)?(o=t._events=Object.create(null),t._eventsCount=0):(void 0!==o.newListener&&(t.emit(\"newListener\",e,r.listener?r.listener:r),o=t._events),s=o[e]),void 0===s)s=o[e]=r,++t._eventsCount;else if(\"function\"==typeof s?s=o[e]=n?[r,s]:[s,r]:n?s.unshift(r):s.push(r),(i=u(t))>0&&s.length>i&&!s.warned){s.warned=!0;var c=new Error(\"Possible EventEmitter memory leak detected. \"+s.length+\" \"+String(e)+\" listeners added. Use emitter.setMaxListeners() to increase limit\");c.name=\"MaxListenersExceededWarning\",c.emitter=t,c.type=e,c.count=s.length,l=c,console&&console.warn&&console.warn(l)}return t}function c(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function f(t,e,r){var n={fired:!1,wrapFn:void 0,target:t,type:e,listener:r},i=c.bind(n);return i.listener=r,n.wrapFn=i,i}function h(t,e,r){var n=t._events;if(void 0===n)return[];var i=n[e];return void 0===i?[]:\"function\"==typeof i?r?[i.listener||i]:[i]:r?function(t){for(var e=new Array(t.length),r=0;r<e.length;++r)e[r]=t[r].listener||t[r];return e}(i):d(i,i.length)}function p(t){var e=this._events;if(void 0!==e){var r=e[t];if(\"function\"==typeof r)return 1;if(void 0!==r)return r.length}return 0}function d(t,e){for(var r=new Array(e),n=0;n<e;++n)r[n]=t[n];return r}Object.defineProperty(o,\"defaultMaxListeners\",{enumerable:!0,get:function(){return s},set:function(t){if(\"number\"!=typeof t||t<0||i(t))throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received '+t+\".\");s=t}}),o.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},o.prototype.setMaxListeners=function(t){if(\"number\"!=typeof t||t<0||i(t))throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received '+t+\".\");return this._maxListeners=t,this},o.prototype.getMaxListeners=function(){return u(this)},o.prototype.emit=function(t){for(var e=[],r=1;r<arguments.length;r++)e.push(arguments[r]);var i=\"error\"===t,o=this._events;if(void 0!==o)i=i&&void 0===o.error;else if(!i)return!1;if(i){var s;if(e.length>0&&(s=e[0]),s instanceof Error)throw s;var a=new Error(\"Unhandled error.\"+(s?\" (\"+s.message+\")\":\"\"));throw a.context=s,a}var u=o[t];if(void 0===u)return!1;if(\"function\"==typeof u)n(u,this,e);else{var l=u.length,c=d(u,l);for(r=0;r<l;++r)n(c[r],this,e)}return!0},o.prototype.addListener=function(t,e){return l(this,t,e,!1)},o.prototype.on=o.prototype.addListener,o.prototype.prependListener=function(t,e){return l(this,t,e,!0)},o.prototype.once=function(t,e){return a(e),this.on(t,f(this,t,e)),this},o.prototype.prependOnceListener=function(t,e){return a(e),this.prependListener(t,f(this,t,e)),this},o.prototype.removeListener=function(t,e){var r,n,i,o,s;if(a(e),void 0===(n=this._events))return this;if(void 0===(r=n[t]))return this;if(r===e||r.listener===e)0==--this._eventsCount?this._events=Object.create(null):(delete n[t],n.removeListener&&this.emit(\"removeListener\",t,r.listener||e));else if(\"function\"!=typeof r){for(i=-1,o=r.length-1;o>=0;o--)if(r[o]===e||r[o].listener===e){s=r[o].listener,i=o;break}if(i<0)return this;0===i?r.shift():function(t,e){for(;e+1<t.length;e++)t[e]=t[e+1];t.pop()}(r,i),1===r.length&&(n[t]=r[0]),void 0!==n.removeListener&&this.emit(\"removeListener\",t,s||e)}return this},o.prototype.off=o.prototype.removeListener,o.prototype.removeAllListeners=function(t){var e,r,n;if(void 0===(r=this._events))return this;if(void 0===r.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==r[t]&&(0==--this._eventsCount?this._events=Object.create(null):delete r[t]),this;if(0===arguments.length){var i,o=Object.keys(r);for(n=0;n<o.length;++n)\"removeListener\"!==(i=o[n])&&this.removeAllListeners(i);return this.removeAllListeners(\"removeListener\"),this._events=Object.create(null),this._eventsCount=0,this}if(\"function\"==typeof(e=r[t]))this.removeListener(t,e);else if(void 0!==e)for(n=e.length-1;n>=0;n--)this.removeListener(t,e[n]);return this},o.prototype.listeners=function(t){return h(this,t,!0)},o.prototype.rawListeners=function(t){return h(this,t,!1)},o.listenerCount=function(t,e){return\"function\"==typeof t.listenerCount?t.listenerCount(e):p.call(t,e)},o.prototype.listenerCount=p,o.prototype.eventNames=function(){return this._eventsCount>0?e(this._events):[]}},645:(t,e)=>{e.read=function(t,e,r,n,i){var o,s,a=8*i-n-1,u=(1<<a)-1,l=u>>1,c=-7,f=r?i-1:0,h=r?-1:1,p=t[e+f];for(f+=h,o=p&(1<<-c)-1,p>>=-c,c+=a;c>0;o=256*o+t[e+f],f+=h,c-=8);for(s=o&(1<<-c)-1,o>>=-c,c+=n;c>0;s=256*s+t[e+f],f+=h,c-=8);if(0===o)o=1-l;else{if(o===u)return s?NaN:1/0*(p?-1:1);s+=Math.pow(2,n),o-=l}return(p?-1:1)*s*Math.pow(2,o-n)},e.write=function(t,e,r,n,i,o){var s,a,u,l=8*o-i-1,c=(1<<l)-1,f=c>>1,h=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,p=n?0:o-1,d=n?1:-1,y=e<0||0===e&&1/e<0?1:0;for(e=Math.abs(e),isNaN(e)||e===1/0?(a=isNaN(e)?1:0,s=c):(s=Math.floor(Math.log(e)/Math.LN2),e*(u=Math.pow(2,-s))<1&&(s--,u*=2),(e+=s+f>=1?h/u:h*Math.pow(2,1-f))*u>=2&&(s++,u/=2),s+f>=c?(a=0,s=c):s+f>=1?(a=(e*u-1)*Math.pow(2,i),s+=f):(a=e*Math.pow(2,f-1)*Math.pow(2,i),s=0));i>=8;t[r+p]=255&a,p+=d,a/=256,i-=8);for(s=s<<i|a,l+=i;l>0;t[r+p]=255&s,p+=d,s/=256,l-=8);t[r+p-d]|=128*y}},717:t=>{\"function\"==typeof Object.create?t.exports=function(t,e){e&&(t.super_=e,t.prototype=Object.create(e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}))}:t.exports=function(t,e){if(e){t.super_=e;var r=function(){};r.prototype=e.prototype,t.prototype=new r,t.prototype.constructor=t}}},595:function(t){t.exports=(()=>{\"use strict\";var t={255:(t,e)=>{e.l=class{hexSlice(t=0,e){return Array.prototype.map.call(this.slice(t,e),(t=>(\"00\"+t.toString(16)).slice(-2))).join(\"\")}}},48:(t,e,r)=>{const{internalBinding:n,Array:i,ArrayIsArray:o,ArrayPrototypeFilter:s,ArrayPrototypeForEach:a,ArrayPrototypePush:u,ArrayPrototypePushApply:l,ArrayPrototypeSort:c,ArrayPrototypeUnshift:f,BigIntPrototypeValueOf:h,BooleanPrototypeValueOf:p,DatePrototypeGetTime:d,DatePrototypeToISOString:y,DatePrototypeToString:g,ErrorPrototypeToString:b,FunctionPrototypeCall:m,FunctionPrototypeToString:w,JSONStringify:_,MapPrototypeGetSize:E,MapPrototypeEntries:v,MathFloor:S,MathMax:A,MathMin:T,MathRound:I,MathSqrt:B,Number:x,NumberIsNaN:O,NumberParseFloat:R,NumberParseInt:N,NumberPrototypeValueOf:L,Object:P,ObjectAssign:M,ObjectCreate:U,ObjectDefineProperty:j,ObjectGetOwnPropertyDescriptor:k,ObjectGetOwnPropertyNames:$,ObjectGetOwnPropertySymbols:F,ObjectGetPrototypeOf:D,ObjectIs:C,ObjectKeys:G,ObjectPrototypeHasOwnProperty:W,ObjectPrototypePropertyIsEnumerable:z,ObjectSeal:H,ObjectSetPrototypeOf:Y,ReflectOwnKeys:q,RegExp:V,RegExpPrototypeTest:K,RegExpPrototypeToString:X,SafeStringIterator:J,SafeMap:Z,SafeSet:Q,SetPrototypeGetSize:tt,SetPrototypeValues:et,String:rt,StringPrototypeCharCodeAt:nt,StringPrototypeCodePointAt:it,StringPrototypeIncludes:ot,StringPrototypeNormalize:st,StringPrototypePadEnd:at,StringPrototypePadStart:ut,StringPrototypeRepeat:lt,StringPrototypeReplace:ct,StringPrototypeSlice:ft,StringPrototypeSplit:ht,StringPrototypeToLowerCase:pt,StringPrototypeTrim:dt,StringPrototypeValueOf:yt,SymbolPrototypeToString:gt,SymbolPrototypeValueOf:bt,SymbolIterator:mt,SymbolToStringTag:wt,TypedArrayPrototypeGetLength:_t,TypedArrayPrototypeGetSymbolToStringTag:Et,Uint8Array:vt,uncurryThis:St}=r(765),{getOwnNonIndexProperties:At,getPromiseDetails:Tt,getProxyDetails:It,kPending:Bt,kRejected:xt,previewEntries:Ot,getConstructorName:Rt,getExternalValue:Nt,propertyFilter:{ALL_PROPERTIES:Lt,ONLY_ENUMERABLE:Pt},Proxy:Mt}=r(891),{customInspectSymbol:Ut,isError:jt,join:kt,removeColors:$t}=r(335),{codes:{ERR_INVALID_ARG_TYPE:Ft},isStackOverflowError:Dt}=r(101),{isAsyncFunction:Ct,isGeneratorFunction:Gt,isAnyArrayBuffer:Wt,isArrayBuffer:zt,isArgumentsObject:Ht,isBoxedPrimitive:Yt,isDataView:qt,isExternal:Vt,isMap:Kt,isMapIterator:Xt,isModuleNamespaceObject:Jt,isNativeError:Zt,isPromise:Qt,isSet:te,isSetIterator:ee,isWeakMap:re,isWeakSet:ne,isRegExp:ie,isDate:oe,isTypedArray:se,isStringObject:ae,isNumberObject:ue,isBooleanObject:le,isBigIntObject:ce}=r(63),fe=r(183),{NativeModule:he}=r(992),{validateObject:pe}=r(356);let de;const ye=new Q(s($(r.g),(t=>K(/^[A-Z][a-zA-Z0-9]+$/,t)))),ge=t=>void 0===t&&void 0!==t,be=H({showHidden:!1,depth:2,colors:!1,customInspect:!0,showProxy:!1,maxArrayLength:100,maxStringLength:1e4,breakLength:80,compact:3,sorted:!1,getters:!1}),me=/[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]/,we=/[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]/g,_e=/[\\x00-\\x1f\\x5c\\x7f-\\x9f]/,Ee=/[\\x00-\\x1f\\x5c\\x7f-\\x9f]/g,ve=/^[a-zA-Z_][a-zA-Z_0-9]*$/,Se=/^(0|[1-9][0-9]*)$/,Ae=/^    at (?:[^/\\\\(]+ \\(|)node:(.+):\\d+:\\d+\\)?$/,Te=/^    at (?:[^/\\\\(]+ \\(|)((?<![/\\\\]).+)\\.js:\\d+:\\d+\\)?$/,Ie=/[/\\\\]node_modules[/\\\\](.+?)(?=[/\\\\])/g,Be=/^(\\s+[^(]*?)\\s*{/,xe=/(\\/\\/.*?\\n)|(\\/\\*(.|\\n)*?\\*\\/)/g,Oe=[\"\\\\x00\",\"\\\\x01\",\"\\\\x02\",\"\\\\x03\",\"\\\\x04\",\"\\\\x05\",\"\\\\x06\",\"\\\\x07\",\"\\\\b\",\"\\\\t\",\"\\\\n\",\"\\\\x0B\",\"\\\\f\",\"\\\\r\",\"\\\\x0E\",\"\\\\x0F\",\"\\\\x10\",\"\\\\x11\",\"\\\\x12\",\"\\\\x13\",\"\\\\x14\",\"\\\\x15\",\"\\\\x16\",\"\\\\x17\",\"\\\\x18\",\"\\\\x19\",\"\\\\x1A\",\"\\\\x1B\",\"\\\\x1C\",\"\\\\x1D\",\"\\\\x1E\",\"\\\\x1F\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\\\\'\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\\\\\\\\\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\\\\x7F\",\"\\\\x80\",\"\\\\x81\",\"\\\\x82\",\"\\\\x83\",\"\\\\x84\",\"\\\\x85\",\"\\\\x86\",\"\\\\x87\",\"\\\\x88\",\"\\\\x89\",\"\\\\x8A\",\"\\\\x8B\",\"\\\\x8C\",\"\\\\x8D\",\"\\\\x8E\",\"\\\\x8F\",\"\\\\x90\",\"\\\\x91\",\"\\\\x92\",\"\\\\x93\",\"\\\\x94\",\"\\\\x95\",\"\\\\x96\",\"\\\\x97\",\"\\\\x98\",\"\\\\x99\",\"\\\\x9A\",\"\\\\x9B\",\"\\\\x9C\",\"\\\\x9D\",\"\\\\x9E\",\"\\\\x9F\"],Re=new V(\"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)|(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\",\"g\");let Ne;function Le(t,e){const r={budget:{},indentationLvl:0,seen:[],currentDepth:0,stylize:De,showHidden:be.showHidden,depth:be.depth,colors:be.colors,customInspect:be.customInspect,showProxy:be.showProxy,maxArrayLength:be.maxArrayLength,maxStringLength:be.maxStringLength,breakLength:be.breakLength,compact:be.compact,sorted:be.sorted,getters:be.getters};if(arguments.length>1)if(arguments.length>2&&(void 0!==arguments[2]&&(r.depth=arguments[2]),arguments.length>3&&void 0!==arguments[3]&&(r.colors=arguments[3])),\"boolean\"==typeof e)r.showHidden=e;else if(e){const t=G(e);for(let n=0;n<t.length;++n){const i=t[n];W(be,i)||\"stylize\"===i?r[i]=e[i]:void 0===r.userOptions&&(r.userOptions=e)}}return r.colors&&(r.stylize=Fe),null===r.maxArrayLength&&(r.maxArrayLength=1/0),null===r.maxStringLength&&(r.maxStringLength=1/0),Ve(r,t,0)}Le.custom=Ut,j(Le,\"defaultOptions\",{get:()=>be,set:t=>(pe(t,\"options\"),M(be,t))});const Pe=39,Me=49;function Ue(t,e){j(Le.colors,e,{get(){return this[t]},set(e){this[t]=e},configurable:!0,enumerable:!1})}function je(t,e){return-1===e?`\"${t}\"`:-2===e?`\\`${t}\\``:`'${t}'`}Le.colors=M(U(null),{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],blink:[5,25],inverse:[7,27],hidden:[8,28],strikethrough:[9,29],doubleunderline:[21,24],black:[30,Pe],red:[31,Pe],green:[32,Pe],yellow:[33,Pe],blue:[34,Pe],magenta:[35,Pe],cyan:[36,Pe],white:[37,Pe],bgBlack:[40,Me],bgRed:[41,Me],bgGreen:[42,Me],bgYellow:[43,Me],bgBlue:[44,Me],bgMagenta:[45,Me],bgCyan:[46,Me],bgWhite:[47,Me],framed:[51,54],overlined:[53,55],gray:[90,Pe],redBright:[91,Pe],greenBright:[92,Pe],yellowBright:[93,Pe],blueBright:[94,Pe],magentaBright:[95,Pe],cyanBright:[96,Pe],whiteBright:[97,Pe],bgGray:[100,Me],bgRedBright:[101,Me],bgGreenBright:[102,Me],bgYellowBright:[103,Me],bgBlueBright:[104,Me],bgMagentaBright:[105,Me],bgCyanBright:[106,Me],bgWhiteBright:[107,Me]}),Ue(\"gray\",\"grey\"),Ue(\"gray\",\"blackBright\"),Ue(\"bgGray\",\"bgGrey\"),Ue(\"bgGray\",\"bgBlackBright\"),Ue(\"dim\",\"faint\"),Ue(\"strikethrough\",\"crossedout\"),Ue(\"strikethrough\",\"strikeThrough\"),Ue(\"strikethrough\",\"crossedOut\"),Ue(\"hidden\",\"conceal\"),Ue(\"inverse\",\"swapColors\"),Ue(\"inverse\",\"swapcolors\"),Ue(\"doubleunderline\",\"doubleUnderline\"),Le.styles=M(U(null),{special:\"cyan\",number:\"yellow\",bigint:\"yellow\",boolean:\"yellow\",undefined:\"grey\",null:\"bold\",string:\"green\",symbol:\"green\",date:\"magenta\",regexp:\"red\",module:\"underline\"});const ke=t=>Oe[nt(t)];function $e(t){let e=me,r=we,n=39;if(ot(t,\"'\")&&(ot(t,'\"')?ot(t,\"`\")||ot(t,\"${\")||(n=-2):n=-1,39!==n&&(e=_e,r=Ee)),t.length<5e3&&!K(e,t))return je(t,n);if(t.length>100)return je(t=ct(t,r,ke),n);let i=\"\",o=0;const s=t.length;for(let e=0;e<s;e++){const r=nt(t,e);(r===n||92===r||r<32||r>126&&r<160)&&(i+=o===e?Oe[r]:`${ft(t,o,e)}${Oe[r]}`,o=e+1)}return o!==s&&(i+=ft(t,o)),je(i,n)}function Fe(t,e){const r=Le.styles[e];if(void 0!==r){const e=Le.colors[r];if(void 0!==e)return`\u001b[${e[0]}m${t}\u001b[${e[1]}m`}return t}function De(t){return t}function Ce(){return[]}function Ge(t,e){try{return t instanceof e}catch{return!1}}function We(t,e,r,n){let i;const o=t;for(;t||ge(t);){const s=k(t,\"constructor\");if(void 0!==s&&\"function\"==typeof s.value&&\"\"!==s.value.name&&Ge(o,s.value))return void 0===n||i===t&&ye.has(s.value.name)||ze(e,o,i||o,r,n),s.value.name;t=D(t),void 0===i&&(i=t)}if(null===i)return null;const s=Rt(o);if(r>e.depth&&null!==e.depth)return`${s} <Complex prototype>`;const a=We(i,e,r+1,n);return null===a?`${s} <${Le(i,{...e,customInspect:!1,depth:-1})}>`:`${s} <${a}>`}function ze(t,e,r,n,i){let o,s,l=0;do{if(0!==l||e===r){if(null===(r=D(r)))return;const t=k(r,\"constructor\");if(void 0!==t&&\"function\"==typeof t.value&&ye.has(t.value.name))return}0===l?s=new Q:a(o,(t=>s.add(t))),o=q(r);for(const a of o){if(\"constructor\"===a||W(e,a)||0!==l&&s.has(a))continue;const o=k(r,a);if(\"function\"==typeof o.value)continue;const c=pr(t,r,n,a,0,o,e);t.colors?u(i,`\u001b[2m${c}\u001b[22m`):u(i,c)}}while(3!=++l)}function He(t,e,r,n=\"\"){return null===t?\"\"!==e&&r!==e?`[${r}${n}: null prototype] [${e}] `:`[${r}${n}: null prototype] `:\"\"!==e&&t!==e?`${t}${n} [${e}] `:`${t}${n} `}function Ye(t,e){let r;const n=F(t);if(e)r=$(t),0!==n.length&&l(r,n);else{try{r=G(t)}catch(e){fe(Zt(e)&&\"ReferenceError\"===e.name&&Jt(t)),r=$(t)}0!==n.length&&l(r,s(n,(e=>z(t,e))))}return r}function qe(t,e,r){let n=\"\";return null===e&&(n=Rt(t),n===r&&(n=\"Object\")),He(e,r,n)}function Ve(t,e,r,n){if(\"object\"!=typeof e&&\"function\"!=typeof e&&!ge(e))return Ze(t.stylize,e,t);if(null===e)return t.stylize(\"null\",\"null\");const i=e,s=It(e,!!t.showProxy);if(void 0!==s){if(t.showProxy)return function(t,e,r){if(r>t.depth&&null!==t.depth)return t.stylize(\"Proxy [Array]\",\"special\");r+=1,t.indentationLvl+=2;const n=[Ve(t,e[0],r),Ve(t,e[1],r)];return t.indentationLvl-=2,yr(t,n,\"\",[\"Proxy [\",\"]\"],2,r)}(t,s,r);e=s}if(t.customInspect){const n=e[Ut];if(\"function\"==typeof n&&n!==Le&&(!e.constructor||e.constructor.prototype!==e)){const e=null===t.depth?null:t.depth-r,o=m(n,i,e,function(t,e){const r={stylize:t.stylize,showHidden:t.showHidden,depth:t.depth,colors:t.colors,customInspect:t.customInspect,showProxy:t.showProxy,maxArrayLength:t.maxArrayLength,maxStringLength:t.maxStringLength,breakLength:t.breakLength,compact:t.compact,sorted:t.sorted,getters:t.getters,...t.userOptions};if(e){Y(r,null);for(const t of G(r))\"object\"!=typeof r[t]&&\"function\"!=typeof r[t]||null===r[t]||delete r[t];r.stylize=Y(((e,r)=>{let n;try{n=`${t.stylize(e,r)}`}catch{}return\"string\"!=typeof n?e:n}),null)}return r}(t,void 0!==s||!(i instanceof P)));if(o!==i)return\"string\"!=typeof o?Ve(t,o,r):o.replace(/\\n/g,`\\n${\" \".repeat(t.indentationLvl)}`)}}if(t.seen.includes(e)){let r=1;return void 0===t.circular?(t.circular=new Z,t.circular.set(e,r)):(r=t.circular.get(e),void 0===r&&(r=t.circular.size+1,t.circular.set(e,r))),t.stylize(`[Circular *${r}]`,\"special\")}return function(t,e,r,n){let i,s;t.showHidden&&(r<=t.depth||null===t.depth)&&(s=[]);const a=We(e,t,r,s);void 0!==s&&0===s.length&&(s=void 0);let u=e[wt];(\"string\"!=typeof u||\"\"!==u&&(t.showHidden?W:z)(e,wt))&&(u=\"\");let l,c=\"\",m=Ce,_=!0,S=0;const A=t.showHidden?Lt:Pt;let T,I=0;if(e[mt]||null===a)if(_=!1,o(e)){const t=\"Array\"!==a||\"\"!==u?He(a,u,\"Array\",`(${e.length})`):\"\";if(i=At(e,A),l=[`${t}[`,\"]\"],0===e.length&&0===i.length&&void 0===s)return`${l[0]}]`;I=2,m=rr}else if(te(e)){const r=tt(e),n=He(a,u,\"Set\",`(${r})`);if(i=Ye(e,t.showHidden),m=null!==a?ir.bind(null,e):ir.bind(null,et(e)),0===r&&0===i.length&&void 0===s)return`${n}{}`;l=[`${n}{`,\"}\"]}else if(Kt(e)){const r=E(e),n=He(a,u,\"Map\",`(${r})`);if(i=Ye(e,t.showHidden),m=null!==a?or.bind(null,e):or.bind(null,v(e)),0===r&&0===i.length&&void 0===s)return`${n}{}`;l=[`${n}{`,\"}\"]}else if(se(e)){i=At(e,A);let r=e,n=\"\";null===a&&(n=Et(e),r=new n(e));const o=_t(e);if(l=[`${He(a,u,n,`(${o})`)}[`,\"]\"],0===e.length&&0===i.length&&!t.showHidden)return`${l[0]}]`;m=nr.bind(null,r,o),I=2}else Xt(e)?(i=Ye(e,t.showHidden),l=Ke(\"Map\",u),m=fr.bind(null,l)):ee(e)?(i=Ye(e,t.showHidden),l=Ke(\"Set\",u),m=fr.bind(null,l)):_=!0;if(_)if(i=Ye(e,t.showHidden),l=[\"{\",\"}\"],\"Object\"===a){if(Ht(e)?l[0]=\"[Arguments] {\":\"\"!==u&&(l[0]=`${He(a,u,\"Object\")}{`),0===i.length&&void 0===s)return`${l[0]}}`}else if(\"function\"==typeof e){if(c=function(t,e,r){const n=w(t);if(\"class\"===n.slice(0,5)&&n.endsWith(\"}\")){const i=n.slice(5,-1),o=i.indexOf(\"{\");if(-1!==o&&(!i.slice(0,o).includes(\"(\")||Be.test(i.replace(xe))))return function(t,e,r){let n=`class ${W(t,\"name\")&&t.name||\"(anonymous)\"}`;if(\"Function\"!==e&&null!==e&&(n+=` [${e}]`),\"\"!==r&&e!==r&&(n+=` [${r}]`),null!==e){const e=D(t).name;e&&(n+=` extends ${e}`)}else n+=\" extends [null prototype]\";return`[${n}]`}(t,e,r)}let i=\"Function\";Gt(t)&&(i=`Generator${i}`),Ct(t)&&(i=`Async${i}`);let o=`[${i}`;return null===e&&(o+=\" (null prototype)\"),\"\"===t.name?o+=\" (anonymous)\":o+=`: ${t.name}`,o+=\"]\",e!==i&&null!==e&&(o+=` ${e}`),\"\"!==r&&e!==r&&(o+=` [${r}]`),o}(e,a,u),0===i.length&&void 0===s)return t.stylize(c,\"special\")}else if(ie(e)){c=X(null!==a?e:new V(e));const n=He(a,u,\"RegExp\");if(\"RegExp \"!==n&&(c=`${n}${c}`),0===i.length&&void 0===s||r>t.depth&&null!==t.depth)return t.stylize(c,\"regexp\")}else if(oe(e)){c=O(d(e))?g(e):y(e);const r=He(a,u,\"Date\");if(\"Date \"!==r&&(c=`${r}${c}`),0===i.length&&void 0===s)return t.stylize(c,\"date\")}else if(jt(e)){if(c=function(t,e,r,n,i){const o=null!=t.name?rt(t.name):\"Error\";let s=o.length,a=t.stack?rt(t.stack):b(t);if(!n.showHidden&&0!==i.length)for(const e of[\"name\",\"message\",\"stack\"]){const r=i.indexOf(e);-1!==r&&a.includes(t[e])&&i.splice(r,1)}if(null===e||o.endsWith(\"Error\")&&a.startsWith(o)&&(a.length===s||\":\"===a[s]||\"\\n\"===a[s])){let t=\"Error\";if(null===e){const e=a.match(/^([A-Z][a-z_ A-Z0-9[\\]()-]+)(?::|\\n {4}at)/)||a.match(/^([a-z_A-Z0-9-]*Error)$/);t=e&&e[1]||\"\",s=t.length,t=t||\"Error\"}const n=He(e,r,t).slice(0,-1);o!==n&&(a=n.includes(o)?0===s?`${n}: ${a}`:`${n}${a.slice(s)}`:`${n} [${o}]${a.slice(s)}`)}let u=t.message&&a.indexOf(t.message)||-1;-1!==u&&(u+=t.message.length);const l=a.indexOf(\"\\n    at\",u);if(-1===l)a=`[${a}]`;else if(n.colors){let t=a.slice(0,l);const e=a.slice(l+1).split(\"\\n\");for(const r of e){const e=r.match(Ae)||r.match(Te);if(null!==e&&he.exists(e[1]))t+=`\\n${n.stylize(r,\"undefined\")}`;else{let e;t+=\"\\n\";let i=0;for(;e=Ie.exec(r);)t+=r.slice(i,e.index+14),t+=n.stylize(e[1],\"module\"),i=e.index+e[0].length;t+=0===i?r:r.slice(i)}}a=t}if(0!==n.indentationLvl){const t=\" \".repeat(n.indentationLvl);a=a.replace(/\\n/g,`\\n${t}`)}return a}(e,a,u,t,i),0===i.length&&void 0===s)return c}else if(Wt(e)){const r=He(a,u,zt(e)?\"ArrayBuffer\":\"SharedArrayBuffer\");if(void 0===n)m=er;else if(0===i.length&&void 0===s)return r+`{ byteLength: ${Xe(t.stylize,e.byteLength)} }`;l[0]=`${r}{`,f(i,\"byteLength\")}else if(qt(e))l[0]=`${He(a,u,\"DataView\")}{`,f(i,\"byteLength\",\"byteOffset\",\"buffer\");else if(Qt(e))l[0]=`${He(a,u,\"Promise\")}{`,m=hr;else if(ne(e))l[0]=`${He(a,u,\"WeakSet\")}{`,m=t.showHidden?lr:ur;else if(re(e))l[0]=`${He(a,u,\"WeakMap\")}{`,m=t.showHidden?cr:ur;else if(Jt(e))l[0]=`${He(a,u,\"Module\")}{`,m=Qe.bind(null,i);else if(Yt(e)){if(c=function(t,e,r,n,i){let o,s;ue(t)?(o=L,s=\"Number\"):ae(t)?(o=yt,s=\"String\",r.splice(0,t.length)):le(t)?(o=p,s=\"Boolean\"):ce(t)?(o=h,s=\"BigInt\"):(o=bt,s=\"Symbol\");let a=`[${s}`;return s!==n&&(a+=null===n?\" (null prototype)\":` (${n})`),a+=`: ${Ze(De,o(t),e)}]`,\"\"!==i&&i!==n&&(a+=` [${i}]`),0!==r.length||e.stylize===De?a:e.stylize(a,pt(s))}(e,t,i,a,u),0===i.length&&void 0===s)return c}else{if(0===i.length&&void 0===s){if(Vt(e)){const r=Nt(e).toString(16);return t.stylize(`[External: ${r}]`,\"special\")}return`${qe(e,a,u)}{}`}l[0]=`${qe(e,a,u)}{`}if(r>t.depth&&null!==t.depth){let r=qe(e,a,u).slice(0,-1);return null!==a&&(r=`[${r}]`),t.stylize(r,\"special\")}r+=1,t.seen.push(e),t.currentDepth=r;const B=t.indentationLvl;try{for(T=m(t,e,r),S=0;S<i.length;S++)T.push(pr(t,e,r,i[S],I));void 0!==s&&T.push(...s)}catch(r){return function(t,e,r,n){if(Dt(e))return t.seen.pop(),t.indentationLvl=n,t.stylize(`[${r}: Inspection interrupted prematurely. Maximum call stack size exceeded.]`,\"special\");throw e}(t,r,qe(e,a,u).slice(0,-1),B)}if(void 0!==t.circular){const r=t.circular.get(e);if(void 0!==r){const e=t.stylize(`<ref *${r}>`,\"special\");!0!==t.compact?c=\"\"===c?e:`${e} ${c}`:l[0]=`${e} ${l[0]}`}}if(t.seen.pop(),t.sorted){const e=!0===t.sorted?void 0:t.sorted;if(0===I)T=T.sort(e);else if(i.length>1){const t=T.slice(T.length-i.length).sort(e);T.splice(T.length-i.length,i.length,...t)}}const x=yr(t,T,c,l,I,r,e),R=(t.budget[t.indentationLvl]||0)+x.length;return t.budget[t.indentationLvl]=R,R>2**27&&(t.depth=-1),x}(t,e,r,n)}function Ke(t,e){return e!==`${t} Iterator`&&(\"\"!==e&&(e+=\"] [\"),e+=`${t} Iterator`),[`[${e}] {`,\"}\"]}function Xe(t,e){return t(C(e,-0)?\"-0\":`${e}`,\"number\")}function Je(t,e){return t(`${e}n`,\"bigint\")}function Ze(t,e,r){if(\"string\"==typeof e){let n=\"\";if(e.length>r.maxStringLength){const t=e.length-r.maxStringLength;e=e.slice(0,r.maxStringLength),n=`... ${t} more character${t>1?\"s\":\"\"}`}return!0!==r.compact&&e.length>16&&e.length>r.breakLength-r.indentationLvl-4?e.split(/(?<=\\n)/).map((e=>t($e(e),\"string\"))).join(` +\\n${\" \".repeat(r.indentationLvl+2)}`)+n:t($e(e),\"string\")+n}return\"number\"==typeof e?Xe(t,e):\"bigint\"==typeof e?Je(t,e):\"boolean\"==typeof e?t(`${e}`,\"boolean\"):void 0===e?t(\"undefined\",\"undefined\"):t(gt(e),\"symbol\")}function Qe(t,e,r,n){const o=new i(t.length);for(let i=0;i<t.length;i++)try{o[i]=pr(e,r,n,t[i],0)}catch(r){if(!Zt(r)||\"ReferenceError\"!==r.name)throw r;const s={[t[i]]:\"\"};o[i]=pr(e,s,n,t[i],0);const a=o[i].lastIndexOf(\" \");o[i]=o[i].slice(0,a+1)+e.stylize(\"<uninitialized>\",\"special\")}return t.length=0,o}function tr(t,e,r,n,i,o){const s=G(e);let a=o;for(;o<s.length&&i.length<n;o++){const u=s[o],l=+u;if(l>2**32-2)break;if(`${a}`!==u){if(!Se.test(u))break;const e=l-a,r=`<${e} empty item${e>1?\"s\":\"\"}>`;if(i.push(t.stylize(r,\"undefined\")),a=l,i.length===n)break}i.push(pr(t,e,r,u,1)),a++}const u=e.length-a;if(i.length!==n){if(u>0){const e=`<${u} empty item${u>1?\"s\":\"\"}>`;i.push(t.stylize(e,\"undefined\"))}}else u>0&&i.push(`... ${u} more item${u>1?\"s\":\"\"}`);return i}function er(t,e){let n;try{n=new vt(e)}catch{return[t.stylize(\"(detached)\",\"special\")]}void 0===de&&(de=St(r(255).l.prototype.hexSlice));let i=dt(ct(de(n,0,T(t.maxArrayLength,n.length)),/(.{2})/g,\"$1 \"));const o=n.length-t.maxArrayLength;return o>0&&(i+=` ... ${o} more byte${o>1?\"s\":\"\"}`),[`${t.stylize(\"[Uint8Contents]\",\"special\")}: <${i}>`]}function rr(t,e,r){const n=e.length,i=T(A(0,t.maxArrayLength),n),o=n-i,s=[];for(let n=0;n<i;n++){if(!W(e,n))return tr(t,e,r,i,s,n);s.push(pr(t,e,r,n,1))}return o>0&&s.push(`... ${o} more item${o>1?\"s\":\"\"}`),s}function nr(t,e,r,n,o){const s=T(A(0,r.maxArrayLength),e),a=t.length-s,l=new i(s),c=t.length>0&&\"number\"==typeof t[0]?Xe:Je;for(let e=0;e<s;++e)l[e]=c(r.stylize,t[e]);if(a>0&&(l[s]=`... ${a} more item${a>1?\"s\":\"\"}`),r.showHidden){r.indentationLvl+=2;for(const e of[\"BYTES_PER_ELEMENT\",\"length\",\"byteLength\",\"byteOffset\",\"buffer\"]){const n=Ve(r,t[e],o,!0);u(l,`[${e}]: ${n}`)}r.indentationLvl-=2}return l}function ir(t,e,r,n){const i=[];e.indentationLvl+=2;for(const r of t)u(i,Ve(e,r,n));return e.indentationLvl-=2,i}function or(t,e,r,n){const i=[];e.indentationLvl+=2;for(const[r,o]of t)i.push(`${Ve(e,r,n)} => `+Ve(e,o,n));return e.indentationLvl-=2,i}function sr(t,e,r,n){const o=A(t.maxArrayLength,0),s=T(o,r.length),a=new i(s);t.indentationLvl+=2;for(let n=0;n<s;n++)a[n]=Ve(t,r[n],e);t.indentationLvl-=2,0!==n||t.sorted||c(a);const l=r.length-s;return l>0&&u(a,`... ${l} more item${l>1?\"s\":\"\"}`),a}function ar(t,e,r,n){const o=A(t.maxArrayLength,0),s=r.length/2,a=s-o,u=T(o,s);let l=new i(u),c=0;if(t.indentationLvl+=2,0===n){for(;c<u;c++){const n=2*c;l[c]=`${Ve(t,r[n],e)} => ${Ve(t,r[n+1],e)}`}t.sorted||(l=l.sort())}else for(;c<u;c++){const n=2*c,i=[Ve(t,r[n],e),Ve(t,r[n+1],e)];l[c]=yr(t,i,\"\",[\"[\",\"]\"],2,e)}return t.indentationLvl-=2,a>0&&l.push(`... ${a} more item${a>1?\"s\":\"\"}`),l}function ur(t){return[t.stylize(\"<items unknown>\",\"special\")]}function lr(t,e,r){return sr(t,r,Ot(e),0)}function cr(t,e,r){return ar(t,r,Ot(e),0)}function fr(t,e,r,n){const[i,o]=Ot(r,!0);return o?(t[0]=t[0].replace(/ Iterator] {$/,\" Entries] {\"),ar(e,n,i,2)):sr(e,n,i,1)}function hr(t,e,r){let n;const[i,o]=Tt(e);if(i===Bt)n=[t.stylize(\"<pending>\",\"special\")];else{t.indentationLvl+=2;const e=Ve(t,o,r);t.indentationLvl-=2,n=[i===xt?`${t.stylize(\"<rejected>\",\"special\")} ${e}`:e]}return n}function pr(t,e,r,n,i,o,s=e){let a,u,l=\" \";if(void 0!==(o=o||k(e,n)||{value:e[n],enumerable:!0}).value){const e=!0!==t.compact||0!==i?2:3;t.indentationLvl+=e,u=Ve(t,o.value,r),3===e&&t.breakLength<Ne(u,t.colors)&&(l=`\\n${\" \".repeat(t.indentationLvl)}`),t.indentationLvl-=e}else if(void 0!==o.get){const e=void 0!==o.set?\"Getter/Setter\":\"Getter\",n=t.stylize,i=\"special\";if(t.getters&&(!0===t.getters||\"get\"===t.getters&&void 0===o.set||\"set\"===t.getters&&void 0!==o.set))try{const a=m(o.get,s);if(t.indentationLvl+=2,null===a)u=`${n(`[${e}:`,i)} ${n(\"null\",\"null\")}${n(\"]\",i)}`;else if(\"object\"==typeof a)u=`${n(`[${e}]`,i)} ${Ve(t,a,r)}`;else{const r=Ze(n,a,t);u=`${n(`[${e}:`,i)} ${r}${n(\"]\",i)}`}t.indentationLvl-=2}catch(t){const r=`<Inspection threw (${t.message})>`;u=`${n(`[${e}:`,i)} ${r}${n(\"]\",i)}`}else u=t.stylize(`[${e}]`,i)}else u=void 0!==o.set?t.stylize(\"[Setter]\",\"special\"):t.stylize(\"undefined\",\"undefined\");if(1===i)return u;if(\"symbol\"==typeof n){const e=ct(gt(n),we,ke);a=`[${t.stylize(e,\"symbol\")}]`}else a=!1===o.enumerable?`[${ct(n,we,ke)}]`:K(ve,n)?t.stylize(n,\"name\"):t.stylize($e(n),\"string\");return`${a}:${l}${u}`}function dr(t,e,r,n){let i=e.length+r;if(i+e.length>t.breakLength)return!1;for(let r=0;r<e.length;r++)if(t.colors?i+=$t(e[r]).length:i+=e[r].length,i>t.breakLength)return!1;return\"\"===n||!ot(n,\"\\n\")}function yr(t,e,r,n,o,s,a){if(!0!==t.compact){if(\"number\"==typeof t.compact&&t.compact>=1){const l=e.length;if(2===o&&l>6&&(e=function(t,e,r){let n=0,o=0,s=0,a=e.length;t.maxArrayLength<e.length&&a--;const l=new i(a);for(;s<a;s++){const r=Ne(e[s],t.colors);l[s]=r,n+=r+2,o<r&&(o=r)}const c=o+2;if(3*c+t.indentationLvl<t.breakLength&&(n/c>5||o<=6)){const i=2.5,o=B(c-n/e.length),s=A(c-3-o,1),f=T(I(B(i*s*a)/s),S((t.breakLength-t.indentationLvl)/c),4*t.compact,15);if(f<=1)return e;const h=[],p=[];for(let t=0;t<f;t++){let r=0;for(let n=t;n<e.length;n+=f)l[n]>r&&(r=l[n]);r+=2,p[t]=r}let d=ut;if(void 0!==r)for(let t=0;t<e.length;t++)if(\"number\"!=typeof r[t]&&\"bigint\"!=typeof r[t]){d=at;break}for(let t=0;t<a;t+=f){const r=T(t+f,a);let n=\"\",i=t;for(;i<r-1;i++){const r=p[i-t]+e[i].length-l[i];n+=d(`${e[i]}, `,r,\" \")}if(d===ut){const r=p[i-t]+e[i].length-l[i]-2;n+=ut(e[i],r,\" \")}else n+=e[i];u(h,n)}t.maxArrayLength<e.length&&u(h,e[a]),e=h}return e}(t,e,a)),t.currentDepth-s<t.compact&&l===e.length&&dr(t,e,e.length+t.indentationLvl+n[0].length+r.length+10,r))return`${r?`${r} `:\"\"}${n[0]} ${kt(e,\", \")} ${n[1]}`}const l=`\\n${lt(\" \",t.indentationLvl)}`;return`${r?`${r} `:\"\"}${n[0]}${l}  ${kt(e,`,${l}  `)}${l}${n[1]}`}if(dr(t,e,0,r))return`${n[0]}${r?` ${r}`:\"\"} ${kt(e,\", \")} `+n[1];const l=lt(\" \",t.indentationLvl),c=\"\"===r&&1===n[0].length?\" \":`${r?` ${r}`:\"\"}\\n${l}  `;return`${n[0]}${c}${kt(e,`,\\n${l}  `)} ${n[1]}`}function gr(t){const e=It(t,!1);if(void 0!==e&&(t=e),\"function\"!=typeof t.toString)return!0;if(W(t,\"toString\"))return!1;let r=t;do{r=D(r)}while(!W(r,\"toString\"));const n=k(r,\"constructor\");return void 0!==n&&\"function\"==typeof n.value&&ye.has(n.value.name)}const br=t=>ht(t.message,\"\\n\",1)[0];let mr;function wr(t){try{return _(t)}catch(t){if(!mr)try{const t={};t.a=t,_(t)}catch(t){mr=br(t)}if(\"TypeError\"===t.name&&br(t)===mr)return\"[Circular]\";throw t}}function _r(t,e){const r=e[0];let n=0,i=\"\",o=\"\";if(\"string\"==typeof r){if(1===e.length)return r;let s,a=0;for(let o=0;o<r.length-1;o++)if(37===nt(r,o)){const u=nt(r,++o);if(n+1!==e.length){switch(u){case 115:const u=e[++n];s=\"number\"==typeof u?Xe(De,u):\"bigint\"==typeof u?`${u}n`:\"object\"==typeof u&&null!==u&&gr(u)?Le(u,{...t,compact:3,colors:!1,depth:0}):rt(u);break;case 106:s=wr(e[++n]);break;case 100:const l=e[++n];s=\"bigint\"==typeof l?`${l}n`:\"symbol\"==typeof l?\"NaN\":Xe(De,x(l));break;case 79:s=Le(e[++n],t);break;case 111:s=Le(e[++n],{...t,showHidden:!0,showProxy:!0,depth:4});break;case 105:const c=e[++n];s=\"bigint\"==typeof c?`${c}n`:\"symbol\"==typeof c?\"NaN\":Xe(De,N(c));break;case 102:const f=e[++n];s=\"symbol\"==typeof f?\"NaN\":Xe(De,R(f));break;case 99:n+=1,s=\"\";break;case 37:i+=ft(r,a,o),a=o+1;continue;default:continue}a!==o-1&&(i+=ft(r,a,o-1)),i+=s,a=o+1}else 37===u&&(i+=ft(r,a,o),a=o+1)}0!==a&&(n++,o=\" \",a<r.length&&(i+=ft(r,a)))}for(;n<e.length;){const r=e[n];i+=o,i+=\"string\"!=typeof r?Le(r,t):r,o=\" \",n++}return i}if(n(\"config\").hasIntl){const t=n(\"icu\");Ne=function(e,r=!0){let n=0;r&&(e=Er(e));for(let r=0;r<e.length;r++){const i=e.charCodeAt(r);if(i>=127){n+=t.getStringWidth(e.slice(r).normalize(\"NFC\"));break}n+=i>=32?1:0}return n}}else{Ne=function(r,n=!0){let i=0;n&&(r=Er(r)),r=st(r,\"NFC\");for(const n of new J(r)){const r=it(n,0);t(r)?i+=2:e(r)||i++}return i};const t=t=>t>=4352&&(t<=4447||9001===t||9002===t||t>=11904&&t<=12871&&12351!==t||t>=12880&&t<=19903||t>=19968&&t<=42182||t>=43360&&t<=43388||t>=44032&&t<=55203||t>=63744&&t<=64255||t>=65040&&t<=65049||t>=65072&&t<=65131||t>=65281&&t<=65376||t>=65504&&t<=65510||t>=110592&&t<=110593||t>=127488&&t<=127569||t>=127744&&t<=128591||t>=131072&&t<=262141),e=t=>t<=31||t>=127&&t<=159||t>=768&&t<=879||t>=8203&&t<=8207||t>=8400&&t<=8447||t>=65024&&t<=65039||t>=65056&&t<=65071||t>=917760&&t<=917999}function Er(t){return t.replace(Re,\"\")}t.exports={inspect:Le,format:function(...t){return _r(void 0,t)},formatWithOptions:function(t,...e){if(\"object\"!=typeof t||null===t)throw new Ft(\"inspectOptions\",\"object\",t);return _r(t,e)},stylizeWithColor:Fe,stylizeWithHTML(t,e){const r=Le.styles[e];return void 0!==r?`<span style=\"color:${r};\">${t}</span>`:t},Proxy:Mt}},183:t=>{t.exports=function(t){if(!t)throw new Error(\"Assertion failed\")}},992:(t,e)=>{e.NativeModule={exists:t=>!t.startsWith(\"/\")}},101:(t,e,r)=>{const{ArrayIsArray:n,ArrayPrototypeIncludes:i,ArrayPrototypeIndexOf:o,ArrayPrototypeJoin:s,ArrayPrototypePop:a,ArrayPrototypePush:u,ArrayPrototypeSplice:l,ErrorCaptureStackTrace:c,ObjectDefineProperty:f,ReflectApply:h,RegExpPrototypeTest:p,SafeMap:d,StringPrototypeEndsWith:y,StringPrototypeIncludes:g,StringPrototypeSlice:b,StringPrototypeToLowerCase:m}=r(765),w=new d,_={},E=/^([A-Z][a-z0-9]*)+$/,v=[\"string\",\"function\",\"number\",\"object\",\"Function\",\"Object\",\"boolean\",\"bigint\",\"symbol\"];let S,A,T=null;function I(){return T||(T=r(48)),T}const B=x((function(t,e,r){(t=O(t)).name=`${e} [${r}]`,t.stack,delete t.name}));function x(t){const e=\"__node_internal_\"+t.name;return f(t,\"name\",{value:e}),t}const O=x((function(t){return S=Error.stackTraceLimit,Error.stackTraceLimit=1/0,c(t),Error.stackTraceLimit=S,t}));let R,N;var L,P,M,U,j;t.exports={codes:_,hideStackFrames:x,isStackOverflowError:function(t){if(void 0===N)try{!function t(){t()}()}catch(t){N=t.message,R=t.name}return t&&t.name===R&&t.message===N}},L=\"ERR_INVALID_ARG_TYPE\",P=(t,e,r)=>{A(\"string\"==typeof t,\"'name' must be a string\"),n(e)||(e=[e]);let c=\"The \";y(t,\" argument\")?c+=`${t} `:c+=`\"${t}\" ${g(t,\".\")?\"property\":\"argument\"} `,c+=\"must be \";const f=[],h=[],d=[];for(const t of e)A(\"string\"==typeof t,\"All expected entries have to be of type string\"),i(v,t)?u(f,m(t)):p(E,t)?u(h,t):(A(\"object\"!==t,'The value \"object\" should be written as \"Object\"'),u(d,t));if(h.length>0){const t=o(f,\"object\");-1!==t&&(l(f,t,1),u(h,\"Object\"))}if(f.length>0){if(f.length>2){const t=a(f);c+=`one of type ${s(f,\", \")}, or ${t}`}else c+=2===f.length?`one of type ${f[0]} or ${f[1]}`:`of type ${f[0]}`;(h.length>0||d.length>0)&&(c+=\" or \")}if(h.length>0){if(h.length>2){const t=a(h);c+=`an instance of ${s(h,\", \")}, or ${t}`}else c+=`an instance of ${h[0]}`,2===h.length&&(c+=` or ${h[1]}`);d.length>0&&(c+=\" or \")}if(d.length>0)if(d.length>2){const t=a(d);c+=`one of ${s(d,\", \")}, or ${t}`}else 2===d.length?c+=`one of ${d[0]} or ${d[1]}`:(m(d[0])!==d[0]&&(c+=\"an \"),c+=`${d[0]}`);if(null==r)c+=`. Received ${r}`;else if(\"function\"==typeof r&&r.name)c+=`. Received function ${r.name}`;else if(\"object\"==typeof r)r.constructor&&r.constructor.name?c+=`. Received an instance of ${r.constructor.name}`:c+=`. Received ${I().inspect(r,{depth:-1})}`;else{let t=I().inspect(r,{colors:!1});t.length>25&&(t=`${b(t,0,25)}...`),c+=`. Received type ${typeof r} (${t})`}return c},M=TypeError,w.set(L,P),_[L]=(U=M,j=L,function(...t){const e=Error.stackTraceLimit;Error.stackTraceLimit=0;const n=new U;Error.stackTraceLimit=e;const i=function(t,e,n){const i=w.get(t);return void 0===A&&(A=r(183)),A(\"function\"==typeof i),A(i.length<=e.length,`Code: ${t}; The provided arguments length (${e.length}) does not match the required ones (${i.length}).`),h(i,n,e)}(j,t,n);return f(n,\"message\",{value:i,enumerable:!1,writable:!0,configurable:!0}),f(n,\"toString\",{value(){return`${this.name} [${j}]: ${this.message}`},enumerable:!1,writable:!0,configurable:!0}),B(n,U.name,j),n.code=j,n})},335:t=>{const e=/\\u001b\\[\\d\\d?m/g;t.exports={customInspectSymbol:Symbol.for(\"nodejs.util.inspect.custom\"),isError:t=>t instanceof Error,join:Array.prototype.join.call.bind(Array.prototype.join),removeColors:t=>String.prototype.replace.call(t,e,\"\")}},63:(t,e,r)=>{const{getConstructorName:n}=r(891);function i(t,...e){for(const r of e){const e=globalThis[r];if(e&&t instanceof e)return!0}for(;t;){if(\"object\"!=typeof t)return!1;if(e.indexOf(n(t))>=0)return!0;t=Object.getPrototypeOf(t)}return!1}function o(t){return e=>{if(!i(e,t.name))return!1;try{t.prototype.valueOf.call(e)}catch{return!1}return!0}}\"object\"!=typeof globalThis&&(Object.defineProperty(Object.prototype,\"__magic__\",{get:function(){return this},configurable:!0}),__magic__.globalThis=__magic__,delete Object.prototype.__magic__);const s=o(String),a=o(Number),u=o(Boolean),l=o(BigInt),c=o(Symbol);t.exports={isAsyncFunction:t=>\"function\"==typeof t&&Function.prototype.toString.call(t).startsWith(\"async\"),isGeneratorFunction:t=>\"function\"==typeof t&&Function.prototype.toString.call(t).match(/^(async\\s+)?function *\\*/),isAnyArrayBuffer:t=>i(t,\"ArrayBuffer\",\"SharedArrayBuffer\"),isArrayBuffer:t=>i(t,\"ArrayBuffer\"),isArgumentsObject:t=>!1,isBoxedPrimitive:t=>a(t)||s(t)||u(t)||l(t)||c(t),isDataView:t=>i(t,\"DataView\"),isExternal:t=>\"object\"==typeof t&&Object.isFrozen(t)&&null==Object.getPrototypeOf(t),isMap(t){if(!i(t,\"Map\"))return!1;try{t.has()}catch{return!1}return!0},isMapIterator:t=>\"[object Map Iterator]\"===Object.prototype.toString.call(Object.getPrototypeOf(t)),isModuleNamespaceObject:t=>t&&\"object\"==typeof t&&\"Module\"===t[Symbol.toStringTag],isNativeError:t=>t instanceof Error&&i(t,\"Error\",\"EvalError\",\"RangeError\",\"ReferenceError\",\"SyntaxError\",\"TypeError\",\"URIError\",\"AggregateError\"),isPromise:t=>i(t,\"Promise\"),isSet(t){if(!i(t,\"Set\"))return!1;try{t.has()}catch{return!1}return!0},isSetIterator:t=>\"[object Set Iterator]\"===Object.prototype.toString.call(Object.getPrototypeOf(t)),isWeakMap:t=>i(t,\"WeakMap\"),isWeakSet:t=>i(t,\"WeakSet\"),isRegExp:t=>i(t,\"RegExp\"),isDate(t){if(i(t,\"Date\"))try{return Date.prototype.getTime.call(t),!0}catch{}return!1},isTypedArray:t=>i(t,\"Int8Array\",\"Uint8Array\",\"Uint8ClampedArray\",\"Int16Array\",\"Uint16Array\",\"Int32Array\",\"Uint32Array\",\"Float32Array\",\"Float64Array\",\"BigInt64Array\",\"BigUint64Array\"),isStringObject:s,isNumberObject:a,isBooleanObject:u,isBigIntObject:l,isSymbolObject:c}},356:(t,e,r)=>{const{hideStackFrames:n,codes:{ERR_INVALID_ARG_TYPE:i}}=r(101);e.validateObject=n(((t,e,{nullable:r=!1}={})=>{if(!r&&null===t||Array.isArray(t)||\"object\"!=typeof t)throw new i(e,\"Object\",t)}))},765:t=>{const e=(t,e)=>{class r{constructor(e){this._iterator=t(e)}next(){return e(this._iterator)}[Symbol.iterator](){return this}}return Object.setPrototypeOf(r.prototype,null),Object.freeze(r.prototype),Object.freeze(r),r};function r(t,e){return Function.prototype.call.bind(t.prototype.__lookupGetter__(e))}function n(t){return Function.prototype.call.bind(t)}const i=(t,e)=>{Array.prototype.forEach.call(Reflect.ownKeys(t),(r=>{Reflect.getOwnPropertyDescriptor(e,r)||Reflect.defineProperty(e,r,Reflect.getOwnPropertyDescriptor(t,r))}))},o=(t,r)=>{if(Symbol.iterator in t.prototype){const i=new t;let o;Array.prototype.forEach.call(Reflect.ownKeys(t.prototype),(s=>{if(!Reflect.getOwnPropertyDescriptor(r.prototype,s)){const a=Reflect.getOwnPropertyDescriptor(t.prototype,s);if(\"function\"==typeof a.value&&0===a.value.length&&Symbol.iterator in(Function.prototype.call.call(a.value,i)||{})){const t=n(a.value);null==o&&(o=n(t(i).next));const r=e(t,o);a.value=function(){return new r(this)}}Reflect.defineProperty(r.prototype,s,a)}}))}else i(t.prototype,r.prototype);return i(t,r),Object.setPrototypeOf(r.prototype,null),Object.freeze(r.prototype),Object.freeze(r),r},s=Function.prototype.call.bind(String.prototype[Symbol.iterator]),a=Reflect.getPrototypeOf(s(\"\"));t.exports={makeSafe:o,internalBinding(t){if(\"config\"===t)return{hasIntl:!1};throw new Error(`unknown module: \"${t}\"`)},Array,ArrayIsArray:Array.isArray,ArrayPrototypeFilter:Function.prototype.call.bind(Array.prototype.filter),ArrayPrototypeForEach:Function.prototype.call.bind(Array.prototype.forEach),ArrayPrototypeIncludes:Function.prototype.call.bind(Array.prototype.includes),ArrayPrototypeIndexOf:Function.prototype.call.bind(Array.prototype.indexOf),ArrayPrototypeJoin:Function.prototype.call.bind(Array.prototype.join),ArrayPrototypePop:Function.prototype.call.bind(Array.prototype.pop),ArrayPrototypePush:Function.prototype.call.bind(Array.prototype.push),ArrayPrototypePushApply:Function.apply.bind(Array.prototype.push),ArrayPrototypeSort:Function.prototype.call.bind(Array.prototype.sort),ArrayPrototypeSplice:Function.prototype.call.bind(Array.prototype.slice),ArrayPrototypeUnshift:Function.prototype.call.bind(Array.prototype.unshift),BigIntPrototypeValueOf:Function.prototype.call.bind(BigInt.prototype.valueOf),BooleanPrototypeValueOf:Function.prototype.call.bind(Boolean.prototype.valueOf),DatePrototypeGetTime:Function.prototype.call.bind(Date.prototype.getTime),DatePrototypeToISOString:Function.prototype.call.bind(Date.prototype.toISOString),DatePrototypeToString:Function.prototype.call.bind(Date.prototype.toString),ErrorCaptureStackTrace:function(t){const e=(new Error).stack;t.stack=e.replace(/.*\\n.*/,\"$1\")},ErrorPrototypeToString:Function.prototype.call.bind(Error.prototype.toString),FunctionPrototypeCall:Function.prototype.call.bind(Function.prototype.call),FunctionPrototypeToString:Function.prototype.call.bind(Function.prototype.toString),JSONStringify:JSON.stringify,MapPrototypeGetSize:r(Map,\"size\"),MapPrototypeEntries:Function.prototype.call.bind(Map.prototype.entries),MathFloor:Math.floor,MathMax:Math.max,MathMin:Math.min,MathRound:Math.round,MathSqrt:Math.sqrt,Number,NumberIsNaN:Number.isNaN,NumberParseFloat:Number.parseFloat,NumberParseInt:Number.parseInt,NumberPrototypeValueOf:Function.prototype.call.bind(Number.prototype.valueOf),Object,ObjectAssign:Object.assign,ObjectCreate:Object.create,ObjectDefineProperty:Object.defineProperty,ObjectGetOwnPropertyDescriptor:Object.getOwnPropertyDescriptor,ObjectGetOwnPropertyNames:Object.getOwnPropertyNames,ObjectGetOwnPropertySymbols:Object.getOwnPropertySymbols,ObjectGetPrototypeOf:Object.getPrototypeOf,ObjectIs:Object.is,ObjectKeys:Object.keys,ObjectPrototypeHasOwnProperty:Function.prototype.call.bind(Object.prototype.hasOwnProperty),ObjectPrototypePropertyIsEnumerable:Function.prototype.call.bind(Object.prototype.propertyIsEnumerable),ObjectSeal:Object.seal,ObjectSetPrototypeOf:Object.setPrototypeOf,ReflectApply:Reflect.apply,ReflectOwnKeys:Reflect.ownKeys,RegExp,RegExpPrototypeTest:Function.prototype.call.bind(RegExp.prototype.test),RegExpPrototypeToString:Function.prototype.call.bind(RegExp.prototype.toString),SafeStringIterator:e(s,Function.prototype.call.bind(a.next)),SafeMap:o(Map,class extends Map{constructor(t){super(t)}}),SafeSet:o(Set,class extends Set{constructor(t){super(t)}}),SetPrototypeGetSize:r(Set,\"size\"),SetPrototypeValues:Function.prototype.call.bind(Set.prototype.values),String,StringPrototypeCharCodeAt:Function.prototype.call.bind(String.prototype.charCodeAt),StringPrototypeCodePointAt:Function.prototype.call.bind(String.prototype.codePointAt),StringPrototypeEndsWith:Function.prototype.call.bind(String.prototype.endsWith),StringPrototypeIncludes:Function.prototype.call.bind(String.prototype.includes),StringPrototypeNormalize:Function.prototype.call.bind(String.prototype.normalize),StringPrototypePadEnd:Function.prototype.call.bind(String.prototype.padEnd),StringPrototypePadStart:Function.prototype.call.bind(String.prototype.padStart),StringPrototypeRepeat:Function.prototype.call.bind(String.prototype.repeat),StringPrototypeReplace:Function.prototype.call.bind(String.prototype.replace),StringPrototypeSlice:Function.prototype.call.bind(String.prototype.slice),StringPrototypeSplit:Function.prototype.call.bind(String.prototype.split),StringPrototypeToLowerCase:Function.prototype.call.bind(String.prototype.toLowerCase),StringPrototypeTrim:Function.prototype.call.bind(String.prototype.trim),StringPrototypeValueOf:Function.prototype.call.bind(String.prototype.valueOf),SymbolPrototypeToString:Function.prototype.call.bind(Symbol.prototype.toString),SymbolPrototypeValueOf:Function.prototype.call.bind(Symbol.prototype.valueOf),SymbolIterator:Symbol.iterator,SymbolFor:Symbol.for,SymbolToStringTag:Symbol.toStringTag,TypedArrayPrototypeGetLength:t=>t.constructor.prototype.__lookupGetter__(\"length\").call(t),Uint8Array,uncurryThis:n}},161:t=>{const e=new WeakMap;class r{constructor(t,r){const n=new Proxy(t,r);return e.set(n,[t,r]),n}static getProxyDetails(t,r=!0){const n=e.get(t);if(n)return r?n:n[0]}}t.exports={getProxyDetails:r.getProxyDetails.bind(r),Proxy:r}},891:(t,e,r)=>{const n=r(161),i=Symbol(\"kPending\"),o=Symbol(\"kRejected\");t.exports={getOwnNonIndexProperties:function(t,e=2){const r=Object.getOwnPropertyDescriptors(t),n=[];for(const[t,i]of Object.entries(r))if(!/^(0|[1-9][0-9]*)$/.test(t)||parseInt(t,10)>=2**32-1){if(2===e&&!i.enumerable)continue;n.push(t)}for(const r of Object.getOwnPropertySymbols(t)){const i=Object.getOwnPropertyDescriptor(t,r);(2!==e||i.enumerable)&&n.push(r)}return n},getPromiseDetails:()=>[i,void 0],getProxyDetails:n.getProxyDetails,Proxy:n.Proxy,kPending:i,kRejected:o,previewEntries:t=>[[],!1],getConstructorName(t){if(!t||\"object\"!=typeof t)throw new Error(\"Invalid object\");if(t.constructor&&t.constructor.name)return t.constructor.name;const e=Object.prototype.toString.call(t).match(/^\\[object ([^\\]]+)\\]/);return e?e[1]:\"Object\"},getExternalValue:()=>BigInt(0),propertyFilter:{ALL_PROPERTIES:0,ONLY_ENUMERABLE:2}}}},e={};function r(n){if(e[n])return e[n].exports;var i=e[n]={exports:{}};return t[n](i,i.exports,r),i.exports}return r.g=function(){if(\"object\"==typeof globalThis)return globalThis;try{return this||new Function(\"return this\")()}catch(t){if(\"object\"==typeof window)return window}}(),r(48)})()},155:t=>{var e,r,n=t.exports={};function i(){throw new Error(\"setTimeout has not been defined\")}function o(){throw new Error(\"clearTimeout has not been defined\")}function s(t){if(e===setTimeout)return setTimeout(t,0);if((e===i||!e)&&setTimeout)return e=setTimeout,setTimeout(t,0);try{return e(t,0)}catch(r){try{return e.call(null,t,0)}catch(r){return e.call(this,t,0)}}}!function(){try{e=\"function\"==typeof setTimeout?setTimeout:i}catch(t){e=i}try{r=\"function\"==typeof clearTimeout?clearTimeout:o}catch(t){r=o}}();var a,u=[],l=!1,c=-1;function f(){l&&a&&(l=!1,a.length?u=a.concat(u):c=-1,u.length&&h())}function h(){if(!l){var t=s(f);l=!0;for(var e=u.length;e;){for(a=u,u=[];++c<e;)a&&a[c].run();c=-1,e=u.length}a=null,l=!1,function(t){if(r===clearTimeout)return clearTimeout(t);if((r===o||!r)&&clearTimeout)return r=clearTimeout,clearTimeout(t);try{r(t)}catch(e){try{return r.call(null,t)}catch(e){return r.call(this,t)}}}(t)}}function p(t,e){this.fun=t,this.array=e}function d(){}n.nextTick=function(t){var e=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)e[r-1]=arguments[r];u.push(new p(t,e)),1!==u.length||l||s(h)},p.prototype.run=function(){this.fun.apply(null,this.array)},n.title=\"browser\",n.browser=!0,n.env={},n.argv=[],n.version=\"\",n.versions={},n.on=d,n.addListener=d,n.once=d,n.off=d,n.removeListener=d,n.removeAllListeners=d,n.emit=d,n.prependListener=d,n.prependOnceListener=d,n.listeners=function(t){return[]},n.binding=function(t){throw new Error(\"process.binding is not supported\")},n.cwd=function(){return\"/\"},n.chdir=function(t){throw new Error(\"process.chdir is not supported\")},n.umask=function(){return 0}},281:t=>{\"use strict\";var e={};function r(t,r,n){n||(n=Error);var i=function(t){var e,n;function i(e,n,i){return t.call(this,function(t,e,n){return\"string\"==typeof r?r:r(t,e,n)}(e,n,i))||this}return n=t,(e=i).prototype=Object.create(n.prototype),e.prototype.constructor=e,e.__proto__=n,i}(n);i.prototype.name=n.name,i.prototype.code=t,e[t]=i}function n(t,e){if(Array.isArray(t)){var r=t.length;return t=t.map((function(t){return String(t)})),r>2?\"one of \".concat(e,\" \").concat(t.slice(0,r-1).join(\", \"),\", or \")+t[r-1]:2===r?\"one of \".concat(e,\" \").concat(t[0],\" or \").concat(t[1]):\"of \".concat(e,\" \").concat(t[0])}return\"of \".concat(e,\" \").concat(String(t))}r(\"ERR_INVALID_OPT_VALUE\",(function(t,e){return'The value \"'+e+'\" is invalid for option \"'+t+'\"'}),TypeError),r(\"ERR_INVALID_ARG_TYPE\",(function(t,e,r){var i,o,s,a,u;if(\"string\"==typeof e&&(o=\"not \",e.substr(0,o.length)===o)?(i=\"must not be\",e=e.replace(/^not /,\"\")):i=\"must be\",function(t,e,r){return(void 0===r||r>t.length)&&(r=t.length),t.substring(r-e.length,r)===e}(t,\" argument\"))s=\"The \".concat(t,\" \").concat(i,\" \").concat(n(e,\"type\"));else{var l=(\"number\"!=typeof u&&(u=0),u+\".\".length>(a=t).length||-1===a.indexOf(\".\",u)?\"argument\":\"property\");s='The \"'.concat(t,'\" ').concat(l,\" \").concat(i,\" \").concat(n(e,\"type\"))}return s+\". Received type \".concat(typeof r)}),TypeError),r(\"ERR_STREAM_PUSH_AFTER_EOF\",\"stream.push() after EOF\"),r(\"ERR_METHOD_NOT_IMPLEMENTED\",(function(t){return\"The \"+t+\" method is not implemented\"})),r(\"ERR_STREAM_PREMATURE_CLOSE\",\"Premature close\"),r(\"ERR_STREAM_DESTROYED\",(function(t){return\"Cannot call \"+t+\" after a stream was destroyed\"})),r(\"ERR_MULTIPLE_CALLBACK\",\"Callback called multiple times\"),r(\"ERR_STREAM_CANNOT_PIPE\",\"Cannot pipe, not readable\"),r(\"ERR_STREAM_WRITE_AFTER_END\",\"write after end\"),r(\"ERR_STREAM_NULL_VALUES\",\"May not write null values to stream\",TypeError),r(\"ERR_UNKNOWN_ENCODING\",(function(t){return\"Unknown encoding: \"+t}),TypeError),r(\"ERR_STREAM_UNSHIFT_AFTER_END_EVENT\",\"stream.unshift() after end event\"),t.exports.q=e},753:(t,e,r)=>{\"use strict\";var n=r(155),i=Object.keys||function(t){var e=[];for(var r in t)e.push(r);return e};t.exports=c;var o=r(481),s=r(229);r(717)(c,o);for(var a=i(s.prototype),u=0;u<a.length;u++){var l=a[u];c.prototype[l]||(c.prototype[l]=s.prototype[l])}function c(t){if(!(this instanceof c))return new c(t);o.call(this,t),s.call(this,t),this.allowHalfOpen=!0,t&&(!1===t.readable&&(this.readable=!1),!1===t.writable&&(this.writable=!1),!1===t.allowHalfOpen&&(this.allowHalfOpen=!1,this.once(\"end\",f)))}function f(){this._writableState.ended||n.nextTick(h,this)}function h(t){t.end()}Object.defineProperty(c.prototype,\"writableHighWaterMark\",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),Object.defineProperty(c.prototype,\"writableBuffer\",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(c.prototype,\"writableLength\",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(c.prototype,\"destroyed\",{enumerable:!1,get:function(){return void 0!==this._readableState&&void 0!==this._writableState&&this._readableState.destroyed&&this._writableState.destroyed},set:function(t){void 0!==this._readableState&&void 0!==this._writableState&&(this._readableState.destroyed=t,this._writableState.destroyed=t)}})},725:(t,e,r)=>{\"use strict\";t.exports=i;var n=r(605);function i(t){if(!(this instanceof i))return new i(t);n.call(this,t)}r(717)(i,n),i.prototype._transform=function(t,e,r){r(null,t)}},481:(t,e,r)=>{\"use strict\";var n,i=r(155);t.exports=T,T.ReadableState=A,r(187).EventEmitter;var o,s=function(t,e){return t.listeners(e).length},a=r(503),u=r(764).Buffer,l=r.g.Uint8Array||function(){},c=r(669);o=c&&c.debuglog?c.debuglog(\"stream\"):function(){};var f,h,p,d=r(327),y=r(195),g=r(457).getHighWaterMark,b=r(281).q,m=b.ERR_INVALID_ARG_TYPE,w=b.ERR_STREAM_PUSH_AFTER_EOF,_=b.ERR_METHOD_NOT_IMPLEMENTED,E=b.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;r(717)(T,a);var v=y.errorOrDestroy,S=[\"error\",\"close\",\"destroy\",\"pause\",\"resume\"];function A(t,e,i){n=n||r(753),t=t||{},\"boolean\"!=typeof i&&(i=e instanceof n),this.objectMode=!!t.objectMode,i&&(this.objectMode=this.objectMode||!!t.readableObjectMode),this.highWaterMark=g(this,t,\"readableHighWaterMark\",i),this.buffer=new d,this.length=0,this.pipes=null,this.pipesCount=0,this.flowing=null,this.ended=!1,this.endEmitted=!1,this.reading=!1,this.sync=!0,this.needReadable=!1,this.emittedReadable=!1,this.readableListening=!1,this.resumeScheduled=!1,this.paused=!0,this.emitClose=!1!==t.emitClose,this.autoDestroy=!!t.autoDestroy,this.destroyed=!1,this.defaultEncoding=t.defaultEncoding||\"utf8\",this.awaitDrain=0,this.readingMore=!1,this.decoder=null,this.encoding=null,t.encoding&&(f||(f=r(553).s),this.decoder=new f(t.encoding),this.encoding=t.encoding)}function T(t){if(n=n||r(753),!(this instanceof T))return new T(t);var e=this instanceof n;this._readableState=new A(t,this,e),this.readable=!0,t&&(\"function\"==typeof t.read&&(this._read=t.read),\"function\"==typeof t.destroy&&(this._destroy=t.destroy)),a.call(this)}function I(t,e,r,n,i){o(\"readableAddChunk\",e);var s,a=t._readableState;if(null===e)a.reading=!1,function(t,e){if(o(\"onEofChunk\"),!e.ended){if(e.decoder){var r=e.decoder.end();r&&r.length&&(e.buffer.push(r),e.length+=e.objectMode?1:r.length)}e.ended=!0,e.sync?R(t):(e.needReadable=!1,e.emittedReadable||(e.emittedReadable=!0,N(t)))}}(t,a);else if(i||(s=function(t,e){var r,n;return n=e,u.isBuffer(n)||n instanceof l||\"string\"==typeof e||void 0===e||t.objectMode||(r=new m(\"chunk\",[\"string\",\"Buffer\",\"Uint8Array\"],e)),r}(a,e)),s)v(t,s);else if(a.objectMode||e&&e.length>0)if(\"string\"==typeof e||a.objectMode||Object.getPrototypeOf(e)===u.prototype||(e=function(t){return u.from(t)}(e)),n)a.endEmitted?v(t,new E):B(t,a,e,!0);else if(a.ended)v(t,new w);else{if(a.destroyed)return!1;a.reading=!1,a.decoder&&!r?(e=a.decoder.write(e),a.objectMode||0!==e.length?B(t,a,e,!1):L(t,a)):B(t,a,e,!1)}else n||(a.reading=!1,L(t,a));return!a.ended&&(a.length<a.highWaterMark||0===a.length)}function B(t,e,r,n){e.flowing&&0===e.length&&!e.sync?(e.awaitDrain=0,t.emit(\"data\",r)):(e.length+=e.objectMode?1:r.length,n?e.buffer.unshift(r):e.buffer.push(r),e.needReadable&&R(t)),L(t,e)}Object.defineProperty(T.prototype,\"destroyed\",{enumerable:!1,get:function(){return void 0!==this._readableState&&this._readableState.destroyed},set:function(t){this._readableState&&(this._readableState.destroyed=t)}}),T.prototype.destroy=y.destroy,T.prototype._undestroy=y.undestroy,T.prototype._destroy=function(t,e){e(t)},T.prototype.push=function(t,e){var r,n=this._readableState;return n.objectMode?r=!0:\"string\"==typeof t&&((e=e||n.defaultEncoding)!==n.encoding&&(t=u.from(t,e),e=\"\"),r=!0),I(this,t,e,!1,r)},T.prototype.unshift=function(t){return I(this,t,null,!0,!1)},T.prototype.isPaused=function(){return!1===this._readableState.flowing},T.prototype.setEncoding=function(t){f||(f=r(553).s);var e=new f(t);this._readableState.decoder=e,this._readableState.encoding=this._readableState.decoder.encoding;for(var n=this._readableState.buffer.head,i=\"\";null!==n;)i+=e.write(n.data),n=n.next;return this._readableState.buffer.clear(),\"\"!==i&&this._readableState.buffer.push(i),this._readableState.length=i.length,this};var x=1073741824;function O(t,e){return t<=0||0===e.length&&e.ended?0:e.objectMode?1:t!=t?e.flowing&&e.length?e.buffer.head.data.length:e.length:(t>e.highWaterMark&&(e.highWaterMark=function(t){return t>=x?t=x:(t--,t|=t>>>1,t|=t>>>2,t|=t>>>4,t|=t>>>8,t|=t>>>16,t++),t}(t)),t<=e.length?t:e.ended?e.length:(e.needReadable=!0,0))}function R(t){var e=t._readableState;o(\"emitReadable\",e.needReadable,e.emittedReadable),e.needReadable=!1,e.emittedReadable||(o(\"emitReadable\",e.flowing),e.emittedReadable=!0,i.nextTick(N,t))}function N(t){var e=t._readableState;o(\"emitReadable_\",e.destroyed,e.length,e.ended),e.destroyed||!e.length&&!e.ended||(t.emit(\"readable\"),e.emittedReadable=!1),e.needReadable=!e.flowing&&!e.ended&&e.length<=e.highWaterMark,k(t)}function L(t,e){e.readingMore||(e.readingMore=!0,i.nextTick(P,t,e))}function P(t,e){for(;!e.reading&&!e.ended&&(e.length<e.highWaterMark||e.flowing&&0===e.length);){var r=e.length;if(o(\"maybeReadMore read 0\"),t.read(0),r===e.length)break}e.readingMore=!1}function M(t){var e=t._readableState;e.readableListening=t.listenerCount(\"readable\")>0,e.resumeScheduled&&!e.paused?e.flowing=!0:t.listenerCount(\"data\")>0&&t.resume()}function U(t){o(\"readable nexttick read 0\"),t.read(0)}function j(t,e){o(\"resume\",e.reading),e.reading||t.read(0),e.resumeScheduled=!1,t.emit(\"resume\"),k(t),e.flowing&&!e.reading&&t.read(0)}function k(t){var e=t._readableState;for(o(\"flow\",e.flowing);e.flowing&&null!==t.read(););}function $(t,e){return 0===e.length?null:(e.objectMode?r=e.buffer.shift():!t||t>=e.length?(r=e.decoder?e.buffer.join(\"\"):1===e.buffer.length?e.buffer.first():e.buffer.concat(e.length),e.buffer.clear()):r=e.buffer.consume(t,e.decoder),r);var r}function F(t){var e=t._readableState;o(\"endReadable\",e.endEmitted),e.endEmitted||(e.ended=!0,i.nextTick(D,e,t))}function D(t,e){if(o(\"endReadableNT\",t.endEmitted,t.length),!t.endEmitted&&0===t.length&&(t.endEmitted=!0,e.readable=!1,e.emit(\"end\"),t.autoDestroy)){var r=e._writableState;(!r||r.autoDestroy&&r.finished)&&e.destroy()}}function C(t,e){for(var r=0,n=t.length;r<n;r++)if(t[r]===e)return r;return-1}T.prototype.read=function(t){o(\"read\",t),t=parseInt(t,10);var e=this._readableState,r=t;if(0!==t&&(e.emittedReadable=!1),0===t&&e.needReadable&&((0!==e.highWaterMark?e.length>=e.highWaterMark:e.length>0)||e.ended))return o(\"read: emitReadable\",e.length,e.ended),0===e.length&&e.ended?F(this):R(this),null;if(0===(t=O(t,e))&&e.ended)return 0===e.length&&F(this),null;var n,i=e.needReadable;return o(\"need readable\",i),(0===e.length||e.length-t<e.highWaterMark)&&o(\"length less than watermark\",i=!0),e.ended||e.reading?o(\"reading or ended\",i=!1):i&&(o(\"do read\"),e.reading=!0,e.sync=!0,0===e.length&&(e.needReadable=!0),this._read(e.highWaterMark),e.sync=!1,e.reading||(t=O(r,e))),null===(n=t>0?$(t,e):null)?(e.needReadable=e.length<=e.highWaterMark,t=0):(e.length-=t,e.awaitDrain=0),0===e.length&&(e.ended||(e.needReadable=!0),r!==t&&e.ended&&F(this)),null!==n&&this.emit(\"data\",n),n},T.prototype._read=function(t){v(this,new _(\"_read()\"))},T.prototype.pipe=function(t,e){var r=this,n=this._readableState;switch(n.pipesCount){case 0:n.pipes=t;break;case 1:n.pipes=[n.pipes,t];break;default:n.pipes.push(t)}n.pipesCount+=1,o(\"pipe count=%d opts=%j\",n.pipesCount,e);var a=e&&!1===e.end||t===i.stdout||t===i.stderr?y:u;function u(){o(\"onend\"),t.end()}n.endEmitted?i.nextTick(a):r.once(\"end\",a),t.on(\"unpipe\",(function e(i,s){o(\"onunpipe\"),i===r&&s&&!1===s.hasUnpiped&&(s.hasUnpiped=!0,o(\"cleanup\"),t.removeListener(\"close\",p),t.removeListener(\"finish\",d),t.removeListener(\"drain\",l),t.removeListener(\"error\",h),t.removeListener(\"unpipe\",e),r.removeListener(\"end\",u),r.removeListener(\"end\",y),r.removeListener(\"data\",f),c=!0,!n.awaitDrain||t._writableState&&!t._writableState.needDrain||l())}));var l=function(t){return function(){var e=t._readableState;o(\"pipeOnDrain\",e.awaitDrain),e.awaitDrain&&e.awaitDrain--,0===e.awaitDrain&&s(t,\"data\")&&(e.flowing=!0,k(t))}}(r);t.on(\"drain\",l);var c=!1;function f(e){o(\"ondata\");var i=t.write(e);o(\"dest.write\",i),!1===i&&((1===n.pipesCount&&n.pipes===t||n.pipesCount>1&&-1!==C(n.pipes,t))&&!c&&(o(\"false write response, pause\",n.awaitDrain),n.awaitDrain++),r.pause())}function h(e){o(\"onerror\",e),y(),t.removeListener(\"error\",h),0===s(t,\"error\")&&v(t,e)}function p(){t.removeListener(\"finish\",d),y()}function d(){o(\"onfinish\"),t.removeListener(\"close\",p),y()}function y(){o(\"unpipe\"),r.unpipe(t)}return r.on(\"data\",f),function(t,e,r){if(\"function\"==typeof t.prependListener)return t.prependListener(e,r);t._events&&t._events.error?Array.isArray(t._events.error)?t._events.error.unshift(r):t._events.error=[r,t._events.error]:t.on(e,r)}(t,\"error\",h),t.once(\"close\",p),t.once(\"finish\",d),t.emit(\"pipe\",r),n.flowing||(o(\"pipe resume\"),r.resume()),t},T.prototype.unpipe=function(t){var e=this._readableState,r={hasUnpiped:!1};if(0===e.pipesCount)return this;if(1===e.pipesCount)return t&&t!==e.pipes||(t||(t=e.pipes),e.pipes=null,e.pipesCount=0,e.flowing=!1,t&&t.emit(\"unpipe\",this,r)),this;if(!t){var n=e.pipes,i=e.pipesCount;e.pipes=null,e.pipesCount=0,e.flowing=!1;for(var o=0;o<i;o++)n[o].emit(\"unpipe\",this,{hasUnpiped:!1});return this}var s=C(e.pipes,t);return-1===s||(e.pipes.splice(s,1),e.pipesCount-=1,1===e.pipesCount&&(e.pipes=e.pipes[0]),t.emit(\"unpipe\",this,r)),this},T.prototype.on=function(t,e){var r=a.prototype.on.call(this,t,e),n=this._readableState;return\"data\"===t?(n.readableListening=this.listenerCount(\"readable\")>0,!1!==n.flowing&&this.resume()):\"readable\"===t&&(n.endEmitted||n.readableListening||(n.readableListening=n.needReadable=!0,n.flowing=!1,n.emittedReadable=!1,o(\"on readable\",n.length,n.reading),n.length?R(this):n.reading||i.nextTick(U,this))),r},T.prototype.addListener=T.prototype.on,T.prototype.removeListener=function(t,e){var r=a.prototype.removeListener.call(this,t,e);return\"readable\"===t&&i.nextTick(M,this),r},T.prototype.removeAllListeners=function(t){var e=a.prototype.removeAllListeners.apply(this,arguments);return\"readable\"!==t&&void 0!==t||i.nextTick(M,this),e},T.prototype.resume=function(){var t=this._readableState;return t.flowing||(o(\"resume\"),t.flowing=!t.readableListening,function(t,e){e.resumeScheduled||(e.resumeScheduled=!0,i.nextTick(j,t,e))}(this,t)),t.paused=!1,this},T.prototype.pause=function(){return o(\"call pause flowing=%j\",this._readableState.flowing),!1!==this._readableState.flowing&&(o(\"pause\"),this._readableState.flowing=!1,this.emit(\"pause\")),this._readableState.paused=!0,this},T.prototype.wrap=function(t){var e=this,r=this._readableState,n=!1;for(var i in t.on(\"end\",(function(){if(o(\"wrapped end\"),r.decoder&&!r.ended){var t=r.decoder.end();t&&t.length&&e.push(t)}e.push(null)})),t.on(\"data\",(function(i){o(\"wrapped data\"),r.decoder&&(i=r.decoder.write(i)),r.objectMode&&null==i||(r.objectMode||i&&i.length)&&(e.push(i)||(n=!0,t.pause()))})),t)void 0===this[i]&&\"function\"==typeof t[i]&&(this[i]=function(e){return function(){return t[e].apply(t,arguments)}}(i));for(var s=0;s<S.length;s++)t.on(S[s],this.emit.bind(this,S[s]));return this._read=function(e){o(\"wrapped _read\",e),n&&(n=!1,t.resume())},this},\"function\"==typeof Symbol&&(T.prototype[Symbol.asyncIterator]=function(){return void 0===h&&(h=r(850)),h(this)}),Object.defineProperty(T.prototype,\"readableHighWaterMark\",{enumerable:!1,get:function(){return this._readableState.highWaterMark}}),Object.defineProperty(T.prototype,\"readableBuffer\",{enumerable:!1,get:function(){return this._readableState&&this._readableState.buffer}}),Object.defineProperty(T.prototype,\"readableFlowing\",{enumerable:!1,get:function(){return this._readableState.flowing},set:function(t){this._readableState&&(this._readableState.flowing=t)}}),T._fromList=$,Object.defineProperty(T.prototype,\"readableLength\",{enumerable:!1,get:function(){return this._readableState.length}}),\"function\"==typeof Symbol&&(T.from=function(t,e){return void 0===p&&(p=r(167)),p(T,t,e)})},605:(t,e,r)=>{\"use strict\";t.exports=c;var n=r(281).q,i=n.ERR_METHOD_NOT_IMPLEMENTED,o=n.ERR_MULTIPLE_CALLBACK,s=n.ERR_TRANSFORM_ALREADY_TRANSFORMING,a=n.ERR_TRANSFORM_WITH_LENGTH_0,u=r(753);function l(t,e){var r=this._transformState;r.transforming=!1;var n=r.writecb;if(null===n)return this.emit(\"error\",new o);r.writechunk=null,r.writecb=null,null!=e&&this.push(e),n(t);var i=this._readableState;i.reading=!1,(i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}function c(t){if(!(this instanceof c))return new c(t);u.call(this,t),this._transformState={afterTransform:l.bind(this),needTransform:!1,transforming:!1,writecb:null,writechunk:null,writeencoding:null},this._readableState.needReadable=!0,this._readableState.sync=!1,t&&(\"function\"==typeof t.transform&&(this._transform=t.transform),\"function\"==typeof t.flush&&(this._flush=t.flush)),this.on(\"prefinish\",f)}function f(){var t=this;\"function\"!=typeof this._flush||this._readableState.destroyed?h(this,null,null):this._flush((function(e,r){h(t,e,r)}))}function h(t,e,r){if(e)return t.emit(\"error\",e);if(null!=r&&t.push(r),t._writableState.length)throw new a;if(t._transformState.transforming)throw new s;return t.push(null)}r(717)(c,u),c.prototype.push=function(t,e){return this._transformState.needTransform=!1,u.prototype.push.call(this,t,e)},c.prototype._transform=function(t,e,r){r(new i(\"_transform()\"))},c.prototype._write=function(t,e,r){var n=this._transformState;if(n.writecb=r,n.writechunk=t,n.writeencoding=e,!n.transforming){var i=this._readableState;(n.needTransform||i.needReadable||i.length<i.highWaterMark)&&this._read(i.highWaterMark)}},c.prototype._read=function(t){var e=this._transformState;null===e.writechunk||e.transforming?e.needTransform=!0:(e.transforming=!0,this._transform(e.writechunk,e.writeencoding,e.afterTransform))},c.prototype._destroy=function(t,e){u.prototype._destroy.call(this,t,(function(t){e(t)}))}},229:(t,e,r)=>{\"use strict\";var n,i=r(155);function o(t){var e=this;this.next=null,this.entry=null,this.finish=function(){!function(t,e,r){var n=t.entry;for(t.entry=null;n;){var i=n.callback;e.pendingcb--,i(undefined),n=n.next}e.corkedRequestsFree.next=t}(e,t)}}t.exports=T,T.WritableState=A;var s,a={deprecate:r(927)},u=r(503),l=r(764).Buffer,c=r.g.Uint8Array||function(){},f=r(195),h=r(457).getHighWaterMark,p=r(281).q,d=p.ERR_INVALID_ARG_TYPE,y=p.ERR_METHOD_NOT_IMPLEMENTED,g=p.ERR_MULTIPLE_CALLBACK,b=p.ERR_STREAM_CANNOT_PIPE,m=p.ERR_STREAM_DESTROYED,w=p.ERR_STREAM_NULL_VALUES,_=p.ERR_STREAM_WRITE_AFTER_END,E=p.ERR_UNKNOWN_ENCODING,v=f.errorOrDestroy;function S(){}function A(t,e,s){n=n||r(753),t=t||{},\"boolean\"!=typeof s&&(s=e instanceof n),this.objectMode=!!t.objectMode,s&&(this.objectMode=this.objectMode||!!t.writableObjectMode),this.highWaterMark=h(this,t,\"writableHighWaterMark\",s),this.finalCalled=!1,this.needDrain=!1,this.ending=!1,this.ended=!1,this.finished=!1,this.destroyed=!1;var a=!1===t.decodeStrings;this.decodeStrings=!a,this.defaultEncoding=t.defaultEncoding||\"utf8\",this.length=0,this.writing=!1,this.corked=0,this.sync=!0,this.bufferProcessing=!1,this.onwrite=function(t){!function(t,e){var r=t._writableState,n=r.sync,o=r.writecb;if(\"function\"!=typeof o)throw new g;if(function(t){t.writing=!1,t.writecb=null,t.length-=t.writelen,t.writelen=0}(r),e)!function(t,e,r,n,o){--e.pendingcb,r?(i.nextTick(o,n),i.nextTick(N,t,e),t._writableState.errorEmitted=!0,v(t,n)):(o(n),t._writableState.errorEmitted=!0,v(t,n),N(t,e))}(t,r,n,e,o);else{var s=O(r)||t.destroyed;s||r.corked||r.bufferProcessing||!r.bufferedRequest||x(t,r),n?i.nextTick(B,t,r,s,o):B(t,r,s,o)}}(e,t)},this.writecb=null,this.writelen=0,this.bufferedRequest=null,this.lastBufferedRequest=null,this.pendingcb=0,this.prefinished=!1,this.errorEmitted=!1,this.emitClose=!1!==t.emitClose,this.autoDestroy=!!t.autoDestroy,this.bufferedRequestCount=0,this.corkedRequestsFree=new o(this)}function T(t){var e=this instanceof(n=n||r(753));if(!e&&!s.call(T,this))return new T(t);this._writableState=new A(t,this,e),this.writable=!0,t&&(\"function\"==typeof t.write&&(this._write=t.write),\"function\"==typeof t.writev&&(this._writev=t.writev),\"function\"==typeof t.destroy&&(this._destroy=t.destroy),\"function\"==typeof t.final&&(this._final=t.final)),u.call(this)}function I(t,e,r,n,i,o,s){e.writelen=n,e.writecb=s,e.writing=!0,e.sync=!0,e.destroyed?e.onwrite(new m(\"write\")):r?t._writev(i,e.onwrite):t._write(i,o,e.onwrite),e.sync=!1}function B(t,e,r,n){r||function(t,e){0===e.length&&e.needDrain&&(e.needDrain=!1,t.emit(\"drain\"))}(t,e),e.pendingcb--,n(),N(t,e)}function x(t,e){e.bufferProcessing=!0;var r=e.bufferedRequest;if(t._writev&&r&&r.next){var n=e.bufferedRequestCount,i=new Array(n),s=e.corkedRequestsFree;s.entry=r;for(var a=0,u=!0;r;)i[a]=r,r.isBuf||(u=!1),r=r.next,a+=1;i.allBuffers=u,I(t,e,!0,e.length,i,\"\",s.finish),e.pendingcb++,e.lastBufferedRequest=null,s.next?(e.corkedRequestsFree=s.next,s.next=null):e.corkedRequestsFree=new o(e),e.bufferedRequestCount=0}else{for(;r;){var l=r.chunk,c=r.encoding,f=r.callback;if(I(t,e,!1,e.objectMode?1:l.length,l,c,f),r=r.next,e.bufferedRequestCount--,e.writing)break}null===r&&(e.lastBufferedRequest=null)}e.bufferedRequest=r,e.bufferProcessing=!1}function O(t){return t.ending&&0===t.length&&null===t.bufferedRequest&&!t.finished&&!t.writing}function R(t,e){t._final((function(r){e.pendingcb--,r&&v(t,r),e.prefinished=!0,t.emit(\"prefinish\"),N(t,e)}))}function N(t,e){var r=O(e);if(r&&(function(t,e){e.prefinished||e.finalCalled||(\"function\"!=typeof t._final||e.destroyed?(e.prefinished=!0,t.emit(\"prefinish\")):(e.pendingcb++,e.finalCalled=!0,i.nextTick(R,t,e)))}(t,e),0===e.pendingcb&&(e.finished=!0,t.emit(\"finish\"),e.autoDestroy))){var n=t._readableState;(!n||n.autoDestroy&&n.endEmitted)&&t.destroy()}return r}r(717)(T,u),A.prototype.getBuffer=function(){for(var t=this.bufferedRequest,e=[];t;)e.push(t),t=t.next;return e},function(){try{Object.defineProperty(A.prototype,\"buffer\",{get:a.deprecate((function(){return this.getBuffer()}),\"_writableState.buffer is deprecated. Use _writableState.getBuffer instead.\",\"DEP0003\")})}catch(t){}}(),\"function\"==typeof Symbol&&Symbol.hasInstance&&\"function\"==typeof Function.prototype[Symbol.hasInstance]?(s=Function.prototype[Symbol.hasInstance],Object.defineProperty(T,Symbol.hasInstance,{value:function(t){return!!s.call(this,t)||this===T&&t&&t._writableState instanceof A}})):s=function(t){return t instanceof this},T.prototype.pipe=function(){v(this,new b)},T.prototype.write=function(t,e,r){var n,o=this._writableState,s=!1,a=!o.objectMode&&(n=t,l.isBuffer(n)||n instanceof c);return a&&!l.isBuffer(t)&&(t=function(t){return l.from(t)}(t)),\"function\"==typeof e&&(r=e,e=null),a?e=\"buffer\":e||(e=o.defaultEncoding),\"function\"!=typeof r&&(r=S),o.ending?function(t,e){var r=new _;v(t,r),i.nextTick(e,r)}(this,r):(a||function(t,e,r,n){var o;return null===r?o=new w:\"string\"==typeof r||e.objectMode||(o=new d(\"chunk\",[\"string\",\"Buffer\"],r)),!o||(v(t,o),i.nextTick(n,o),!1)}(this,o,t,r))&&(o.pendingcb++,s=function(t,e,r,n,i,o){if(!r){var s=function(t,e,r){return t.objectMode||!1===t.decodeStrings||\"string\"!=typeof e||(e=l.from(e,r)),e}(e,n,i);n!==s&&(r=!0,i=\"buffer\",n=s)}var a=e.objectMode?1:n.length;e.length+=a;var u=e.length<e.highWaterMark;if(u||(e.needDrain=!0),e.writing||e.corked){var c=e.lastBufferedRequest;e.lastBufferedRequest={chunk:n,encoding:i,isBuf:r,callback:o,next:null},c?c.next=e.lastBufferedRequest:e.bufferedRequest=e.lastBufferedRequest,e.bufferedRequestCount+=1}else I(t,e,!1,a,n,i,o);return u}(this,o,a,t,e,r)),s},T.prototype.cork=function(){this._writableState.corked++},T.prototype.uncork=function(){var t=this._writableState;t.corked&&(t.corked--,t.writing||t.corked||t.bufferProcessing||!t.bufferedRequest||x(this,t))},T.prototype.setDefaultEncoding=function(t){if(\"string\"==typeof t&&(t=t.toLowerCase()),!([\"hex\",\"utf8\",\"utf-8\",\"ascii\",\"binary\",\"base64\",\"ucs2\",\"ucs-2\",\"utf16le\",\"utf-16le\",\"raw\"].indexOf((t+\"\").toLowerCase())>-1))throw new E(t);return this._writableState.defaultEncoding=t,this},Object.defineProperty(T.prototype,\"writableBuffer\",{enumerable:!1,get:function(){return this._writableState&&this._writableState.getBuffer()}}),Object.defineProperty(T.prototype,\"writableHighWaterMark\",{enumerable:!1,get:function(){return this._writableState.highWaterMark}}),T.prototype._write=function(t,e,r){r(new y(\"_write()\"))},T.prototype._writev=null,T.prototype.end=function(t,e,r){var n=this._writableState;return\"function\"==typeof t?(r=t,t=null,e=null):\"function\"==typeof e&&(r=e,e=null),null!=t&&this.write(t,e),n.corked&&(n.corked=1,this.uncork()),n.ending||function(t,e,r){e.ending=!0,N(t,e),r&&(e.finished?i.nextTick(r):t.once(\"finish\",r)),e.ended=!0,t.writable=!1}(this,n,r),this},Object.defineProperty(T.prototype,\"writableLength\",{enumerable:!1,get:function(){return this._writableState.length}}),Object.defineProperty(T.prototype,\"destroyed\",{enumerable:!1,get:function(){return void 0!==this._writableState&&this._writableState.destroyed},set:function(t){this._writableState&&(this._writableState.destroyed=t)}}),T.prototype.destroy=f.destroy,T.prototype._undestroy=f.undestroy,T.prototype._destroy=function(t,e){e(t)}},850:(t,e,r)=>{\"use strict\";var n,i=r(155);function o(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}var s=r(610),a=Symbol(\"lastResolve\"),u=Symbol(\"lastReject\"),l=Symbol(\"error\"),c=Symbol(\"ended\"),f=Symbol(\"lastPromise\"),h=Symbol(\"handlePromise\"),p=Symbol(\"stream\");function d(t,e){return{value:t,done:e}}function y(t){var e=t[a];if(null!==e){var r=t[p].read();null!==r&&(t[f]=null,t[a]=null,t[u]=null,e(d(r,!1)))}}function g(t){i.nextTick(y,t)}var b=Object.getPrototypeOf((function(){})),m=Object.setPrototypeOf((o(n={get stream(){return this[p]},next:function(){var t=this,e=this[l];if(null!==e)return Promise.reject(e);if(this[c])return Promise.resolve(d(void 0,!0));if(this[p].destroyed)return new Promise((function(e,r){i.nextTick((function(){t[l]?r(t[l]):e(d(void 0,!0))}))}));var r,n=this[f];if(n)r=new Promise(function(t,e){return function(r,n){t.then((function(){e[c]?r(d(void 0,!0)):e[h](r,n)}),n)}}(n,this));else{var o=this[p].read();if(null!==o)return Promise.resolve(d(o,!1));r=new Promise(this[h])}return this[f]=r,r}},Symbol.asyncIterator,(function(){return this})),o(n,\"return\",(function(){var t=this;return new Promise((function(e,r){t[p].destroy(null,(function(t){t?r(t):e(d(void 0,!0))}))}))})),n),b);t.exports=function(t){var e,r=Object.create(m,(o(e={},p,{value:t,writable:!0}),o(e,a,{value:null,writable:!0}),o(e,u,{value:null,writable:!0}),o(e,l,{value:null,writable:!0}),o(e,c,{value:t._readableState.endEmitted,writable:!0}),o(e,h,{value:function(t,e){var n=r[p].read();n?(r[f]=null,r[a]=null,r[u]=null,t(d(n,!1))):(r[a]=t,r[u]=e)},writable:!0}),e));return r[f]=null,s(t,(function(t){if(t&&\"ERR_STREAM_PREMATURE_CLOSE\"!==t.code){var e=r[u];return null!==e&&(r[f]=null,r[a]=null,r[u]=null,e(t)),void(r[l]=t)}var n=r[a];null!==n&&(r[f]=null,r[a]=null,r[u]=null,n(d(void 0,!0))),r[c]=!0})),t.on(\"readable\",g.bind(null,r)),r}},327:(t,e,r)=>{\"use strict\";function n(t,e){var r=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),r.push.apply(r,n)}return r}function i(t,e,r){return e in t?Object.defineProperty(t,e,{value:r,enumerable:!0,configurable:!0,writable:!0}):t[e]=r,t}function o(t,e){for(var r=0;r<e.length;r++){var n=e[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(t,n.key,n)}}var s=r(764).Buffer,a=r(669).inspect,u=a&&a.custom||\"inspect\";t.exports=function(){function t(){!function(t,e){if(!(t instanceof e))throw new TypeError(\"Cannot call a class as a function\")}(this,t),this.head=null,this.tail=null,this.length=0}var e,r;return e=t,(r=[{key:\"push\",value:function(t){var e={data:t,next:null};this.length>0?this.tail.next=e:this.head=e,this.tail=e,++this.length}},{key:\"unshift\",value:function(t){var e={data:t,next:this.head};0===this.length&&(this.tail=e),this.head=e,++this.length}},{key:\"shift\",value:function(){if(0!==this.length){var t=this.head.data;return 1===this.length?this.head=this.tail=null:this.head=this.head.next,--this.length,t}}},{key:\"clear\",value:function(){this.head=this.tail=null,this.length=0}},{key:\"join\",value:function(t){if(0===this.length)return\"\";for(var e=this.head,r=\"\"+e.data;e=e.next;)r+=t+e.data;return r}},{key:\"concat\",value:function(t){if(0===this.length)return s.alloc(0);for(var e,r,n,i=s.allocUnsafe(t>>>0),o=this.head,a=0;o;)e=o.data,r=i,n=a,s.prototype.copy.call(e,r,n),a+=o.data.length,o=o.next;return i}},{key:\"consume\",value:function(t,e){var r;return t<this.head.data.length?(r=this.head.data.slice(0,t),this.head.data=this.head.data.slice(t)):r=t===this.head.data.length?this.shift():e?this._getString(t):this._getBuffer(t),r}},{key:\"first\",value:function(){return this.head.data}},{key:\"_getString\",value:function(t){var e=this.head,r=1,n=e.data;for(t-=n.length;e=e.next;){var i=e.data,o=t>i.length?i.length:t;if(o===i.length?n+=i:n+=i.slice(0,t),0==(t-=o)){o===i.length?(++r,e.next?this.head=e.next:this.head=this.tail=null):(this.head=e,e.data=i.slice(o));break}++r}return this.length-=r,n}},{key:\"_getBuffer\",value:function(t){var e=s.allocUnsafe(t),r=this.head,n=1;for(r.data.copy(e),t-=r.data.length;r=r.next;){var i=r.data,o=t>i.length?i.length:t;if(i.copy(e,e.length-t,0,o),0==(t-=o)){o===i.length?(++n,r.next?this.head=r.next:this.head=this.tail=null):(this.head=r,r.data=i.slice(o));break}++n}return this.length-=n,e}},{key:u,value:function(t,e){return a(this,function(t){for(var e=1;e<arguments.length;e++){var r=null!=arguments[e]?arguments[e]:{};e%2?n(Object(r),!0).forEach((function(e){i(t,e,r[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(r,e))}))}return t}({},e,{depth:0,customInspect:!1}))}}])&&o(e.prototype,r),t}()},195:(t,e,r)=>{\"use strict\";var n=r(155);function i(t,e){s(t,e),o(t)}function o(t){t._writableState&&!t._writableState.emitClose||t._readableState&&!t._readableState.emitClose||t.emit(\"close\")}function s(t,e){t.emit(\"error\",e)}t.exports={destroy:function(t,e){var r=this,a=this._readableState&&this._readableState.destroyed,u=this._writableState&&this._writableState.destroyed;return a||u?(e?e(t):t&&(this._writableState?this._writableState.errorEmitted||(this._writableState.errorEmitted=!0,n.nextTick(s,this,t)):n.nextTick(s,this,t)),this):(this._readableState&&(this._readableState.destroyed=!0),this._writableState&&(this._writableState.destroyed=!0),this._destroy(t||null,(function(t){!e&&t?r._writableState?r._writableState.errorEmitted?n.nextTick(o,r):(r._writableState.errorEmitted=!0,n.nextTick(i,r,t)):n.nextTick(i,r,t):e?(n.nextTick(o,r),e(t)):n.nextTick(o,r)})),this)},undestroy:function(){this._readableState&&(this._readableState.destroyed=!1,this._readableState.reading=!1,this._readableState.ended=!1,this._readableState.endEmitted=!1),this._writableState&&(this._writableState.destroyed=!1,this._writableState.ended=!1,this._writableState.ending=!1,this._writableState.finalCalled=!1,this._writableState.prefinished=!1,this._writableState.finished=!1,this._writableState.errorEmitted=!1)},errorOrDestroy:function(t,e){var r=t._readableState,n=t._writableState;r&&r.autoDestroy||n&&n.autoDestroy?t.destroy(e):t.emit(\"error\",e)}}},610:(t,e,r)=>{\"use strict\";var n=r(281).q.ERR_STREAM_PREMATURE_CLOSE;function i(){}t.exports=function t(e,r,o){if(\"function\"==typeof r)return t(e,null,r);r||(r={}),o=function(t){var e=!1;return function(){if(!e){e=!0;for(var r=arguments.length,n=new Array(r),i=0;i<r;i++)n[i]=arguments[i];t.apply(this,n)}}}(o||i);var s=r.readable||!1!==r.readable&&e.readable,a=r.writable||!1!==r.writable&&e.writable,u=function(){e.writable||c()},l=e._writableState&&e._writableState.finished,c=function(){a=!1,l=!0,s||o.call(e)},f=e._readableState&&e._readableState.endEmitted,h=function(){s=!1,f=!0,a||o.call(e)},p=function(t){o.call(e,t)},d=function(){var t;return s&&!f?(e._readableState&&e._readableState.ended||(t=new n),o.call(e,t)):a&&!l?(e._writableState&&e._writableState.ended||(t=new n),o.call(e,t)):void 0},y=function(){e.req.on(\"finish\",c)};return function(t){return t.setHeader&&\"function\"==typeof t.abort}(e)?(e.on(\"complete\",c),e.on(\"abort\",d),e.req?y():e.on(\"request\",y)):a&&!e._writableState&&(e.on(\"end\",u),e.on(\"close\",u)),e.on(\"end\",h),e.on(\"finish\",c),!1!==r.error&&e.on(\"error\",p),e.on(\"close\",d),function(){e.removeListener(\"complete\",c),e.removeListener(\"abort\",d),e.removeListener(\"request\",y),e.req&&e.req.removeListener(\"finish\",c),e.removeListener(\"end\",u),e.removeListener(\"close\",u),e.removeListener(\"finish\",c),e.removeListener(\"end\",h),e.removeListener(\"error\",p),e.removeListener(\"close\",d)}}},167:t=>{t.exports=function(){throw new Error(\"Readable.from is not available in the browser\")}},946:(t,e,r)=>{\"use strict\";var n,i=r(281).q,o=i.ERR_MISSING_ARGS,s=i.ERR_STREAM_DESTROYED;function a(t){if(t)throw t}function u(t,e,i,o){o=function(t){var e=!1;return function(){e||(e=!0,t.apply(void 0,arguments))}}(o);var a=!1;t.on(\"close\",(function(){a=!0})),void 0===n&&(n=r(610)),n(t,{readable:e,writable:i},(function(t){if(t)return o(t);a=!0,o()}));var u=!1;return function(e){if(!a&&!u)return u=!0,function(t){return t.setHeader&&\"function\"==typeof t.abort}(t)?t.abort():\"function\"==typeof t.destroy?t.destroy():void o(e||new s(\"pipe\"))}}function l(t){t()}function c(t,e){return t.pipe(e)}function f(t){return t.length?\"function\"!=typeof t[t.length-1]?a:t.pop():a}t.exports=function(){for(var t=arguments.length,e=new Array(t),r=0;r<t;r++)e[r]=arguments[r];var n,i=f(e);if(Array.isArray(e[0])&&(e=e[0]),e.length<2)throw new o(\"streams\");var s=e.map((function(t,r){var o=r<e.length-1;return u(t,o,r>0,(function(t){n||(n=t),t&&s.forEach(l),o||(s.forEach(l),i(n))}))}));return e.reduce(c)}},457:(t,e,r)=>{\"use strict\";var n=r(281).q.ERR_INVALID_OPT_VALUE;t.exports={getHighWaterMark:function(t,e,r,i){var o=function(t,e,r){return null!=t.highWaterMark?t.highWaterMark:e?t[r]:null}(e,i,r);if(null!=o){if(!isFinite(o)||Math.floor(o)!==o||o<0)throw new n(i?r:\"highWaterMark\",o);return Math.floor(o)}return t.objectMode?16:16384}}},503:(t,e,r)=>{t.exports=r(187).EventEmitter},509:(t,e,r)=>{var n=r(764),i=n.Buffer;function o(t,e){for(var r in t)e[r]=t[r]}function s(t,e,r){return i(t,e,r)}i.from&&i.alloc&&i.allocUnsafe&&i.allocUnsafeSlow?t.exports=n:(o(n,e),e.Buffer=s),s.prototype=Object.create(i.prototype),o(i,s),s.from=function(t,e,r){if(\"number\"==typeof t)throw new TypeError(\"Argument must not be a number\");return i(t,e,r)},s.alloc=function(t,e,r){if(\"number\"!=typeof t)throw new TypeError(\"Argument must be a number\");var n=i(t);return void 0!==e?\"string\"==typeof r?n.fill(e,r):n.fill(e):n.fill(0),n},s.allocUnsafe=function(t){if(\"number\"!=typeof t)throw new TypeError(\"Argument must be a number\");return i(t)},s.allocUnsafeSlow=function(t){if(\"number\"!=typeof t)throw new TypeError(\"Argument must be a number\");return n.SlowBuffer(t)}},830:(t,e,r)=>{t.exports=i;var n=r(187).EventEmitter;function i(){n.call(this)}r(717)(i,n),i.Readable=r(481),i.Writable=r(229),i.Duplex=r(753),i.Transform=r(605),i.PassThrough=r(725),i.finished=r(610),i.pipeline=r(946),i.Stream=i,i.prototype.pipe=function(t,e){var r=this;function i(e){t.writable&&!1===t.write(e)&&r.pause&&r.pause()}function o(){r.readable&&r.resume&&r.resume()}r.on(\"data\",i),t.on(\"drain\",o),t._isStdio||e&&!1===e.end||(r.on(\"end\",a),r.on(\"close\",u));var s=!1;function a(){s||(s=!0,t.end())}function u(){s||(s=!0,\"function\"==typeof t.destroy&&t.destroy())}function l(t){if(c(),0===n.listenerCount(this,\"error\"))throw t}function c(){r.removeListener(\"data\",i),t.removeListener(\"drain\",o),r.removeListener(\"end\",a),r.removeListener(\"close\",u),r.removeListener(\"error\",l),t.removeListener(\"error\",l),r.removeListener(\"end\",c),r.removeListener(\"close\",c),t.removeListener(\"close\",c)}return r.on(\"error\",l),t.on(\"error\",l),r.on(\"end\",c),r.on(\"close\",c),t.on(\"close\",c),t.emit(\"pipe\",r),t}},553:(t,e,r)=>{\"use strict\";var n=r(509).Buffer,i=n.isEncoding||function(t){switch((t=\"\"+t)&&t.toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":case\"raw\":return!0;default:return!1}};function o(t){var e;switch(this.encoding=function(t){var e=function(t){if(!t)return\"utf8\";for(var e;;)switch(t){case\"utf8\":case\"utf-8\":return\"utf8\";case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return\"utf16le\";case\"latin1\":case\"binary\":return\"latin1\";case\"base64\":case\"ascii\":case\"hex\":return t;default:if(e)return;t=(\"\"+t).toLowerCase(),e=!0}}(t);if(\"string\"!=typeof e&&(n.isEncoding===i||!i(t)))throw new Error(\"Unknown encoding: \"+t);return e||t}(t),this.encoding){case\"utf16le\":this.text=u,this.end=l,e=4;break;case\"utf8\":this.fillLast=a,e=4;break;case\"base64\":this.text=c,this.end=f,e=3;break;default:return this.write=h,void(this.end=p)}this.lastNeed=0,this.lastTotal=0,this.lastChar=n.allocUnsafe(e)}function s(t){return t<=127?0:t>>5==6?2:t>>4==14?3:t>>3==30?4:t>>6==2?-1:-2}function a(t){var e=this.lastTotal-this.lastNeed,r=function(t,e,r){if(128!=(192&e[0]))return t.lastNeed=0,\"\";if(t.lastNeed>1&&e.length>1){if(128!=(192&e[1]))return t.lastNeed=1,\"\";if(t.lastNeed>2&&e.length>2&&128!=(192&e[2]))return t.lastNeed=2,\"\"}}(this,t);return void 0!==r?r:this.lastNeed<=t.length?(t.copy(this.lastChar,e,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal)):(t.copy(this.lastChar,e,0,t.length),void(this.lastNeed-=t.length))}function u(t,e){if((t.length-e)%2==0){var r=t.toString(\"utf16le\",e);if(r){var n=r.charCodeAt(r.length-1);if(n>=55296&&n<=56319)return this.lastNeed=2,this.lastTotal=4,this.lastChar[0]=t[t.length-2],this.lastChar[1]=t[t.length-1],r.slice(0,-1)}return r}return this.lastNeed=1,this.lastTotal=2,this.lastChar[0]=t[t.length-1],t.toString(\"utf16le\",e,t.length-1)}function l(t){var e=t&&t.length?this.write(t):\"\";if(this.lastNeed){var r=this.lastTotal-this.lastNeed;return e+this.lastChar.toString(\"utf16le\",0,r)}return e}function c(t,e){var r=(t.length-e)%3;return 0===r?t.toString(\"base64\",e):(this.lastNeed=3-r,this.lastTotal=3,1===r?this.lastChar[0]=t[t.length-1]:(this.lastChar[0]=t[t.length-2],this.lastChar[1]=t[t.length-1]),t.toString(\"base64\",e,t.length-r))}function f(t){var e=t&&t.length?this.write(t):\"\";return this.lastNeed?e+this.lastChar.toString(\"base64\",0,3-this.lastNeed):e}function h(t){return t.toString(this.encoding)}function p(t){return t&&t.length?this.write(t):\"\"}e.s=o,o.prototype.write=function(t){if(0===t.length)return\"\";var e,r;if(this.lastNeed){if(void 0===(e=this.fillLast(t)))return\"\";r=this.lastNeed,this.lastNeed=0}else r=0;return r<t.length?e?e+this.text(t,r):this.text(t,r):e||\"\"},o.prototype.end=function(t){var e=t&&t.length?this.write(t):\"\";return this.lastNeed?e+\"\":e},o.prototype.text=function(t,e){var r=function(t,e,r){var n=e.length-1;if(n<r)return 0;var i=s(e[n]);return i>=0?(i>0&&(t.lastNeed=i-1),i):--n<r||-2===i?0:(i=s(e[n]))>=0?(i>0&&(t.lastNeed=i-2),i):--n<r||-2===i?0:(i=s(e[n]))>=0?(i>0&&(2===i?i=0:t.lastNeed=i-3),i):0}(this,t,e);if(!this.lastNeed)return t.toString(\"utf8\",e);this.lastTotal=r;var n=t.length-(r-this.lastNeed);return t.copy(this.lastChar,0,n),t.toString(\"utf8\",e,n)},o.prototype.fillLast=function(t){if(this.lastNeed<=t.length)return t.copy(this.lastChar,this.lastTotal-this.lastNeed,0,this.lastNeed),this.lastChar.toString(this.encoding,0,this.lastTotal);t.copy(this.lastChar,this.lastTotal-this.lastNeed,0,t.length),this.lastNeed-=t.length}},927:(t,e,r)=>{function n(t){try{if(!r.g.localStorage)return!1}catch(t){return!1}var e=r.g.localStorage[t];return null!=e&&\"true\"===String(e).toLowerCase()}t.exports=function(t,e){if(n(\"noDeprecation\"))return t;var r=!1;return function(){if(!r){if(n(\"throwDeprecation\"))throw new Error(e);n(\"traceDeprecation\")?console.trace(e):console.warn(e),r=!0}return t.apply(this,arguments)}}},669:t=>{\"use strict\";t.exports=e},937:e=>{\"use strict\";if(void 0===t){var r=new Error(\"Cannot find module 'undefined'\");throw r.code=\"MODULE_NOT_FOUND\",r}e.exports=t}},n={};function i(t){if(n[t])return n[t].exports;var e=n[t]={exports:{}};return r[t].call(e.exports,e,e.exports,i),e.exports}i.d=(t,e)=>{for(var r in e)i.o(e,r)&&!i.o(t,r)&&Object.defineProperty(t,r,{enumerable:!0,get:e[r]})},i.g=function(){if(\"object\"==typeof globalThis)return globalThis;try{return this||new Function(\"return this\")()}catch(t){if(\"object\"==typeof window)return window}}(),i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e),i.r=t=>{\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(t,\"__esModule\",{value:!0})};var o={};return(()=>{\"use strict\";i.r(o),i.d(o,{BigNumber:()=>t.BigNumber,Commented:()=>t.Commented,Decoder:()=>t.Decoder,Diagnose:()=>t.Diagnose,Encoder:()=>t.Encoder,Map:()=>t.Map,Simple:()=>t.Simple,Tagged:()=>t.Tagged,comment:()=>t.UI,decode:()=>t.Jx,decodeAll:()=>t.fI,decodeAllSync:()=>t.cc,decodeFirst:()=>t.h8,decodeFirstSync:()=>t.$u,diagnose:()=>t.M,encode:()=>t.cv,encodeAsync:()=>t.WR,encodeCanonical:()=>t.N2,encodeOne:()=>t.TG,hasBigInt:()=>t.vc,leveldb:()=>t.ww});var t=i(141)})(),o})()}));\n\n//# sourceURL=webpack://webpack-demo/./node_modules/cbor-web/dist/cbor.js?");

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n\n//# sourceURL=webpack://webpack-demo/./node_modules/ieee754/index.js?");

/***/ }),

/***/ "./node_modules/node-inspect-extracted/dist/inspect.js":
/*!*************************************************************!*\
  !*** ./node_modules/node-inspect-extracted/dist/inspect.js ***!
  \*************************************************************/
/***/ (function(module) {

eval("!function(t,e){ true?module.exports=e():0}(this,(function(){return(()=>{\"use strict\";var t={255:(t,e)=>{e.l=class{hexSlice(t=0,e){return Array.prototype.map.call(this.slice(t,e),(t=>(\"00\"+t.toString(16)).slice(-2))).join(\"\")}}},48:(t,e,r)=>{const{internalBinding:n,Array:o,ArrayIsArray:i,ArrayPrototypeFilter:l,ArrayPrototypeForEach:c,ArrayPrototypePush:s,ArrayPrototypePushApply:a,ArrayPrototypeSort:p,ArrayPrototypeUnshift:u,BigIntPrototypeValueOf:y,BooleanPrototypeValueOf:f,DatePrototypeGetTime:g,DatePrototypeToISOString:d,DatePrototypeToString:h,ErrorPrototypeToString:b,FunctionPrototypeCall:m,FunctionPrototypeToString:$,JSONStringify:S,MapPrototypeGetSize:x,MapPrototypeEntries:P,MathFloor:O,MathMax:A,MathMin:v,MathRound:j,MathSqrt:w,Number:E,NumberIsNaN:L,NumberParseFloat:F,NumberParseInt:I,NumberPrototypeValueOf:k,Object:R,ObjectAssign:T,ObjectCreate:z,ObjectDefineProperty:N,ObjectGetOwnPropertyDescriptor:B,ObjectGetOwnPropertyNames:M,ObjectGetOwnPropertySymbols:_,ObjectGetPrototypeOf:D,ObjectIs:C,ObjectKeys:G,ObjectPrototypeHasOwnProperty:H,ObjectPrototypePropertyIsEnumerable:W,ObjectSeal:V,ObjectSetPrototypeOf:U,ReflectOwnKeys:Z,RegExp:Y,RegExpPrototypeTest:K,RegExpPrototypeToString:q,SafeStringIterator:J,SafeMap:Q,SafeSet:X,SetPrototypeGetSize:tt,SetPrototypeValues:et,String:rt,StringPrototypeCharCodeAt:nt,StringPrototypeCodePointAt:ot,StringPrototypeIncludes:it,StringPrototypeNormalize:lt,StringPrototypePadEnd:ct,StringPrototypePadStart:st,StringPrototypeRepeat:at,StringPrototypeReplace:pt,StringPrototypeSlice:ut,StringPrototypeSplit:yt,StringPrototypeToLowerCase:ft,StringPrototypeTrim:gt,StringPrototypeValueOf:dt,SymbolPrototypeToString:ht,SymbolPrototypeValueOf:bt,SymbolIterator:mt,SymbolToStringTag:$t,TypedArrayPrototypeGetLength:St,TypedArrayPrototypeGetSymbolToStringTag:xt,Uint8Array:Pt,uncurryThis:Ot}=r(765),{getOwnNonIndexProperties:At,getPromiseDetails:vt,getProxyDetails:jt,kPending:wt,kRejected:Et,previewEntries:Lt,getConstructorName:Ft,getExternalValue:It,propertyFilter:{ALL_PROPERTIES:kt,ONLY_ENUMERABLE:Rt},Proxy:Tt}=r(891),{customInspectSymbol:zt,isError:Nt,join:Bt,removeColors:Mt}=r(335),{codes:{ERR_INVALID_ARG_TYPE:_t},isStackOverflowError:Dt}=r(101),{isAsyncFunction:Ct,isGeneratorFunction:Gt,isAnyArrayBuffer:Ht,isArrayBuffer:Wt,isArgumentsObject:Vt,isBoxedPrimitive:Ut,isDataView:Zt,isExternal:Yt,isMap:Kt,isMapIterator:qt,isModuleNamespaceObject:Jt,isNativeError:Qt,isPromise:Xt,isSet:te,isSetIterator:ee,isWeakMap:re,isWeakSet:ne,isRegExp:oe,isDate:ie,isTypedArray:le,isStringObject:ce,isNumberObject:se,isBooleanObject:ae,isBigIntObject:pe}=r(63),ue=r(183),{NativeModule:ye}=r(992),{validateObject:fe}=r(356);let ge;const de=new X(l(M(r.g),(t=>K(/^[A-Z][a-zA-Z0-9]+$/,t)))),he=t=>void 0===t&&void 0!==t,be=V({showHidden:!1,depth:2,colors:!1,customInspect:!0,showProxy:!1,maxArrayLength:100,maxStringLength:1e4,breakLength:80,compact:3,sorted:!1,getters:!1}),me=/[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]/,$e=/[\\x00-\\x1f\\x27\\x5c\\x7f-\\x9f]/g,Se=/[\\x00-\\x1f\\x5c\\x7f-\\x9f]/,xe=/[\\x00-\\x1f\\x5c\\x7f-\\x9f]/g,Pe=/^[a-zA-Z_][a-zA-Z_0-9]*$/,Oe=/^(0|[1-9][0-9]*)$/,Ae=/^    at (?:[^/\\\\(]+ \\(|)node:(.+):\\d+:\\d+\\)?$/,ve=/^    at (?:[^/\\\\(]+ \\(|)((?<![/\\\\]).+)\\.js:\\d+:\\d+\\)?$/,je=/[/\\\\]node_modules[/\\\\](.+?)(?=[/\\\\])/g,we=/^(\\s+[^(]*?)\\s*{/,Ee=/(\\/\\/.*?\\n)|(\\/\\*(.|\\n)*?\\*\\/)/g,Le=[\"\\\\x00\",\"\\\\x01\",\"\\\\x02\",\"\\\\x03\",\"\\\\x04\",\"\\\\x05\",\"\\\\x06\",\"\\\\x07\",\"\\\\b\",\"\\\\t\",\"\\\\n\",\"\\\\x0B\",\"\\\\f\",\"\\\\r\",\"\\\\x0E\",\"\\\\x0F\",\"\\\\x10\",\"\\\\x11\",\"\\\\x12\",\"\\\\x13\",\"\\\\x14\",\"\\\\x15\",\"\\\\x16\",\"\\\\x17\",\"\\\\x18\",\"\\\\x19\",\"\\\\x1A\",\"\\\\x1B\",\"\\\\x1C\",\"\\\\x1D\",\"\\\\x1E\",\"\\\\x1F\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\\\\'\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\\\\\\\\\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\",\"\\\\x7F\",\"\\\\x80\",\"\\\\x81\",\"\\\\x82\",\"\\\\x83\",\"\\\\x84\",\"\\\\x85\",\"\\\\x86\",\"\\\\x87\",\"\\\\x88\",\"\\\\x89\",\"\\\\x8A\",\"\\\\x8B\",\"\\\\x8C\",\"\\\\x8D\",\"\\\\x8E\",\"\\\\x8F\",\"\\\\x90\",\"\\\\x91\",\"\\\\x92\",\"\\\\x93\",\"\\\\x94\",\"\\\\x95\",\"\\\\x96\",\"\\\\x97\",\"\\\\x98\",\"\\\\x99\",\"\\\\x9A\",\"\\\\x9B\",\"\\\\x9C\",\"\\\\x9D\",\"\\\\x9E\",\"\\\\x9F\"],Fe=new Y(\"[\\\\u001B\\\\u009B][[\\\\]()#;?]*(?:(?:(?:[a-zA-Z\\\\d]*(?:;[-a-zA-Z\\\\d\\\\/#&.:=?%@~_]*)*)?\\\\u0007)|(?:(?:\\\\d{1,4}(?:;\\\\d{0,4})*)?[\\\\dA-PR-TZcf-ntqry=><~]))\",\"g\");let Ie;function ke(t,e){const r={budget:{},indentationLvl:0,seen:[],currentDepth:0,stylize:De,showHidden:be.showHidden,depth:be.depth,colors:be.colors,customInspect:be.customInspect,showProxy:be.showProxy,maxArrayLength:be.maxArrayLength,maxStringLength:be.maxStringLength,breakLength:be.breakLength,compact:be.compact,sorted:be.sorted,getters:be.getters};if(arguments.length>1)if(arguments.length>2&&(void 0!==arguments[2]&&(r.depth=arguments[2]),arguments.length>3&&void 0!==arguments[3]&&(r.colors=arguments[3])),\"boolean\"==typeof e)r.showHidden=e;else if(e){const t=G(e);for(let n=0;n<t.length;++n){const o=t[n];H(be,o)||\"stylize\"===o?r[o]=e[o]:void 0===r.userOptions&&(r.userOptions=e)}}return r.colors&&(r.stylize=_e),null===r.maxArrayLength&&(r.maxArrayLength=1/0),null===r.maxStringLength&&(r.maxStringLength=1/0),Ye(r,t,0)}ke.custom=zt,N(ke,\"defaultOptions\",{get:()=>be,set:t=>(fe(t,\"options\"),T(be,t))});const Re=39,Te=49;function ze(t,e){N(ke.colors,e,{get(){return this[t]},set(e){this[t]=e},configurable:!0,enumerable:!1})}function Ne(t,e){return-1===e?`\"${t}\"`:-2===e?`\\`${t}\\``:`'${t}'`}ke.colors=T(z(null),{reset:[0,0],bold:[1,22],dim:[2,22],italic:[3,23],underline:[4,24],blink:[5,25],inverse:[7,27],hidden:[8,28],strikethrough:[9,29],doubleunderline:[21,24],black:[30,Re],red:[31,Re],green:[32,Re],yellow:[33,Re],blue:[34,Re],magenta:[35,Re],cyan:[36,Re],white:[37,Re],bgBlack:[40,Te],bgRed:[41,Te],bgGreen:[42,Te],bgYellow:[43,Te],bgBlue:[44,Te],bgMagenta:[45,Te],bgCyan:[46,Te],bgWhite:[47,Te],framed:[51,54],overlined:[53,55],gray:[90,Re],redBright:[91,Re],greenBright:[92,Re],yellowBright:[93,Re],blueBright:[94,Re],magentaBright:[95,Re],cyanBright:[96,Re],whiteBright:[97,Re],bgGray:[100,Te],bgRedBright:[101,Te],bgGreenBright:[102,Te],bgYellowBright:[103,Te],bgBlueBright:[104,Te],bgMagentaBright:[105,Te],bgCyanBright:[106,Te],bgWhiteBright:[107,Te]}),ze(\"gray\",\"grey\"),ze(\"gray\",\"blackBright\"),ze(\"bgGray\",\"bgGrey\"),ze(\"bgGray\",\"bgBlackBright\"),ze(\"dim\",\"faint\"),ze(\"strikethrough\",\"crossedout\"),ze(\"strikethrough\",\"strikeThrough\"),ze(\"strikethrough\",\"crossedOut\"),ze(\"hidden\",\"conceal\"),ze(\"inverse\",\"swapColors\"),ze(\"inverse\",\"swapcolors\"),ze(\"doubleunderline\",\"doubleUnderline\"),ke.styles=T(z(null),{special:\"cyan\",number:\"yellow\",bigint:\"yellow\",boolean:\"yellow\",undefined:\"grey\",null:\"bold\",string:\"green\",symbol:\"green\",date:\"magenta\",regexp:\"red\",module:\"underline\"});const Be=t=>Le[nt(t)];function Me(t){let e=me,r=$e,n=39;if(it(t,\"'\")&&(it(t,'\"')?it(t,\"`\")||it(t,\"${\")||(n=-2):n=-1,39!==n&&(e=Se,r=xe)),t.length<5e3&&!K(e,t))return Ne(t,n);if(t.length>100)return Ne(t=pt(t,r,Be),n);let o=\"\",i=0;const l=t.length;for(let e=0;e<l;e++){const r=nt(t,e);(r===n||92===r||r<32||r>126&&r<160)&&(o+=i===e?Le[r]:`${ut(t,i,e)}${Le[r]}`,i=e+1)}return i!==l&&(o+=ut(t,i)),Ne(o,n)}function _e(t,e){const r=ke.styles[e];if(void 0!==r){const e=ke.colors[r];if(void 0!==e)return`\u001b[${e[0]}m${t}\u001b[${e[1]}m`}return t}function De(t){return t}function Ce(){return[]}function Ge(t,e){try{return t instanceof e}catch{return!1}}function He(t,e,r,n){let o;const i=t;for(;t||he(t);){const l=B(t,\"constructor\");if(void 0!==l&&\"function\"==typeof l.value&&\"\"!==l.value.name&&Ge(i,l.value))return void 0===n||o===t&&de.has(l.value.name)||We(e,i,o||i,r,n),l.value.name;t=D(t),void 0===o&&(o=t)}if(null===o)return null;const l=Ft(i);if(r>e.depth&&null!==e.depth)return`${l} <Complex prototype>`;const c=He(o,e,r+1,n);return null===c?`${l} <${ke(o,{...e,customInspect:!1,depth:-1})}>`:`${l} <${c}>`}function We(t,e,r,n,o){let i,l,a=0;do{if(0!==a||e===r){if(null===(r=D(r)))return;const t=B(r,\"constructor\");if(void 0!==t&&\"function\"==typeof t.value&&de.has(t.value.name))return}0===a?l=new X:c(i,(t=>l.add(t))),i=Z(r);for(const c of i){if(\"constructor\"===c||H(e,c)||0!==a&&l.has(c))continue;const i=B(r,c);if(\"function\"==typeof i.value)continue;const p=fr(t,r,n,c,0,i,e);t.colors?s(o,`\u001b[2m${p}\u001b[22m`):s(o,p)}}while(3!=++a)}function Ve(t,e,r,n=\"\"){return null===t?\"\"!==e&&r!==e?`[${r}${n}: null prototype] [${e}] `:`[${r}${n}: null prototype] `:\"\"!==e&&t!==e?`${t}${n} [${e}] `:`${t}${n} `}function Ue(t,e){let r;const n=_(t);if(e)r=M(t),0!==n.length&&a(r,n);else{try{r=G(t)}catch(e){ue(Qt(e)&&\"ReferenceError\"===e.name&&Jt(t)),r=M(t)}0!==n.length&&a(r,l(n,(e=>W(t,e))))}return r}function Ze(t,e,r){let n=\"\";return null===e&&(n=Ft(t),n===r&&(n=\"Object\")),Ve(e,r,n)}function Ye(t,e,r,n){if(\"object\"!=typeof e&&\"function\"!=typeof e&&!he(e))return Qe(t.stylize,e,t);if(null===e)return t.stylize(\"null\",\"null\");const o=e,l=jt(e,!!t.showProxy);if(void 0!==l){if(t.showProxy)return function(t,e,r){if(r>t.depth&&null!==t.depth)return t.stylize(\"Proxy [Array]\",\"special\");r+=1,t.indentationLvl+=2;const n=[Ye(t,e[0],r),Ye(t,e[1],r)];return t.indentationLvl-=2,dr(t,n,\"\",[\"Proxy [\",\"]\"],2,r)}(t,l,r);e=l}if(t.customInspect){const n=e[zt];if(\"function\"==typeof n&&n!==ke&&(!e.constructor||e.constructor.prototype!==e)){const e=null===t.depth?null:t.depth-r,i=m(n,o,e,function(t,e){const r={stylize:t.stylize,showHidden:t.showHidden,depth:t.depth,colors:t.colors,customInspect:t.customInspect,showProxy:t.showProxy,maxArrayLength:t.maxArrayLength,maxStringLength:t.maxStringLength,breakLength:t.breakLength,compact:t.compact,sorted:t.sorted,getters:t.getters,...t.userOptions};if(e){U(r,null);for(const t of G(r))\"object\"!=typeof r[t]&&\"function\"!=typeof r[t]||null===r[t]||delete r[t];r.stylize=U(((e,r)=>{let n;try{n=`${t.stylize(e,r)}`}catch{}return\"string\"!=typeof n?e:n}),null)}return r}(t,void 0!==l||!(o instanceof R)));if(i!==o)return\"string\"!=typeof i?Ye(t,i,r):i.replace(/\\n/g,`\\n${\" \".repeat(t.indentationLvl)}`)}}if(t.seen.includes(e)){let r=1;return void 0===t.circular?(t.circular=new Q,t.circular.set(e,r)):(r=t.circular.get(e),void 0===r&&(r=t.circular.size+1,t.circular.set(e,r))),t.stylize(`[Circular *${r}]`,\"special\")}return function(t,e,r,n){let o,l;t.showHidden&&(r<=t.depth||null===t.depth)&&(l=[]);const c=He(e,t,r,l);void 0!==l&&0===l.length&&(l=void 0);let s=e[$t];(\"string\"!=typeof s||\"\"!==s&&(t.showHidden?H:W)(e,$t))&&(s=\"\");let a,p=\"\",m=Ce,S=!0,O=0;const A=t.showHidden?kt:Rt;let v,j=0;if(e[mt]||null===c)if(S=!1,i(e)){const t=\"Array\"!==c||\"\"!==s?Ve(c,s,\"Array\",`(${e.length})`):\"\";if(o=At(e,A),a=[`${t}[`,\"]\"],0===e.length&&0===o.length&&void 0===l)return`${a[0]}]`;j=2,m=rr}else if(te(e)){const r=tt(e),n=Ve(c,s,\"Set\",`(${r})`);if(o=Ue(e,t.showHidden),m=null!==c?or.bind(null,e):or.bind(null,et(e)),0===r&&0===o.length&&void 0===l)return`${n}{}`;a=[`${n}{`,\"}\"]}else if(Kt(e)){const r=x(e),n=Ve(c,s,\"Map\",`(${r})`);if(o=Ue(e,t.showHidden),m=null!==c?ir.bind(null,e):ir.bind(null,P(e)),0===r&&0===o.length&&void 0===l)return`${n}{}`;a=[`${n}{`,\"}\"]}else if(le(e)){o=At(e,A);let r=e,n=\"\";null===c&&(n=xt(e),r=new n(e));const i=St(e);if(a=[`${Ve(c,s,n,`(${i})`)}[`,\"]\"],0===e.length&&0===o.length&&!t.showHidden)return`${a[0]}]`;m=nr.bind(null,r,i),j=2}else qt(e)?(o=Ue(e,t.showHidden),a=Ke(\"Map\",s),m=ur.bind(null,a)):ee(e)?(o=Ue(e,t.showHidden),a=Ke(\"Set\",s),m=ur.bind(null,a)):S=!0;if(S)if(o=Ue(e,t.showHidden),a=[\"{\",\"}\"],\"Object\"===c){if(Vt(e)?a[0]=\"[Arguments] {\":\"\"!==s&&(a[0]=`${Ve(c,s,\"Object\")}{`),0===o.length&&void 0===l)return`${a[0]}}`}else if(\"function\"==typeof e){if(p=function(t,e,r){const n=$(t);if(\"class\"===n.slice(0,5)&&n.endsWith(\"}\")){const o=n.slice(5,-1),i=o.indexOf(\"{\");if(-1!==i&&(!o.slice(0,i).includes(\"(\")||we.test(o.replace(Ee))))return function(t,e,r){let n=`class ${H(t,\"name\")&&t.name||\"(anonymous)\"}`;if(\"Function\"!==e&&null!==e&&(n+=` [${e}]`),\"\"!==r&&e!==r&&(n+=` [${r}]`),null!==e){const e=D(t).name;e&&(n+=` extends ${e}`)}else n+=\" extends [null prototype]\";return`[${n}]`}(t,e,r)}let o=\"Function\";Gt(t)&&(o=`Generator${o}`),Ct(t)&&(o=`Async${o}`);let i=`[${o}`;return null===e&&(i+=\" (null prototype)\"),\"\"===t.name?i+=\" (anonymous)\":i+=`: ${t.name}`,i+=\"]\",e!==o&&null!==e&&(i+=` ${e}`),\"\"!==r&&e!==r&&(i+=` [${r}]`),i}(e,c,s),0===o.length&&void 0===l)return t.stylize(p,\"special\")}else if(oe(e)){p=q(null!==c?e:new Y(e));const n=Ve(c,s,\"RegExp\");if(\"RegExp \"!==n&&(p=`${n}${p}`),0===o.length&&void 0===l||r>t.depth&&null!==t.depth)return t.stylize(p,\"regexp\")}else if(ie(e)){p=L(g(e))?h(e):d(e);const r=Ve(c,s,\"Date\");if(\"Date \"!==r&&(p=`${r}${p}`),0===o.length&&void 0===l)return t.stylize(p,\"date\")}else if(Nt(e)){if(p=function(t,e,r,n,o){const i=null!=t.name?rt(t.name):\"Error\";let l=i.length,c=t.stack?rt(t.stack):b(t);if(!n.showHidden&&0!==o.length)for(const e of[\"name\",\"message\",\"stack\"]){const r=o.indexOf(e);-1!==r&&c.includes(t[e])&&o.splice(r,1)}if(null===e||i.endsWith(\"Error\")&&c.startsWith(i)&&(c.length===l||\":\"===c[l]||\"\\n\"===c[l])){let t=\"Error\";if(null===e){const e=c.match(/^([A-Z][a-z_ A-Z0-9[\\]()-]+)(?::|\\n {4}at)/)||c.match(/^([a-z_A-Z0-9-]*Error)$/);t=e&&e[1]||\"\",l=t.length,t=t||\"Error\"}const n=Ve(e,r,t).slice(0,-1);i!==n&&(c=n.includes(i)?0===l?`${n}: ${c}`:`${n}${c.slice(l)}`:`${n} [${i}]${c.slice(l)}`)}let s=t.message&&c.indexOf(t.message)||-1;-1!==s&&(s+=t.message.length);const a=c.indexOf(\"\\n    at\",s);if(-1===a)c=`[${c}]`;else if(n.colors){let t=c.slice(0,a);const e=c.slice(a+1).split(\"\\n\");for(const r of e){const e=r.match(Ae)||r.match(ve);if(null!==e&&ye.exists(e[1]))t+=`\\n${n.stylize(r,\"undefined\")}`;else{let e;t+=\"\\n\";let o=0;for(;e=je.exec(r);)t+=r.slice(o,e.index+14),t+=n.stylize(e[1],\"module\"),o=e.index+e[0].length;t+=0===o?r:r.slice(o)}}c=t}if(0!==n.indentationLvl){const t=\" \".repeat(n.indentationLvl);c=c.replace(/\\n/g,`\\n${t}`)}return c}(e,c,s,t,o),0===o.length&&void 0===l)return p}else if(Ht(e)){const r=Ve(c,s,Wt(e)?\"ArrayBuffer\":\"SharedArrayBuffer\");if(void 0===n)m=er;else if(0===o.length&&void 0===l)return r+`{ byteLength: ${qe(t.stylize,e.byteLength)} }`;a[0]=`${r}{`,u(o,\"byteLength\")}else if(Zt(e))a[0]=`${Ve(c,s,\"DataView\")}{`,u(o,\"byteLength\",\"byteOffset\",\"buffer\");else if(Xt(e))a[0]=`${Ve(c,s,\"Promise\")}{`,m=yr;else if(ne(e))a[0]=`${Ve(c,s,\"WeakSet\")}{`,m=t.showHidden?ar:sr;else if(re(e))a[0]=`${Ve(c,s,\"WeakMap\")}{`,m=t.showHidden?pr:sr;else if(Jt(e))a[0]=`${Ve(c,s,\"Module\")}{`,m=Xe.bind(null,o);else if(Ut(e)){if(p=function(t,e,r,n,o){let i,l;se(t)?(i=k,l=\"Number\"):ce(t)?(i=dt,l=\"String\",r.splice(0,t.length)):ae(t)?(i=f,l=\"Boolean\"):pe(t)?(i=y,l=\"BigInt\"):(i=bt,l=\"Symbol\");let c=`[${l}`;return l!==n&&(c+=null===n?\" (null prototype)\":` (${n})`),c+=`: ${Qe(De,i(t),e)}]`,\"\"!==o&&o!==n&&(c+=` [${o}]`),0!==r.length||e.stylize===De?c:e.stylize(c,ft(l))}(e,t,o,c,s),0===o.length&&void 0===l)return p}else{if(0===o.length&&void 0===l){if(Yt(e)){const r=It(e).toString(16);return t.stylize(`[External: ${r}]`,\"special\")}return`${Ze(e,c,s)}{}`}a[0]=`${Ze(e,c,s)}{`}if(r>t.depth&&null!==t.depth){let r=Ze(e,c,s).slice(0,-1);return null!==c&&(r=`[${r}]`),t.stylize(r,\"special\")}r+=1,t.seen.push(e),t.currentDepth=r;const w=t.indentationLvl;try{for(v=m(t,e,r),O=0;O<o.length;O++)v.push(fr(t,e,r,o[O],j));void 0!==l&&v.push(...l)}catch(r){return function(t,e,r,n){if(Dt(e))return t.seen.pop(),t.indentationLvl=n,t.stylize(`[${r}: Inspection interrupted prematurely. Maximum call stack size exceeded.]`,\"special\");throw e}(t,r,Ze(e,c,s).slice(0,-1),w)}if(void 0!==t.circular){const r=t.circular.get(e);if(void 0!==r){const e=t.stylize(`<ref *${r}>`,\"special\");!0!==t.compact?p=\"\"===p?e:`${e} ${p}`:a[0]=`${e} ${a[0]}`}}if(t.seen.pop(),t.sorted){const e=!0===t.sorted?void 0:t.sorted;if(0===j)v=v.sort(e);else if(o.length>1){const t=v.slice(v.length-o.length).sort(e);v.splice(v.length-o.length,o.length,...t)}}const E=dr(t,v,p,a,j,r,e),F=(t.budget[t.indentationLvl]||0)+E.length;return t.budget[t.indentationLvl]=F,F>2**27&&(t.depth=-1),E}(t,e,r,n)}function Ke(t,e){return e!==`${t} Iterator`&&(\"\"!==e&&(e+=\"] [\"),e+=`${t} Iterator`),[`[${e}] {`,\"}\"]}function qe(t,e){return t(C(e,-0)?\"-0\":`${e}`,\"number\")}function Je(t,e){return t(`${e}n`,\"bigint\")}function Qe(t,e,r){if(\"string\"==typeof e){let n=\"\";if(e.length>r.maxStringLength){const t=e.length-r.maxStringLength;e=e.slice(0,r.maxStringLength),n=`... ${t} more character${t>1?\"s\":\"\"}`}return!0!==r.compact&&e.length>16&&e.length>r.breakLength-r.indentationLvl-4?e.split(/(?<=\\n)/).map((e=>t(Me(e),\"string\"))).join(` +\\n${\" \".repeat(r.indentationLvl+2)}`)+n:t(Me(e),\"string\")+n}return\"number\"==typeof e?qe(t,e):\"bigint\"==typeof e?Je(t,e):\"boolean\"==typeof e?t(`${e}`,\"boolean\"):void 0===e?t(\"undefined\",\"undefined\"):t(ht(e),\"symbol\")}function Xe(t,e,r,n){const i=new o(t.length);for(let o=0;o<t.length;o++)try{i[o]=fr(e,r,n,t[o],0)}catch(r){if(!Qt(r)||\"ReferenceError\"!==r.name)throw r;const l={[t[o]]:\"\"};i[o]=fr(e,l,n,t[o],0);const c=i[o].lastIndexOf(\" \");i[o]=i[o].slice(0,c+1)+e.stylize(\"<uninitialized>\",\"special\")}return t.length=0,i}function tr(t,e,r,n,o,i){const l=G(e);let c=i;for(;i<l.length&&o.length<n;i++){const s=l[i],a=+s;if(a>2**32-2)break;if(`${c}`!==s){if(!Oe.test(s))break;const e=a-c,r=`<${e} empty item${e>1?\"s\":\"\"}>`;if(o.push(t.stylize(r,\"undefined\")),c=a,o.length===n)break}o.push(fr(t,e,r,s,1)),c++}const s=e.length-c;if(o.length!==n){if(s>0){const e=`<${s} empty item${s>1?\"s\":\"\"}>`;o.push(t.stylize(e,\"undefined\"))}}else s>0&&o.push(`... ${s} more item${s>1?\"s\":\"\"}`);return o}function er(t,e){let n;try{n=new Pt(e)}catch{return[t.stylize(\"(detached)\",\"special\")]}void 0===ge&&(ge=Ot(r(255).l.prototype.hexSlice));let o=gt(pt(ge(n,0,v(t.maxArrayLength,n.length)),/(.{2})/g,\"$1 \"));const i=n.length-t.maxArrayLength;return i>0&&(o+=` ... ${i} more byte${i>1?\"s\":\"\"}`),[`${t.stylize(\"[Uint8Contents]\",\"special\")}: <${o}>`]}function rr(t,e,r){const n=e.length,o=v(A(0,t.maxArrayLength),n),i=n-o,l=[];for(let n=0;n<o;n++){if(!H(e,n))return tr(t,e,r,o,l,n);l.push(fr(t,e,r,n,1))}return i>0&&l.push(`... ${i} more item${i>1?\"s\":\"\"}`),l}function nr(t,e,r,n,i){const l=v(A(0,r.maxArrayLength),e),c=t.length-l,a=new o(l),p=t.length>0&&\"number\"==typeof t[0]?qe:Je;for(let e=0;e<l;++e)a[e]=p(r.stylize,t[e]);if(c>0&&(a[l]=`... ${c} more item${c>1?\"s\":\"\"}`),r.showHidden){r.indentationLvl+=2;for(const e of[\"BYTES_PER_ELEMENT\",\"length\",\"byteLength\",\"byteOffset\",\"buffer\"]){const n=Ye(r,t[e],i,!0);s(a,`[${e}]: ${n}`)}r.indentationLvl-=2}return a}function or(t,e,r,n){const o=[];e.indentationLvl+=2;for(const r of t)s(o,Ye(e,r,n));return e.indentationLvl-=2,o}function ir(t,e,r,n){const o=[];e.indentationLvl+=2;for(const[r,i]of t)o.push(`${Ye(e,r,n)} => `+Ye(e,i,n));return e.indentationLvl-=2,o}function lr(t,e,r,n){const i=A(t.maxArrayLength,0),l=v(i,r.length),c=new o(l);t.indentationLvl+=2;for(let n=0;n<l;n++)c[n]=Ye(t,r[n],e);t.indentationLvl-=2,0!==n||t.sorted||p(c);const a=r.length-l;return a>0&&s(c,`... ${a} more item${a>1?\"s\":\"\"}`),c}function cr(t,e,r,n){const i=A(t.maxArrayLength,0),l=r.length/2,c=l-i,s=v(i,l);let a=new o(s),p=0;if(t.indentationLvl+=2,0===n){for(;p<s;p++){const n=2*p;a[p]=`${Ye(t,r[n],e)} => ${Ye(t,r[n+1],e)}`}t.sorted||(a=a.sort())}else for(;p<s;p++){const n=2*p,o=[Ye(t,r[n],e),Ye(t,r[n+1],e)];a[p]=dr(t,o,\"\",[\"[\",\"]\"],2,e)}return t.indentationLvl-=2,c>0&&a.push(`... ${c} more item${c>1?\"s\":\"\"}`),a}function sr(t){return[t.stylize(\"<items unknown>\",\"special\")]}function ar(t,e,r){return lr(t,r,Lt(e),0)}function pr(t,e,r){return cr(t,r,Lt(e),0)}function ur(t,e,r,n){const[o,i]=Lt(r,!0);return i?(t[0]=t[0].replace(/ Iterator] {$/,\" Entries] {\"),cr(e,n,o,2)):lr(e,n,o,1)}function yr(t,e,r){let n;const[o,i]=vt(e);if(o===wt)n=[t.stylize(\"<pending>\",\"special\")];else{t.indentationLvl+=2;const e=Ye(t,i,r);t.indentationLvl-=2,n=[o===Et?`${t.stylize(\"<rejected>\",\"special\")} ${e}`:e]}return n}function fr(t,e,r,n,o,i,l=e){let c,s,a=\" \";if(void 0!==(i=i||B(e,n)||{value:e[n],enumerable:!0}).value){const e=!0!==t.compact||0!==o?2:3;t.indentationLvl+=e,s=Ye(t,i.value,r),3===e&&t.breakLength<Ie(s,t.colors)&&(a=`\\n${\" \".repeat(t.indentationLvl)}`),t.indentationLvl-=e}else if(void 0!==i.get){const e=void 0!==i.set?\"Getter/Setter\":\"Getter\",n=t.stylize,o=\"special\";if(t.getters&&(!0===t.getters||\"get\"===t.getters&&void 0===i.set||\"set\"===t.getters&&void 0!==i.set))try{const c=m(i.get,l);if(t.indentationLvl+=2,null===c)s=`${n(`[${e}:`,o)} ${n(\"null\",\"null\")}${n(\"]\",o)}`;else if(\"object\"==typeof c)s=`${n(`[${e}]`,o)} ${Ye(t,c,r)}`;else{const r=Qe(n,c,t);s=`${n(`[${e}:`,o)} ${r}${n(\"]\",o)}`}t.indentationLvl-=2}catch(t){const r=`<Inspection threw (${t.message})>`;s=`${n(`[${e}:`,o)} ${r}${n(\"]\",o)}`}else s=t.stylize(`[${e}]`,o)}else s=void 0!==i.set?t.stylize(\"[Setter]\",\"special\"):t.stylize(\"undefined\",\"undefined\");if(1===o)return s;if(\"symbol\"==typeof n){const e=pt(ht(n),$e,Be);c=`[${t.stylize(e,\"symbol\")}]`}else c=!1===i.enumerable?`[${pt(n,$e,Be)}]`:K(Pe,n)?t.stylize(n,\"name\"):t.stylize(Me(n),\"string\");return`${c}:${a}${s}`}function gr(t,e,r,n){let o=e.length+r;if(o+e.length>t.breakLength)return!1;for(let r=0;r<e.length;r++)if(t.colors?o+=Mt(e[r]).length:o+=e[r].length,o>t.breakLength)return!1;return\"\"===n||!it(n,\"\\n\")}function dr(t,e,r,n,i,l,c){if(!0!==t.compact){if(\"number\"==typeof t.compact&&t.compact>=1){const a=e.length;if(2===i&&a>6&&(e=function(t,e,r){let n=0,i=0,l=0,c=e.length;t.maxArrayLength<e.length&&c--;const a=new o(c);for(;l<c;l++){const r=Ie(e[l],t.colors);a[l]=r,n+=r+2,i<r&&(i=r)}const p=i+2;if(3*p+t.indentationLvl<t.breakLength&&(n/p>5||i<=6)){const o=2.5,i=w(p-n/e.length),l=A(p-3-i,1),u=v(j(w(o*l*c)/l),O((t.breakLength-t.indentationLvl)/p),4*t.compact,15);if(u<=1)return e;const y=[],f=[];for(let t=0;t<u;t++){let r=0;for(let n=t;n<e.length;n+=u)a[n]>r&&(r=a[n]);r+=2,f[t]=r}let g=st;if(void 0!==r)for(let t=0;t<e.length;t++)if(\"number\"!=typeof r[t]&&\"bigint\"!=typeof r[t]){g=ct;break}for(let t=0;t<c;t+=u){const r=v(t+u,c);let n=\"\",o=t;for(;o<r-1;o++){const r=f[o-t]+e[o].length-a[o];n+=g(`${e[o]}, `,r,\" \")}if(g===st){const r=f[o-t]+e[o].length-a[o]-2;n+=st(e[o],r,\" \")}else n+=e[o];s(y,n)}t.maxArrayLength<e.length&&s(y,e[c]),e=y}return e}(t,e,c)),t.currentDepth-l<t.compact&&a===e.length&&gr(t,e,e.length+t.indentationLvl+n[0].length+r.length+10,r))return`${r?`${r} `:\"\"}${n[0]} ${Bt(e,\", \")} ${n[1]}`}const a=`\\n${at(\" \",t.indentationLvl)}`;return`${r?`${r} `:\"\"}${n[0]}${a}  ${Bt(e,`,${a}  `)}${a}${n[1]}`}if(gr(t,e,0,r))return`${n[0]}${r?` ${r}`:\"\"} ${Bt(e,\", \")} `+n[1];const a=at(\" \",t.indentationLvl),p=\"\"===r&&1===n[0].length?\" \":`${r?` ${r}`:\"\"}\\n${a}  `;return`${n[0]}${p}${Bt(e,`,\\n${a}  `)} ${n[1]}`}function hr(t){const e=jt(t,!1);if(void 0!==e&&(t=e),\"function\"!=typeof t.toString)return!0;if(H(t,\"toString\"))return!1;let r=t;do{r=D(r)}while(!H(r,\"toString\"));const n=B(r,\"constructor\");return void 0!==n&&\"function\"==typeof n.value&&de.has(n.value.name)}const br=t=>yt(t.message,\"\\n\",1)[0];let mr;function $r(t){try{return S(t)}catch(t){if(!mr)try{const t={};t.a=t,S(t)}catch(t){mr=br(t)}if(\"TypeError\"===t.name&&br(t)===mr)return\"[Circular]\";throw t}}function Sr(t,e){const r=e[0];let n=0,o=\"\",i=\"\";if(\"string\"==typeof r){if(1===e.length)return r;let l,c=0;for(let i=0;i<r.length-1;i++)if(37===nt(r,i)){const s=nt(r,++i);if(n+1!==e.length){switch(s){case 115:const s=e[++n];l=\"number\"==typeof s?qe(De,s):\"bigint\"==typeof s?`${s}n`:\"object\"==typeof s&&null!==s&&hr(s)?ke(s,{...t,compact:3,colors:!1,depth:0}):rt(s);break;case 106:l=$r(e[++n]);break;case 100:const a=e[++n];l=\"bigint\"==typeof a?`${a}n`:\"symbol\"==typeof a?\"NaN\":qe(De,E(a));break;case 79:l=ke(e[++n],t);break;case 111:l=ke(e[++n],{...t,showHidden:!0,showProxy:!0,depth:4});break;case 105:const p=e[++n];l=\"bigint\"==typeof p?`${p}n`:\"symbol\"==typeof p?\"NaN\":qe(De,I(p));break;case 102:const u=e[++n];l=\"symbol\"==typeof u?\"NaN\":qe(De,F(u));break;case 99:n+=1,l=\"\";break;case 37:o+=ut(r,c,i),c=i+1;continue;default:continue}c!==i-1&&(o+=ut(r,c,i-1)),o+=l,c=i+1}else 37===s&&(o+=ut(r,c,i),c=i+1)}0!==c&&(n++,i=\" \",c<r.length&&(o+=ut(r,c)))}for(;n<e.length;){const r=e[n];o+=i,o+=\"string\"!=typeof r?ke(r,t):r,i=\" \",n++}return o}if(n(\"config\").hasIntl){const t=n(\"icu\");Ie=function(e,r=!0){let n=0;r&&(e=xr(e));for(let r=0;r<e.length;r++){const o=e.charCodeAt(r);if(o>=127){n+=t.getStringWidth(e.slice(r).normalize(\"NFC\"));break}n+=o>=32?1:0}return n}}else{Ie=function(r,n=!0){let o=0;n&&(r=xr(r)),r=lt(r,\"NFC\");for(const n of new J(r)){const r=ot(n,0);t(r)?o+=2:e(r)||o++}return o};const t=t=>t>=4352&&(t<=4447||9001===t||9002===t||t>=11904&&t<=12871&&12351!==t||t>=12880&&t<=19903||t>=19968&&t<=42182||t>=43360&&t<=43388||t>=44032&&t<=55203||t>=63744&&t<=64255||t>=65040&&t<=65049||t>=65072&&t<=65131||t>=65281&&t<=65376||t>=65504&&t<=65510||t>=110592&&t<=110593||t>=127488&&t<=127569||t>=127744&&t<=128591||t>=131072&&t<=262141),e=t=>t<=31||t>=127&&t<=159||t>=768&&t<=879||t>=8203&&t<=8207||t>=8400&&t<=8447||t>=65024&&t<=65039||t>=65056&&t<=65071||t>=917760&&t<=917999}function xr(t){return t.replace(Fe,\"\")}t.exports={inspect:ke,format:function(...t){return Sr(void 0,t)},formatWithOptions:function(t,...e){if(\"object\"!=typeof t||null===t)throw new _t(\"inspectOptions\",\"object\",t);return Sr(t,e)},stylizeWithColor:_e,stylizeWithHTML(t,e){const r=ke.styles[e];return void 0!==r?`<span style=\"color:${r};\">${t}</span>`:t},Proxy:Tt}},183:t=>{t.exports=function(t){if(!t)throw new Error(\"Assertion failed\")}},992:(t,e)=>{e.NativeModule={exists:t=>!t.startsWith(\"/\")}},101:(t,e,r)=>{const{ArrayIsArray:n,ArrayPrototypeIncludes:o,ArrayPrototypeIndexOf:i,ArrayPrototypeJoin:l,ArrayPrototypePop:c,ArrayPrototypePush:s,ArrayPrototypeSplice:a,ErrorCaptureStackTrace:p,ObjectDefineProperty:u,ReflectApply:y,RegExpPrototypeTest:f,SafeMap:g,StringPrototypeEndsWith:d,StringPrototypeIncludes:h,StringPrototypeSlice:b,StringPrototypeToLowerCase:m}=r(765),$=new g,S={},x=/^([A-Z][a-z0-9]*)+$/,P=[\"string\",\"function\",\"number\",\"object\",\"Function\",\"Object\",\"boolean\",\"bigint\",\"symbol\"];let O,A,v=null;function j(){return v||(v=r(48)),v}const w=E((function(t,e,r){(t=L(t)).name=`${e} [${r}]`,t.stack,delete t.name}));function E(t){const e=\"__node_internal_\"+t.name;return u(t,\"name\",{value:e}),t}const L=E((function(t){return O=Error.stackTraceLimit,Error.stackTraceLimit=1/0,p(t),Error.stackTraceLimit=O,t}));let F,I;var k,R,T,z,N;t.exports={codes:S,hideStackFrames:E,isStackOverflowError:function(t){if(void 0===I)try{!function t(){t()}()}catch(t){I=t.message,F=t.name}return t&&t.name===F&&t.message===I}},k=\"ERR_INVALID_ARG_TYPE\",R=(t,e,r)=>{A(\"string\"==typeof t,\"'name' must be a string\"),n(e)||(e=[e]);let p=\"The \";d(t,\" argument\")?p+=`${t} `:p+=`\"${t}\" ${h(t,\".\")?\"property\":\"argument\"} `,p+=\"must be \";const u=[],y=[],g=[];for(const t of e)A(\"string\"==typeof t,\"All expected entries have to be of type string\"),o(P,t)?s(u,m(t)):f(x,t)?s(y,t):(A(\"object\"!==t,'The value \"object\" should be written as \"Object\"'),s(g,t));if(y.length>0){const t=i(u,\"object\");-1!==t&&(a(u,t,1),s(y,\"Object\"))}if(u.length>0){if(u.length>2){const t=c(u);p+=`one of type ${l(u,\", \")}, or ${t}`}else p+=2===u.length?`one of type ${u[0]} or ${u[1]}`:`of type ${u[0]}`;(y.length>0||g.length>0)&&(p+=\" or \")}if(y.length>0){if(y.length>2){const t=c(y);p+=`an instance of ${l(y,\", \")}, or ${t}`}else p+=`an instance of ${y[0]}`,2===y.length&&(p+=` or ${y[1]}`);g.length>0&&(p+=\" or \")}if(g.length>0)if(g.length>2){const t=c(g);p+=`one of ${l(g,\", \")}, or ${t}`}else 2===g.length?p+=`one of ${g[0]} or ${g[1]}`:(m(g[0])!==g[0]&&(p+=\"an \"),p+=`${g[0]}`);if(null==r)p+=`. Received ${r}`;else if(\"function\"==typeof r&&r.name)p+=`. Received function ${r.name}`;else if(\"object\"==typeof r)r.constructor&&r.constructor.name?p+=`. Received an instance of ${r.constructor.name}`:p+=`. Received ${j().inspect(r,{depth:-1})}`;else{let t=j().inspect(r,{colors:!1});t.length>25&&(t=`${b(t,0,25)}...`),p+=`. Received type ${typeof r} (${t})`}return p},T=TypeError,$.set(k,R),S[k]=(z=T,N=k,function(...t){const e=Error.stackTraceLimit;Error.stackTraceLimit=0;const n=new z;Error.stackTraceLimit=e;const o=function(t,e,n){const o=$.get(t);return void 0===A&&(A=r(183)),A(\"function\"==typeof o),A(o.length<=e.length,`Code: ${t}; The provided arguments length (${e.length}) does not match the required ones (${o.length}).`),y(o,n,e)}(N,t,n);return u(n,\"message\",{value:o,enumerable:!1,writable:!0,configurable:!0}),u(n,\"toString\",{value(){return`${this.name} [${N}]: ${this.message}`},enumerable:!1,writable:!0,configurable:!0}),w(n,z.name,N),n.code=N,n})},335:t=>{const e=/\\u001b\\[\\d\\d?m/g;t.exports={customInspectSymbol:Symbol.for(\"nodejs.util.inspect.custom\"),isError:t=>t instanceof Error,join:Array.prototype.join.call.bind(Array.prototype.join),removeColors:t=>String.prototype.replace.call(t,e,\"\")}},63:(t,e,r)=>{const{getConstructorName:n}=r(891);function o(t,...e){for(const r of e){const e=globalThis[r];if(e&&t instanceof e)return!0}for(;t;){if(\"object\"!=typeof t)return!1;if(e.indexOf(n(t))>=0)return!0;t=Object.getPrototypeOf(t)}return!1}function i(t){return e=>{if(!o(e,t.name))return!1;try{t.prototype.valueOf.call(e)}catch{return!1}return!0}}\"object\"!=typeof globalThis&&(Object.defineProperty(Object.prototype,\"__magic__\",{get:function(){return this},configurable:!0}),__magic__.globalThis=__magic__,delete Object.prototype.__magic__);const l=i(String),c=i(Number),s=i(Boolean),a=i(BigInt),p=i(Symbol);t.exports={isAsyncFunction:t=>\"function\"==typeof t&&Function.prototype.toString.call(t).startsWith(\"async\"),isGeneratorFunction:t=>\"function\"==typeof t&&Function.prototype.toString.call(t).match(/^(async\\s+)?function *\\*/),isAnyArrayBuffer:t=>o(t,\"ArrayBuffer\",\"SharedArrayBuffer\"),isArrayBuffer:t=>o(t,\"ArrayBuffer\"),isArgumentsObject:t=>!1,isBoxedPrimitive:t=>c(t)||l(t)||s(t)||a(t)||p(t),isDataView:t=>o(t,\"DataView\"),isExternal:t=>\"object\"==typeof t&&Object.isFrozen(t)&&null==Object.getPrototypeOf(t),isMap(t){if(!o(t,\"Map\"))return!1;try{t.has()}catch{return!1}return!0},isMapIterator:t=>\"[object Map Iterator]\"===Object.prototype.toString.call(Object.getPrototypeOf(t)),isModuleNamespaceObject:t=>t&&\"object\"==typeof t&&\"Module\"===t[Symbol.toStringTag],isNativeError:t=>t instanceof Error&&o(t,\"Error\",\"EvalError\",\"RangeError\",\"ReferenceError\",\"SyntaxError\",\"TypeError\",\"URIError\",\"AggregateError\"),isPromise:t=>o(t,\"Promise\"),isSet(t){if(!o(t,\"Set\"))return!1;try{t.has()}catch{return!1}return!0},isSetIterator:t=>\"[object Set Iterator]\"===Object.prototype.toString.call(Object.getPrototypeOf(t)),isWeakMap:t=>o(t,\"WeakMap\"),isWeakSet:t=>o(t,\"WeakSet\"),isRegExp:t=>o(t,\"RegExp\"),isDate(t){if(o(t,\"Date\"))try{return Date.prototype.getTime.call(t),!0}catch{}return!1},isTypedArray:t=>o(t,\"Int8Array\",\"Uint8Array\",\"Uint8ClampedArray\",\"Int16Array\",\"Uint16Array\",\"Int32Array\",\"Uint32Array\",\"Float32Array\",\"Float64Array\",\"BigInt64Array\",\"BigUint64Array\"),isStringObject:l,isNumberObject:c,isBooleanObject:s,isBigIntObject:a,isSymbolObject:p}},356:(t,e,r)=>{const{hideStackFrames:n,codes:{ERR_INVALID_ARG_TYPE:o}}=r(101);e.validateObject=n(((t,e,{nullable:r=!1}={})=>{if(!r&&null===t||Array.isArray(t)||\"object\"!=typeof t)throw new o(e,\"Object\",t)}))},765:t=>{const e=(t,e)=>{class r{constructor(e){this._iterator=t(e)}next(){return e(this._iterator)}[Symbol.iterator](){return this}}return Object.setPrototypeOf(r.prototype,null),Object.freeze(r.prototype),Object.freeze(r),r};function r(t,e){return Function.prototype.call.bind(t.prototype.__lookupGetter__(e))}function n(t){return Function.prototype.call.bind(t)}const o=(t,e)=>{Array.prototype.forEach.call(Reflect.ownKeys(t),(r=>{Reflect.getOwnPropertyDescriptor(e,r)||Reflect.defineProperty(e,r,Reflect.getOwnPropertyDescriptor(t,r))}))},i=(t,r)=>{if(Symbol.iterator in t.prototype){const o=new t;let i;Array.prototype.forEach.call(Reflect.ownKeys(t.prototype),(l=>{if(!Reflect.getOwnPropertyDescriptor(r.prototype,l)){const c=Reflect.getOwnPropertyDescriptor(t.prototype,l);if(\"function\"==typeof c.value&&0===c.value.length&&Symbol.iterator in(Function.prototype.call.call(c.value,o)||{})){const t=n(c.value);null==i&&(i=n(t(o).next));const r=e(t,i);c.value=function(){return new r(this)}}Reflect.defineProperty(r.prototype,l,c)}}))}else o(t.prototype,r.prototype);return o(t,r),Object.setPrototypeOf(r.prototype,null),Object.freeze(r.prototype),Object.freeze(r),r},l=Function.prototype.call.bind(String.prototype[Symbol.iterator]),c=Reflect.getPrototypeOf(l(\"\"));t.exports={makeSafe:i,internalBinding(t){if(\"config\"===t)return{hasIntl:!1};throw new Error(`unknown module: \"${t}\"`)},Array,ArrayIsArray:Array.isArray,ArrayPrototypeFilter:Function.prototype.call.bind(Array.prototype.filter),ArrayPrototypeForEach:Function.prototype.call.bind(Array.prototype.forEach),ArrayPrototypeIncludes:Function.prototype.call.bind(Array.prototype.includes),ArrayPrototypeIndexOf:Function.prototype.call.bind(Array.prototype.indexOf),ArrayPrototypeJoin:Function.prototype.call.bind(Array.prototype.join),ArrayPrototypePop:Function.prototype.call.bind(Array.prototype.pop),ArrayPrototypePush:Function.prototype.call.bind(Array.prototype.push),ArrayPrototypePushApply:Function.apply.bind(Array.prototype.push),ArrayPrototypeSort:Function.prototype.call.bind(Array.prototype.sort),ArrayPrototypeSplice:Function.prototype.call.bind(Array.prototype.slice),ArrayPrototypeUnshift:Function.prototype.call.bind(Array.prototype.unshift),BigIntPrototypeValueOf:Function.prototype.call.bind(BigInt.prototype.valueOf),BooleanPrototypeValueOf:Function.prototype.call.bind(Boolean.prototype.valueOf),DatePrototypeGetTime:Function.prototype.call.bind(Date.prototype.getTime),DatePrototypeToISOString:Function.prototype.call.bind(Date.prototype.toISOString),DatePrototypeToString:Function.prototype.call.bind(Date.prototype.toString),ErrorCaptureStackTrace:function(t){const e=(new Error).stack;t.stack=e.replace(/.*\\n.*/,\"$1\")},ErrorPrototypeToString:Function.prototype.call.bind(Error.prototype.toString),FunctionPrototypeCall:Function.prototype.call.bind(Function.prototype.call),FunctionPrototypeToString:Function.prototype.call.bind(Function.prototype.toString),JSONStringify:JSON.stringify,MapPrototypeGetSize:r(Map,\"size\"),MapPrototypeEntries:Function.prototype.call.bind(Map.prototype.entries),MathFloor:Math.floor,MathMax:Math.max,MathMin:Math.min,MathRound:Math.round,MathSqrt:Math.sqrt,Number,NumberIsNaN:Number.isNaN,NumberParseFloat:Number.parseFloat,NumberParseInt:Number.parseInt,NumberPrototypeValueOf:Function.prototype.call.bind(Number.prototype.valueOf),Object,ObjectAssign:Object.assign,ObjectCreate:Object.create,ObjectDefineProperty:Object.defineProperty,ObjectGetOwnPropertyDescriptor:Object.getOwnPropertyDescriptor,ObjectGetOwnPropertyNames:Object.getOwnPropertyNames,ObjectGetOwnPropertySymbols:Object.getOwnPropertySymbols,ObjectGetPrototypeOf:Object.getPrototypeOf,ObjectIs:Object.is,ObjectKeys:Object.keys,ObjectPrototypeHasOwnProperty:Function.prototype.call.bind(Object.prototype.hasOwnProperty),ObjectPrototypePropertyIsEnumerable:Function.prototype.call.bind(Object.prototype.propertyIsEnumerable),ObjectSeal:Object.seal,ObjectSetPrototypeOf:Object.setPrototypeOf,ReflectApply:Reflect.apply,ReflectOwnKeys:Reflect.ownKeys,RegExp,RegExpPrototypeTest:Function.prototype.call.bind(RegExp.prototype.test),RegExpPrototypeToString:Function.prototype.call.bind(RegExp.prototype.toString),SafeStringIterator:e(l,Function.prototype.call.bind(c.next)),SafeMap:i(Map,class extends Map{constructor(t){super(t)}}),SafeSet:i(Set,class extends Set{constructor(t){super(t)}}),SetPrototypeGetSize:r(Set,\"size\"),SetPrototypeValues:Function.prototype.call.bind(Set.prototype.values),String,StringPrototypeCharCodeAt:Function.prototype.call.bind(String.prototype.charCodeAt),StringPrototypeCodePointAt:Function.prototype.call.bind(String.prototype.codePointAt),StringPrototypeEndsWith:Function.prototype.call.bind(String.prototype.endsWith),StringPrototypeIncludes:Function.prototype.call.bind(String.prototype.includes),StringPrototypeNormalize:Function.prototype.call.bind(String.prototype.normalize),StringPrototypePadEnd:Function.prototype.call.bind(String.prototype.padEnd),StringPrototypePadStart:Function.prototype.call.bind(String.prototype.padStart),StringPrototypeRepeat:Function.prototype.call.bind(String.prototype.repeat),StringPrototypeReplace:Function.prototype.call.bind(String.prototype.replace),StringPrototypeSlice:Function.prototype.call.bind(String.prototype.slice),StringPrototypeSplit:Function.prototype.call.bind(String.prototype.split),StringPrototypeToLowerCase:Function.prototype.call.bind(String.prototype.toLowerCase),StringPrototypeTrim:Function.prototype.call.bind(String.prototype.trim),StringPrototypeValueOf:Function.prototype.call.bind(String.prototype.valueOf),SymbolPrototypeToString:Function.prototype.call.bind(Symbol.prototype.toString),SymbolPrototypeValueOf:Function.prototype.call.bind(Symbol.prototype.valueOf),SymbolIterator:Symbol.iterator,SymbolFor:Symbol.for,SymbolToStringTag:Symbol.toStringTag,TypedArrayPrototypeGetLength:(\"length\",t=>t.constructor.prototype.__lookupGetter__(\"length\").call(t)),Uint8Array,uncurryThis:n}},161:t=>{const e=new WeakMap;class r{constructor(t,r){const n=new Proxy(t,r);return e.set(n,[t,r]),n}static getProxyDetails(t,r=!0){const n=e.get(t);if(n)return r?n:n[0]}}t.exports={getProxyDetails:r.getProxyDetails.bind(r),Proxy:r}},891:(t,e,r)=>{const n=r(161),o=Symbol(\"kPending\"),i=Symbol(\"kRejected\");t.exports={getOwnNonIndexProperties:function(t,e=2){const r=Object.getOwnPropertyDescriptors(t),n=[];for(const[t,o]of Object.entries(r))if(!/^(0|[1-9][0-9]*)$/.test(t)||parseInt(t,10)>=2**32-1){if(2===e&&!o.enumerable)continue;n.push(t)}for(const r of Object.getOwnPropertySymbols(t)){const o=Object.getOwnPropertyDescriptor(t,r);(2!==e||o.enumerable)&&n.push(r)}return n},getPromiseDetails:()=>[o,void 0],getProxyDetails:n.getProxyDetails,Proxy:n.Proxy,kPending:o,kRejected:i,previewEntries:t=>[[],!1],getConstructorName(t){if(!t||\"object\"!=typeof t)throw new Error(\"Invalid object\");if(t.constructor&&t.constructor.name)return t.constructor.name;const e=Object.prototype.toString.call(t).match(/^\\[object ([^\\]]+)\\]/);return e?e[1]:\"Object\"},getExternalValue:()=>BigInt(0),propertyFilter:{ALL_PROPERTIES:0,ONLY_ENUMERABLE:2}}}},e={};function r(n){if(e[n])return e[n].exports;var o=e[n]={exports:{}};return t[n](o,o.exports,r),o.exports}return r.g=function(){if(\"object\"==typeof globalThis)return globalThis;try{return this||new Function(\"return this\")()}catch(t){if(\"object\"==typeof window)return window}}(),r(48)})()}));\n\n//# sourceURL=webpack://webpack-demo/./node_modules/node-inspect-extracted/dist/inspect.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/***/ ((module) => {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack://webpack-demo/./node_modules/process/browser.js?");

/***/ }),

/***/ "./src/index-wp.js":
/*!*************************!*\
  !*** ./src/index-wp.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint-disable no-undef */\n\nconst cbor = __webpack_require__(/*! cbor-web */ \"./node_modules/cbor-web/dist/cbor.js\")\nconst { inspect } = __webpack_require__(/*! node-inspect-extracted */ \"./node_modules/node-inspect-extracted/dist/inspect.js\")\nconst { Buffer } = __webpack_require__(/*! buffer */ \"./node_modules/buffer/index.js\")\n\n// eslint-disable-next-line no-unused-vars\nconst process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\")\n// eslint-disable-next-line no-unused-vars\nconst style = __webpack_require__(/*! ./style.css */ \"./src/style.css\")\n\nconst ofmt = document.getElementById('output-fmt')\nconst otxt = document.getElementById('output-text')\nconst itxt = document.getElementById('input-text')\nconst ifmt = document.getElementById('input-fmt')\nconst copy = document.getElementById('copy')\n\nfunction error(e) {\n  copy.disabled = true\n  otxt.value = e.toString()\n}\n\n// convert any input to a buffer\nfunction input() {\n  const inp = ifmt.selectedOptions[0].label\n  const txt = itxt.value\n  switch (inp) {\n    case 'JSON':\n      return cbor.encodeOne(JSON.parse(txt), {canonical: true})\n    case 'hex':\n    case 'base64':\n      return Buffer.from(txt, inp)\n    default:\n      throw new Error(`Unknown input: \"${inp}\"`)\n  }\n}\n\n// convert a buffer to the desired output format\nfunction output(buf, typ) {\n  const outp = ofmt.selectedOptions[0].label\n  switch (outp) {\n    case 'hex':\n    case 'base64':\n      copy.disabled = false\n      otxt.value = buf.toString(outp)\n      break\n    case 'commented':\n      copy.disabled = true\n      cbor.comment(buf).then(txt => {\n        otxt.value = txt\n      }, error)\n      break\n    case 'diagnostic':\n      copy.disabled = true\n      cbor.diagnose(buf).then(txt => {\n        otxt.value = txt\n      }, error)\n      break\n    case 'js':\n      copy.disabled = true\n      cbor.decodeFirst(buf).then(o => {\n        otxt.value = inspect(o, {\n          depth: Infinity,\n          compact: 1,\n          maxArrayLength: Infinity,\n          breakLength: otxt.cols - 1\n        })\n      }, error)\n      break\n    case 'JSON':\n      copy.disabled = false\n      cbor.decodeFirst(buf).then(o => {\n        otxt.value = JSON.stringify(o, null, 2)\n      }, error)\n      break\n    default:\n      throw new Error(`Unknown output: \"${outp}\"`)\n  }\n}\n\nfunction convert() {\n  try {\n    output(input())\n  } catch (e) {\n    error(e)\n    throw e\n  }\n}\n\nofmt.oninput = convert\nifmt.oninput = convert\ncopy.onclick = () => {\n  // copy output to input, and guess the new input format\n  itxt.value = otxt.value\n  const sel = ofmt.selectedOptions[0].label\n  for (const o of ifmt.options) {\n    if (o.label === sel) {\n      ifmt.selectedIndex = o.index\n      break\n    }\n  }\n}\n\n// debounce\nlet timeout = null\nitxt.oninput = () => {\n  clearTimeout(timeout)\n  timeout = setTimeout(() => {\n    timeout = null\n    convert()\n  }, 300)\n}\n\n// make sure that initial output is set\nconvert()\n\n\n//# sourceURL=webpack://webpack-demo/./src/index-wp.js?");

/***/ }),

/***/ "util":
/*!*********************!*\
  !*** external "{}" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = {};

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index-wp.js");
/******/ 	
/******/ })()
;